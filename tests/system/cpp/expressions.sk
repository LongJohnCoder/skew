namespace cpp { void testExpressions() {

testCPP("
export bool foo(int a, int b, int c, int d) {
  return (a == b) == (c == d)
}
", "
bool foo(int a, int b, int c, int d);

bool foo(int a, int b, int c, int d) {
  return a == b == (c == d);
}
")

testCPP("
export var x = [
  0b1100100,
  0100,
  0o144,
  0x64,
  0xabc,
  0xABC,
]
", "
#include <initializer_list>
#include <vector>

template <typename T>
struct List;

template <typename T>
struct List {
  List();
  List<T> *literal(std::initializer_list<T> list);

  std::vector<T> _data;
};

extern List<int> *x;

template <typename T>
List<T>::List() : _data() {
}

template <typename T>
List<T> *List<T>::literal(std::initializer_list<T> list) {
  _data.insert(_data.end(), list.begin(), list.end());
  return this;
}

List<int> *x = (new List<int>())->literal({ 100, 100, 100, 100, 2748, 2748 });
")

// Need to special-case strings with '\0' in them to avoid truncation
testCPP("
export var foo = \"'\"
export var bar = \"\\\"\"
export var baz = \"abc \\0 def\"
", "
#include <string>

extern std::string foo;
extern std::string bar;
extern std::string baz;

std::string foo = \"'\";
std::string bar = \"\\\"\";
std::string baz = std::string(\"abc \\0 def\", 9);
")

testCPP("
export void test() {
  double x = 0
  - -1
  + +1
  - +1
  + -1
}
", "
void test();

void test() {
  double x = 0;
  - -1;
  + +1;
  -+1;
  +-1;
}
")

testCPP("
export void test() {
  -0x80000000
  - -0x80000000
}
", "
void test();

void test() {
  -2147483648;
  - -2147483648;
}
")

testCPP("
export void test() {
  float x = 0
  (1f - 2f) - 3f
  (1f / 2f) * 3f
  1e30f - (2e30f - 3e30f)
  1e-30f / (2e-30f * 3e-30f)
}
", "
void test();

void test() {
  float x = 0;
  1.0f - 2.0f - 3.0f;
  1.0f / 2.0f * 3.0f;
  1.0e+30f - (2.0e+30f - 3.0e+30f);
  1.0e-30f / (2.0e-30f * 3.0e-30f);
}
")

testCPP("
export void test() {
  double x = 0
  (1.0 - 2.0) - 3.0
  (1.0 / 2.0) * 3.0
  1e30 - (2e30 - 3e30)
  1e-30 / (2e-30 * 3e-30)
}
", "
void test();

void test() {
  double x = 0;
  1.0 - 2.0 - 3.0;
  1.0 / 2.0 * 3.0;
  1.0e+30 - (2.0e+30 - 3.0e+30);
  1.0e-30 / (2.0e-30 * 3.0e-30);
}
")

testCPP("
export void test() {
  (bool)1
  (int)false
  (float)false
}
", "
void test();

void test() {
  static_cast<bool>(1);
  static_cast<int>(false);
  static_cast<float>(false);
}
")

testCPP("
export void test() {
  (bool)1
}
", "
void test();

void test() {
  !!1;
}
").windows()

testCPP("
export void test() {
  assert (bool)1
}
", "
#include <cassert>

void test();

void test() {
  assert(static_cast<bool>(1));
}
")

testCPP("
enum Foo {}
export int a(Foo x) { return (int)x }
export Foo b(int x) { return (Foo)x }
export int c(int x) { return (int)(Foo)x }
export Foo d(Foo x) { return (Foo)(int)x }
", "
enum struct Foo {
};

int a(Foo x);
Foo b(int x);
int c(int x);
Foo d(Foo x);

int a(Foo x) {
  return static_cast<int>(x);
}

Foo b(int x) {
  return static_cast<Foo>(x);
}

int c(int x) {
  return static_cast<int>(static_cast<Foo>(x));
}

Foo d(Foo x) {
  return static_cast<Foo>(static_cast<int>(x));
}
")

testCPP("
enum flags Foo {}
export int a(Foo x) { return (int)x }
export Foo b(int x) { return (Foo)x }
export int c(int x) { return (int)(Foo)x }
export Foo d(Foo x) { return (Foo)(int)x }
", "
namespace Foo {
  enum {
  };
}

int a(int x);
int b(int x);
int c(int x);
int d(int x);

int a(int x) {
  return static_cast<int>(x);
}

int b(int x) {
  return static_cast<int>(x);
}

int c(int x) {
  return static_cast<int>(static_cast<int>(x));
}

int d(int x) {
  return static_cast<int>(static_cast<int>(x));
}
")

testCPP("
enum flags Foo {}
export int a(Foo x) { return x }
", "
namespace Foo {
  enum {
  };
}

int a(int x);

int a(int x) {
  return x;
}
")

testCPP("
export void test() {
  int foo = (1, 2)
  foo = (1, 2)
  (1, 2), (3, 4)
}
", "
void test();

void test() {
  int foo = (1, 2);
  foo = (1, 2);
  (1, 2), (3, 4);
}
")

testCPP("
export void test() {
  0.toString()
  0.0f.toString()
  0.0.toString()
}
", "
#include <cstdio>
#include <string>

namespace in_double {
  std::string _format_(double value);
}

void test();

std::string in_double::_format_(double value) {
  std::string buffer = \"\";
  buffer.resize(64);
  std::snprintf(&buffer[0], buffer.size(), \"%.15g\", value);

  if (std::stod(&buffer[0]) != value) {
    std::snprintf(&buffer[0], buffer.size(), \"%.16g\", value);

    if (std::stod(&buffer[0]) != value) {
      std::snprintf(&buffer[0], buffer.size(), \"%.17g\", value);
    }
  }

  return buffer.c_str();
}

void test() {
  std::to_string(0);
  in_double::_format_(0.0f);
  in_double::_format_(0.0);
}
")

testCPP("
export void test() {
  0.toString()
  0.0f.toString()
  0.0.toString()
}
", "
#include <stdio.h>
#include <string>

namespace in_double {
  std::string _format_(double value);
}

void test();

std::string in_double::_format_(double value) {
  std::string buffer = \"\";
  buffer.resize(64);
  sprintf_s(&buffer[0], buffer.size(), \"%.15g\", value);

  if (std::stod(&buffer[0]) != value) {
    sprintf_s(&buffer[0], buffer.size(), \"%.16g\", value);

    if (std::stod(&buffer[0]) != value) {
      sprintf_s(&buffer[0], buffer.size(), \"%.17g\", value);
    }
  }

  return buffer.c_str();
}

void test() {
  std::to_string(0);
  in_double::_format_(0.0f);
  in_double::_format_(0.0);
}
").windows()

testCPP("
export void test(bool a) {
  var b = a ? \"1\" : \"2\"
}
", "
#include <string>

void test(bool a);

void test(bool a) {
  std::string b = a ? std::string(\"1\") : \"2\";
}
")

// Need to make implicit casts explicit here to avoid compile errors
testCPP("
class Foo {}
class Bar : Foo {}
class Baz : Foo {}
export void foo(Foo foo) {
  foo = true ? Foo() : Foo()
  foo = true ? Foo() : Baz()
  foo = true ? Bar() : Foo()
  foo = true ? Bar() : Baz()
  foo = true ? Bar() : null
  foo = true ? null : Baz()
  foo = true ? null : null
}
", "
struct Foo;
struct Bar;
struct Baz;

struct Foo {
  Foo();
};

struct Bar : Foo {
  Bar();
};

struct Baz : Foo {
  Baz();
};

void foo(Foo *foo);

Foo::Foo() {
}

Bar::Bar() {
}

Baz::Baz() {
}

void foo(Foo *foo) {
  foo = true ? new Foo() : new Foo();
  foo = true ? new Foo() : new Baz();
  foo = true ? static_cast<Foo *>(new Bar()) : new Foo();
  foo = true ? static_cast<Foo *>(new Bar()) : new Baz();
  foo = true ? new Bar() : nullptr;
  foo = true ? nullptr : new Baz();
  foo = true ? nullptr : nullptr;
}
")

testCPP("
alias foo = `foo`
export void bar() { foo() }
", "
void bar();

void bar() {
  new foo();
}
")

testCPP("
class Foo<T> {}
export Foo<`foo`> bar
", "
template <typename T>
struct Foo;

template <typename T>
struct Foo {
  Foo();
};

extern Foo<foo> *bar;

template <typename T>
Foo<T>::Foo() {
}

Foo<foo> *bar = nullptr;
")

testCPP("
export int foo() {
  return List<int>().size() // The constructor call must be wrapped in parentheses
}
", "
#include <initializer_list>
#include <vector>

template <typename T>
struct List;

template <typename T>
struct List {
  List();
  int size();
  List<T> *literal(std::initializer_list<T> list);

  std::vector<T> _data;
};

int foo();

template <typename T>
List<T>::List() : _data() {
}

template <typename T>
int List<T>::size() {
  return static_cast<int>(_data.size());
}

template <typename T>
List<T> *List<T>::literal(std::initializer_list<T> list) {
  _data.insert(_data.end(), list.begin(), list.end());
  return this;
}

int foo() {
  return (new List<int>())->size();
}
")

testCPP("
#define FOO false
export var foo = FOO
export bool bar() { return FOO }
", "
bool bar();

extern bool foo;

bool bar() {
  return false;
}

bool foo = false;
")

testCPP("
export bool foo() {
  const var foo = false
  return foo
}
", "
bool foo();

bool foo() {
  bool foo = false;
  return foo;
}
")

testCPP("
enum Foo { FOO = 1 }
export var foo = { Foo.FOO: 2 }
", "
#include <cassert>
#include <initializer_list>
#include <unordered_map>
#include <vector>

template <typename T>
struct List;
template <typename T>
struct IntMap;

template <typename T>
struct List {
  List();
  int size();
  T get(int index);
  List<T> *literal(std::initializer_list<T> list);

  std::vector<T> _data;
};

template <typename T>
struct IntMap {
  IntMap();
  void set(int key, T value);

  std::unordered_map<int, T> _table;
};

namespace in_IntMap {
  template <typename X>
  IntMap<X> *literal(List<int> *keys, List<X> *values);
}

extern IntMap<int> *foo;

template <typename T>
List<T>::List() : _data() {
}

template <typename T>
int List<T>::size() {
  return static_cast<int>(_data.size());
}

template <typename T>
T List<T>::get(int index) {
  assert(index >= 0 && index < size());
  return _data[index];
}

template <typename T>
List<T> *List<T>::literal(std::initializer_list<T> list) {
  _data.insert(_data.end(), list.begin(), list.end());
  return this;
}

template <typename T>
IntMap<T>::IntMap() : _table() {
}

template <typename T>
void IntMap<T>::set(int key, T value) {
  _table[key] = value;
}

template <typename X>
IntMap<X> *in_IntMap::literal(List<int> *keys, List<X> *values) {
  IntMap<X> *map = new IntMap<X>();
  assert(keys->size() == values->size());

  for (int i = 0; i < keys->size(); i++) {
    map->set(keys->get(i), values->get(i));
  }

  return map;
}

IntMap<int> *foo = in_IntMap::literal<int>((new List<int>())->literal({ 1 }), (new List<int>())->literal({ 2 }));
")

testCPP("
export void foo() {
  -0 ** 1 ** -2
}
", "
#include <cmath>

void foo();

void foo() {
  std::pow(-0, std::pow(1, -2));
}
")

testCPP("
export void foo() {
  `*(int *)0 = 1`
}
", "
void foo();

void foo() {
  *(int *)0 = 1;
}
")

}}
