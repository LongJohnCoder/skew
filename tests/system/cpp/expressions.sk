namespace cpp { void testExpressions() {

// Need to special-case strings with '\0' in them to avoid truncation
testCPP("
export var foo = \"'\";
export var bar = \"\\\"\";
export var baz = \"abc \\0 def\";
", "
#include <string>

extern std::string foo;
extern std::string bar;
extern std::string baz;

std::string foo = \"'\";
std::string bar = \"\\\"\";
std::string baz = std::string(\"abc \\0 def\", 9);
");

testCPP("
export void test() {
  double x = 0;
  - -1;
  + +1;
  - +1;
  + -1;
}
", "
void test();

void test() {
  double x = 0;
  - -1;
  + +1;
  -+1;
  +-1;
}
");

testCPP("
export void test() {
  - -0x80000000;
}
", "
void test();

void test() {
  - -2147483648;
}
");

testCPP("
export void test() {
  float x = 0;
  (1f - 2f) - 3f;
  (1f / 2f) * 3f;
  1f - (2f - 3f);
  1f / (2f * 3f);
}
", "
void test();

void test() {
  float x = 0;
  1.0f - 2.0f - 3.0f;
  1.0f / 2.0f * 3.0f;
  1.0f - (2.0f - 3.0f);
  1.0f / (2.0f * 3.0f);
}
");

testCPP("
export void test() {
  double x = 0;
  (1.0 - 2.0) - 3.0;
  (1.0 / 2.0) * 3.0;
  1.0 - (2.0 - 3.0);
  1.0 / (2.0 * 3.0);
}
", "
void test();

void test() {
  double x = 0;
  1.0 - 2.0 - 3.0;
  1.0 / 2.0 * 3.0;
  1.0 - (2.0 - 3.0);
  1.0 / (2.0 * 3.0);
}
");

testCPP("
export void test() {
  (bool)1;
  (int)false;
  (float)false;
}
", "
void test();

void test() {
  static_cast<bool>(1);
  static_cast<int>(false);
  static_cast<float>(false);
}
");

testCPP("
export void test() {
  assert (bool)1;
}
", "
#include <cassert>

void test();

void test() {
  assert(static_cast<bool>(1));
}
");

testCPP("
enum Foo {}
export int a(Foo x) { return (int)x; }
export Foo b(int x) { return (Foo)x; }
export int c(int x) { return (int)(Foo)x; }
export Foo d(Foo x) { return (Foo)(int)x; }
", "
enum struct Foo {
};

int a(Foo x);
Foo b(int x);
int c(int x);
Foo d(Foo x);

int a(Foo x) {
  return static_cast<int>(x);
}

Foo b(int x) {
  return static_cast<Foo>(x);
}

int c(int x) {
  return static_cast<int>(static_cast<Foo>(x));
}

Foo d(Foo x) {
  return static_cast<Foo>(static_cast<int>(x));
}
");

testCPP("
enum flags Foo {}
export int a(Foo x) { return (int)x; }
export Foo b(int x) { return (Foo)x; }
export int c(int x) { return (int)(Foo)x; }
export Foo d(Foo x) { return (Foo)(int)x; }
", "
namespace Foo {
  enum {
  };
}

int a(int x);
int b(int x);
int c(int x);
int d(int x);

int a(int x) {
  return static_cast<int>(x);
}

int b(int x) {
  return static_cast<int>(x);
}

int c(int x) {
  return static_cast<int>(static_cast<int>(x));
}

int d(int x) {
  return static_cast<int>(static_cast<int>(x));
}
");

testCPP("
enum flags Foo {}
export int a(Foo x) { return x; }
", "
namespace Foo {
  enum {
  };
}

int a(int x);

int a(int x) {
  return x;
}
");

testCPP("
export void test() {
  int foo = (1, 2);
  foo = (1, 2);
  (1, 2), (3, 4);
}
", "
void test();

void test() {
  int foo = (1, 2);
  foo = (1, 2);
  (1, 2), (3, 4);
}
");

testCPP("
export void test() {
  0.toString();
  0.0f.toString();
  0.0.toString();
}
", "
#include <cstdio>
#include <string>

namespace in_double {
  std::string _format_(double value);
}

void test();

std::string in_double::_format_(double value) {
  std::string buffer = \"\";
  buffer.resize(64);
  std::snprintf(&buffer[0], buffer.size(), \"%.15g\", value);

  if (std::stod(&buffer[0]) != value) {
    std::snprintf(&buffer[0], buffer.size(), \"%.16g\", value);

    if (std::stod(&buffer[0]) != value) {
      std::snprintf(&buffer[0], buffer.size(), \"%.17g\", value);
    }
  }

  return buffer.c_str();
}

void test() {
  std::to_string(0);
  in_double::_format_(0.0f);
  in_double::_format_(0.0);
}
");

testCPP("
export void test(bool a) {
  var b = a ? \"1\" : \"2\";
}
", "
#include <string>

void test(bool a);

void test(bool a) {
  std::string b = a ? std::string(\"1\") : \"2\";
}
");

// Need to make implicit casts explicit here to avoid compile errors
testCPP("
class Foo {}
class Bar : Foo {}
class Baz : Foo {}
export void foo(Foo foo) {
  foo = true ? Foo() : Foo();
  foo = true ? Foo() : Baz();
  foo = true ? Bar() : Foo();
  foo = true ? Bar() : Baz();
  foo = true ? Bar() : null;
  foo = true ? null : Baz();
  foo = true ? null : null;
}
", "
struct Foo;
struct Bar;
struct Baz;

struct Foo {
  Foo();
};

struct Bar : Foo {
  Bar();
};

struct Baz : Foo {
  Baz();
};

void foo(Foo *foo);

Foo::Foo() {
}

Bar::Bar() {
}

Baz::Baz() {
}

void foo(Foo *foo) {
  foo = true ? new Foo() : new Foo();
  foo = true ? new Foo() : new Baz();
  foo = true ? static_cast<Foo *>(new Bar()) : new Foo();
  foo = true ? static_cast<Foo *>(new Bar()) : new Baz();
  foo = true ? new Bar() : nullptr;
  foo = true ? nullptr : new Baz();
  foo = true ? nullptr : nullptr;
}
");

testCPP("
alias foo = `foo`;
export void bar() { foo(); }
", "
void bar();

void bar() {
  new foo();
}
");

testCPP("
class Foo<T> {}
export Foo<`foo`> bar;
", "
template <typename T>
struct Foo;

template <typename T>
struct Foo {
  Foo();
};

extern Foo<foo> *bar;

template <typename T>
Foo<T>::Foo() {
}

Foo<foo> *bar = nullptr;
");

testCPP("
class Foo {}
export void foo(int foo, int bar) {
  for (Foo x = null, y = null; x == y; x = y) {}
  for (`(void *)` x = null, y = null; x == y; x = y) {}
  for (`(int &)` x = foo, y = bar; foo == bar; foo++, bar--) {}
}
", "
struct Foo;

struct Foo {
  Foo();
};

void foo(int foo, int bar);

Foo::Foo() {
}

void foo(int foo, int bar) {
  for (Foo *x = nullptr, *y = nullptr; x == y; x = y) {
  }

  for (void *x = nullptr, *y = nullptr; x == y; x = y) {
  }

  for (int &x = foo, &y = bar; foo == bar; foo++, bar--) {
  }
}
");

}}
