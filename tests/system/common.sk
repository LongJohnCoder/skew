using tests
using unit

namespace tests {
  class FormatTest : Test {
    override void run() {
      rename(compactWhitespace(_input))
      var formatted = Range(Source("<stdin>", _input), _start, _end).format(_maxLength)
      expectString(trim(_expected), trim(formatted.line + "\n" + formatted.range))
    }

    private {
      string _input
      string _expected
      int _start
      int _end
      int _maxLength
    }
  }

  class CompilerTest : Test {
    override void run() {
      rename(compactWhitespace(_input))
      var compiler = Compiler(_options)
      compiler.addInput(Source("<stdin>", _input))
      var result = compiler.compile()
      var output = ""
      if (result.outputs.size() != 0) {
        for (var i = 0; i < result.outputs.size(); i++) {
          output += result.outputs[i].contents + "\n"
        }
      } else {
        output = _options.log.toString()
      }
      expectString(trim(_expected), trim(output))
    }

    CompilerTest js() {
      _options.target = .JAVASCRIPT
      return this
    }

    CompilerTest cpp() {
      _options.target = .CPP
      _options.config = .OSX
      return this
    }

    CompilerTest ruby() {
      _options.target = .RUBY
      return this
    }

    CompilerTest windows() {
      _options.config = .WINDOWS
      return this
    }

    CompilerTest release() {
      _options.minify = true
      _options.mangle = true
      _options.removeAsserts = true
      _options.foldAllConstants = true
      _options.inlineAllFunctions = true
      _options.globalizeAllFunctions = true
      return this
    }

    CompilerTest minify() {
      _options.minify = true
      return this
    }

    CompilerTest mangle() {
      _options.mangle = true
      return this
    }

    private {
      string _input
      string _expected
      var _options = CompilerOptions()
    }
  }

  bool isSpace(int c) {
    return c == ' ' || c == '\n'
  }

  string trim(string text) {
    var length = text.size()
    var start = 0
    var end = length
    while (start < length && isSpace(text[start])) {
      start++
    }
    while (start < end && isSpace(text[end - 1])) {
      end--
    }
    return text.slice(start, end)
  }

  string compactWhitespace(string text) {
    var wasSpace = false
    var result = ""
    for (var i = 0; i < text.size(); i++) {
      if (!isSpace(text[i])) {
        result += text.sliceCodeUnit(i)
        wasSpace = false
      } else if (!wasSpace) {
        result += " "
        wasSpace = true
      }
    }
    return result
  }
}

FormatTest testFormat(string input, string _expected, int start, int end, int maxLength) {
  return FormatTest(trim(input), _expected, start, end, maxLength)
}

CompilerTest test(string input, string _expected) {
  return CompilerTest(trim(input), _expected)
}

CompilerTest testJS(string input, string _expected) {
  return test(input, _expected).js()
}

CompilerTest testCPP(string input, string _expected) {
  return test(input, _expected).cpp()
}

CompilerTest testRuby(string input, string _expected) {
  return test(input, _expected).ruby()
}

@EntryPoint
int start() {
  core.testAccess()
  core.testAnnotations()
  core.testCalls()
  core.testConst()
  core.testConstructors()
  core.testConversions()
  core.testCyclic()
  core.testEnums()
  core.testExpressions()
  core.testFormatting()
  core.testFunctions()
  core.testGenerics()
  core.testLists()
  core.testMerging()
  core.testModifiers()
  core.testObjects()
  core.testParsing()
  core.testPreprocessor()
  core.testPurity()
  core.testShadowing()
  core.testStatements()
  core.testStatic()
  core.testSwitch()
  core.testTryCatch()
  core.testTypes()
  core.testUsing()
  core.testVar()

  js.testAnnotations()
  js.testExpressions()
  js.testFunctions()
  js.testInlining()
  js.testMinify()
  js.testObjects()
  js.testStatements()

  cpp.testAnnotations()
  cpp.testExpressions()
  cpp.testFunctions()
  cpp.testNeedsInclude()
  cpp.testObjects()
  cpp.testRelease()
  cpp.testStatements()

  ruby.testExpressions()
  ruby.testStatements()

  var report = TerminalReport()
  Test.runAll(report)
  return report.failedCount()
}
