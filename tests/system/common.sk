using tests;

namespace tests {
  enum Status {
    PENDING,
    FAILED,
    SUCCEEDED,
  }

  class Test {
    string input;
    string expected;
    var output = "";
    var options = CompilerOptions();
    Status status = .PENDING;

    void run() {
      options.inputs = [Source("<stdin>", input)];
      var compiler = Compiler();
      var result = compiler.compile(options);
      if (result.outputs.size() > 0) {
        for (var i = 0; i < result.outputs.size(); i++) {
          output += result.outputs[i].contents + "\n";
        }
      } else {
        output = compiler.log.toString();
      }
      output = trim(output);
      expected = trim(expected);
      status = output == expected ? .SUCCEEDED : .FAILED;
    }

    Test js() {
      options.targetFormat = .JAVASCRIPT;
      return this;
    }

    Test cpp() {
      options.targetFormat = .CPP;
      return this;
    }

    Test release() {
      options.minify = true;
      options.mangle = true;
      options.removeAsserts = true;
      options.foldAllConstants = true;
      options.inlineAllFunctions = true;
      options.globalizeAllFunctions = true;
      return this;
    }
  }

  List<Test> registeredTests = [];

  int runAllTests() {
    // Run the tests
    List<Test> failing = [];
    var width = terminal.width() * 3 / 4;
    var startTime = now();
    terminal.write("\n  ");
    for (var i = 0; i < registeredTests.size(); i++) {
      var test = registeredTests[i];
      test.run();
      var failed = test.status == .FAILED;
      terminal.setColor(failed ? .RED : .GREEN);
      terminal.write(failed ? "x" : ".");
      if (i + 1 < registeredTests.size() && width != 0 && i % width == width - 1) {
        terminal.write("\n  ");
      }
      terminal.setColor(.DEFAULT);
      terminal.flush();
      if (failed) {
        failing.push(test);
      }
    }
    terminal.print("\n");

    // Print the summary
    var totalTime = now() - startTime;
    terminal.setColor(.GREEN);
    terminal.write("  " + (registeredTests.size() - failing.size()) + " passing");
    terminal.setColor(.GRAY);
    terminal.print("  (" + formatNumber(totalTime) + "ms)");
    if (failing.size() != 0) {
      terminal.setColor(.RED);
      terminal.print("  " + failing.size() + " failing");
    }
    terminal.setColor(.DEFAULT);
    terminal.print("");

    // Print the failed tests
    var indent = " ".repeat(failing.size().toString().size() + 5);
    for (var i = 0; i < failing.size(); i++) {
      var test = failing[i];
      var text = "  " + (i + 1) + ")";
      var lines = test.input.split("\n");
      terminal.write(text + " ".repeat(indent.size() - text.size()));
      terminal.setColor(.BOLD);
      terminal.print("Test:\n");
      terminal.setColor(.GRAY);
      for (var j = 0; j < lines.size(); j++) {
        terminal.print(indent + "  " + lines[j]);
      }
      terminal.setColor(.BOLD);
      terminal.print("\n" + indent + "Output:\n");
      printDiff(indent + " ",
        test.expected == "" ? [] : test.expected.split("\n"),
        test.output == "" ? [] : test.output.split("\n"));
      terminal.setColor(.DEFAULT);
      terminal.print("");
    }
    return failing.size();
  }

  void printDiff(string indent, List<string> expected, List<string> output) {
    var m = expected.size();
    var n = output.size();
    List<int> matrix = [];

    // Solve for the lowest common subsequence length
    for (var i = 0, ij = 0; i < m; i++) {
      for (var j = 0; j < n; j++, ij++) {
        matrix.push(expected[i] == output[j]
          ? i > 0 && j > 0 ? matrix[ij - n - 1] + 1 : 1
          : imax(i > 0 ? matrix[ij - n] : 0, j > 0 ? matrix[ij - 1] : 0));
      }
    }

    // Extract the diff in reverse
    List<string> reversed = [];
    var i = m - 1;
    var j = n - 1;
    while (i >= 0 || j >= 0) {
      var ij = i * n + j;

      // Common
      if (i >= 0 && j >= 0 && expected[i] == output[j]) {
        reversed.push(" " + expected[i]);
        i--;
        j--;
      }

      // Removal
      else if (j >= 0 && (i < 0 || matrix[ij - 1] > matrix[ij - n])) {
        reversed.push("-" + output[j]);
        j--;
      }

      // Insertion
      else {
        assert i >= 0 && (j < 0 || matrix[ij - 1] <= matrix[ij - n]);
        reversed.push("+" + expected[i]);
        i--;
      }
    }

    // Print out the diff
    for (var i = reversed.size() - 1; i >= 0; i--) {
      var text = reversed[i];
      var c = text[0];
      terminal.setColor(c == '+' ? .GREEN : c == '-' ? .RED : .GRAY);
      terminal.print(indent + text);
    }
  }

  bool isSpace(int c) {
    return c == ' ' || c == '\n';
  }

  string trim(string text) {
    var length = text.size();
    var start = 0;
    var end = length;
    while (start < length && isSpace(text[start])) {
      start++;
    }
    while (start < end && isSpace(text[end - 1])) {
      end--;
    }
    return text.slice(start, end);
  }
}

void test(string input, string expected) {
  registeredTests.push(Test(trim(input), expected));
}

void testJS(string input, string expected) {
  registeredTests.push(Test(trim(input), expected).js());
}

void testCPP(string input, string expected) {
  registeredTests.push(Test(trim(input), expected).cpp());
}

void testMinifyJS(string input, string expected) {
  registeredTests.push(Test(trim(input), expected).js().release());
}

@EntryPoint
int start() {
  core.testAnnotations();
  core.testCalls();
  core.testConst();
  core.testConstructors();
  core.testConversions();
  core.testCyclic();
  core.testEnums();
  core.testExpressions();
  core.testFunctions();
  core.testGenerics();
  core.testLists();
  core.testMerging();
  core.testModifiers();
  core.testObjects();
  core.testParsing();
  core.testPreprocessor();
  core.testStatements();
  core.testStatic();
  core.testSwitch();
  core.testTypes();
  core.testUsing();
  core.testVar();

  js.testAnnotations();
  js.testExpressions();
  js.testFunctions();
  js.testInlining();
  js.testMinify();
  js.testObjects();
  js.testStatements();

  cpp.testAnnotations();
  cpp.testExpressions();
  cpp.testFunctions();
  cpp.testNeedsInclude();
  cpp.testObjects();

  return runAllTests();
}
