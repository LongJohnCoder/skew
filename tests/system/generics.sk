test("
class Foo<T is int> {}
", "
<stdin>:1:16: error: Cannot use type \"int\" as a type parameter bound
class Foo<T is int> {}
               ~~~
");

test("
class Foo<T is void> {}
", "
<stdin>:1:16: error: Cannot use type \"void\" as a type parameter bound
class Foo<T is void> {}
               ~~~~
");

test("
class Foo<T is Bar> {}
class Bar {}
", "
<stdin>:1:16: error: Cannot use type \"Bar\" as a type parameter bound
class Foo<T is Bar> {}
               ~~~
");

test("
class Foo<T is IBar> {}
interface IBar {}
", "
");

test("
class Foo<T is IBar<int>> {}
interface IBar<T> {}
", "
");

test("
class Foo<A, B is A> {}
", "
<stdin>:1:19: error: Cannot use type \"A\" as a type parameter bound
class Foo<A, B is A> {}
                  ^
");

test("
class Foo<A is B, B> {}
", "
<stdin>:1:16: error: Cannot use type \"B\" as a type parameter bound
class Foo<A is B, B> {}
               ^
");

test("
interface IFoo {
  bool foo(int bar);
}
class Foo<T is IFoo> {
  int foo(T value) {
    return value.foo(false);
  }
}
", "
<stdin>:6:22: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    return value.foo(false);
                     ~~~~~
<stdin>:6:12: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    return value.foo(false);
           ~~~~~~~~~~~~~~~~
");

test("
int<int> foo = 0;
void fn()<int> bar = 0;
", "
<stdin>:1:1: error: Cannot parameterize type \"int\" because it has no type parameters
int<int> foo = 0;
~~~
<stdin>:2:1: error: Cannot parameterize type \"void fn()\" because it has no type parameters
void fn()<int> bar = 0;
~~~~~~~~~
");

test("
class Foo<T> {}
Foo<int, int> foo = 0;
", "
<stdin>:2:4: error: Expected 1 type parameter but found 2 type parameters
Foo<int, int> foo = 0;
   ~~~~~~~~~~
");

test("
Foo<Bar> foo = 0;
Foo<Baz> bar = 0;
class Foo<T is IFoo> {}
interface IFoo {}
class Bar : IFoo {}
class Baz {}
", "
<stdin>:1:16: error: Cannot convert from type \"int\" to type \"Foo<Bar>\"
Foo<Bar> foo = 0;
               ^
<stdin>:2:5: error: Cannot convert from type \"Baz\" to type \"IFoo\"
Foo<Baz> bar = 0;
    ~~~
");

test("
Foo<Bar><Bar> foo = 0;
Foo<Bar><Baz> bar = 0;
class Foo<T> {}
class Bar {}
class Baz {}
", "
<stdin>:1:1: error: Cannot parameterize type \"Foo<Bar>\" because it is already parameterized
Foo<Bar><Bar> foo = 0;
~~~~~~~~
<stdin>:2:1: error: Cannot parameterize type \"Foo<Bar>\" because it is already parameterized
Foo<Bar><Baz> bar = 0;
~~~~~~~~
");

test("
Foo<int, bool> foo = bar;
Foo<bool, int> bar = foo;
class Foo<A, B> {}
", "
<stdin>:1:22: error: Cannot convert from type \"Foo<bool, int>\" to type \"Foo<int, bool>\"
Foo<int, bool> foo = bar;
                     ~~~
<stdin>:2:22: error: Cannot convert from type \"Foo<int, bool>\" to type \"Foo<bool, int>\"
Foo<bool, int> bar = foo;
                     ~~~
");

test("
class Foo<A, B> { A foo(B foo); }
bool foo(Foo<int, bool> foo) { return foo.foo(0); }
", "
<stdin>:2:47: error: Cannot convert from type \"int\" to type \"bool\" without a cast
bool foo(Foo<int, bool> foo) { return foo.foo(0); }
                                              ^
<stdin>:2:39: error: Cannot convert from type \"int\" to type \"bool\" without a cast
bool foo(Foo<int, bool> foo) { return foo.foo(0); }
                                      ~~~~~~~~~~
");

test("
class Foo<A, B> { A foo(B bar) {} }
class Bar<T> : Foo<int, T> {}
class Baz : Bar<bool> {}
Baz foo = null;
bool bar = foo.foo(0);
", "
<stdin>:5:20: error: Cannot convert from type \"int\" to type \"bool\" without a cast
bool bar = foo.foo(0);
                   ^
<stdin>:5:12: error: Cannot convert from type \"int\" to type \"bool\" without a cast
bool bar = foo.foo(0);
           ~~~~~~~~~~
");

test("
interface IFoo<T> { T foo(); }
class Foo : IFoo<int>, IFoo<float> {}
", "
<stdin>:2:7: error: Member \"Foo.foo\" has an ambiguous inherited type, could be type \"int fn()\" or type \"float fn()\"
class Foo : IFoo<int>, IFoo<float> {}
      ~~~
");

test("
class Foo<T> { T foo(); }
bool foo = Foo.foo();
", "
<stdin>:2:16: error: Cannot access instance member \"foo\" from a static context
bool foo = Foo.foo();
               ~~~
<stdin>:2:12: error: Cannot convert from type \"T\" to type \"bool\"
bool foo = Foo.foo();
           ~~~~~~~~~
");

test("
class Foo<T> {
  T foo = 0;
}
Foo.T foo = 0;
", "
<stdin>:2:11: error: Cannot convert from type \"int\" to type \"T\"
  T foo = 0;
          ^
<stdin>:4:5: error: \"T\" is not declared on type \"Foo<T>\"
Foo.T foo = 0;
    ^
");

test("
class Foo<T> {
  static T foo;
  static T bar() { return default(T); }
}
bool foo = Foo.foo;
bool bar = Foo.bar();
", "
<stdin>:2:10: error: Cannot access \"T\" from a static context
  static T foo;
         ^
<stdin>:3:10: error: Cannot access \"T\" from a static context
  static T bar() { return default(T); }
         ^
<stdin>:3:35: error: Cannot access \"T\" from a static context
  static T bar() { return default(T); }
                                  ^
");

test("
class Foo<T> {}
in Foo { T foo() {} }
", "
<stdin>:2:10: error: \"T\" is not declared
in Foo { T foo() {} }
         ^
");

test("
class Foo<F> {
  class Bar<B is F> : F {
    B bar() { return F(); }
  }
}
", "
<stdin>:2:3: error: Cannot use this statement here
  class Bar<B is F> : F {
  ~~~~~~~~~~~~~~~~~~~~~~~
<stdin>:2:18: error: Cannot access \"F\" from a static context
  class Bar<B is F> : F {
                 ^
<stdin>:2:23: error: Cannot access \"F\" from a static context
  class Bar<B is F> : F {
                      ^
<stdin>:3:22: error: Cannot access \"F\" from a static context
    B bar() { return F(); }
                     ^
");

test("
class Foo<T> { Foo(bool foo) {} }
int foo = Foo(0);
int bar = Foo<int>(0);
", "
<stdin>:2:11: error: Cannot use unparameterized type \"Foo<T>\"
int foo = Foo(0);
          ~~~
<stdin>:3:20: error: Cannot convert from type \"int\" to type \"bool\" without a cast
int bar = Foo<int>(0);
                   ^
<stdin>:3:11: error: Cannot convert from type \"Foo<int>\" to type \"int\"
int bar = Foo<int>(0);
          ~~~~~~~~~~~
");

test("
class Foo<A, B is IFoo<A>> {}
interface IFoo<T> { T foo(); }
Foo<int, IFoo<bool>> foo;
", "
TODO
");

test("
class Foo<A is IFoo<B>, B> {}
interface IFoo<T> { T foo(); }
Foo<IFoo<bool>, int> foo;
", "
TODO
");
