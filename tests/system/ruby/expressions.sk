namespace ruby { void testExpressions() {

// Ruby apparently has a quirk regarding "==" and "!=" that requires extra
// parentheses here. Other targets do not have this issue and other operators
// in Ruby also don't seem to have this issue.
testRuby("
export bool foo(int a, int b, int c, int d) {
  return (a == b) == (c == d);
}
", "
def foo(a, b, c, d)
  return (a == b) == (c == d)
end
")

testRuby("
export var foo = \"'\";
export var bar = \"\\\"\";
export var baz = \"#{test}\";
", "
$foo = \"'\"
$bar = \"\\\"\"
$baz = \"\\#{test}\"
")

testRuby("
export List<float> foo(int x, float y) {
  return [1, 1 + 2, 1 + 2f, 1 + 2.0, x + 2.0, 1 + y];
}
export List<double> bar(int x, double y) {
  return [1, 1 + 2, 1 + 2f, 1 + 2.0, x + 2.0, 1 + y];
}
", "
def foo(x, y)
  return [1.0, Float(1 + 2), 1.0 + 2.0, 1.0 + 2.0, Float(x) + 2.0, 1.0 + y]
end

def bar(x, y)
  return [1.0, Float(1 + 2), 1.0 + 2.0, 1.0 + 2.0, Float(x) + 2.0, 1.0 + y]
end
")

testRuby("
export void foo(int x) {
  x = (1, 2);
  x++, --x;
}
", "
def foo(x)
  x = (1; 2)
  x += 1
  x -= 1
end
")

testRuby("
class Foo<T> {
  inline T foo() { return `this`.untyped; }
}
export int foo(Foo<bool> foo) { return (int)foo.foo(); }
export int bar(int x) { return (int)baz(x); }
inline bool baz(int x) { return x == 0; }
", "
class Foo
  def initialize
  end
end

def foo(foo)
  return foo.untyped ? 1 : 0
end

def bar(x)
  return x == 0 ? 1 : 0
end
")

testRuby("
export dynamic foo() {
  return `{ \"x\": 1, 2: \"y\" }`;
}
", "
def foo
  return { \"x\" => 1, 2 => \"y\" }
end
")

testRuby("
export StringMap<int> foo() {
  return { \"x\": 1, \"y\": 2 };
}
", "
def foo
  return { \"x\" => 1, \"y\" => 2 }
end
")

}}
