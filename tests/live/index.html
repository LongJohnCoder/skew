<style>

body {
  font: 12px/15px 'Lucida Grande', sans-serif;
  margin: 20px;
}

textarea {
  font: 12px Monaco, monospace;
}

div {
  display: inline-block;
  vertical-align: top;
  margin: 20px;
}

select {
  width: 100px;
}

#compileTime, #examples {
  font: 12px/15px 'Lucida Grande', sans-serif;
  float: right;
}

label {
  cursor: default;
  -webkit-user-select: none;
  -moz-user-select: -moz-none;
}

#optionArea {
  display: block;
  height: 30px;
  margin-bottom: -30px;
}

</style>
<div>
  <h2>Input <span id="examples">Examples: <select id="exampleSelect"></select></span></h2>
  <textarea id="input" rows="10" cols="80" spellcheck="false" autofocus></textarea>
  <p>
    <span id="compileTime">Loading...</span>
    Target: <span id="targetArea"></span>
    <span id="optionArea"></span>
  </p>
</div>
<div>
  <h2>Log</h2>
  <textarea id="outputLog" rows="10" cols="80" spellcheck="false" readonly></textarea>
</div>
<div>
  <h2>Tree</h2>
  <textarea id="outputTree" rows="20" cols="80" spellcheck="false" readonly></textarea>
</div>
<div>
  <h2>Code</h2>
  <textarea id="outputCode" rows="20" cols="80" spellcheck="false" readonly></textarea>
</div>
<script>

function webWorker() {
  onmessage = function(e) {
    var message = {};
    try {
      var compiler = new Compiler();
      var options = new CompilerOptions();
      switch (e.data.format) {
        case 'js': {
          options.targetFormat = TargetFormat.JAVASCRIPT;
          options.outputFile = e.data.js.singleFile ? '' : 'output.js';
          options.jsMinify = e.data.js.minify;
          options.jsMangle = e.data.js.mangle;
          options.jsSourceMap = e.data.js.sourceMap;
          options.removeAsserts = e.data.js.optimize;
          options.foldAllConstants = e.data.js.optimize;
          options.inlineAllFunctions = e.data.js.optimize;
          options.convertAllInstanceToStatic = e.data.js.optimize;
          break;
        }
        case 'cpp': {
          options.targetFormat = TargetFormat.CPP;
          break;
        }
      }
      options.inputs.push(new Source('<stdin>', e.data.input));
      var result = compiler.compile(options);
      message.log = compiler.log.toString();
      message.tree = result.files.map(lisp.dump).join('\n');
      message.code = result.outputs.map(function(output) {
        return output.name ? '[' + output.name + ']\n' + output.contents : output.contents;
      }).join('\n');
    } catch (e) {
      var text = e + '';
      if (e && e.stack) {
        var stackText = e.stack + '';
        text = stackText.indexOf(text) === 0 ? stackText : text + '\n' + stackText;
      }
      message.error = text;
    }
    postMessage(message);
  };
}

function ajax(url, callback) {
  var xhr = new XMLHttpRequest;
  xhr.onload = function() { callback(xhr.response); };
  xhr.open('GET', url);
  xhr.send();
}

function gatherSettings() {
  var result = {};
  targets.forEach(function(target) {
    if (target.element.checked) {
      result.format = target.name;
    }
    var json = result[target.name] = {};
    target.options.forEach(function(option) {
      json[option.name] = option.element.checked;
      option.element.parentNode.style.display = target.element.checked ? 'inline' : 'none';
    });
  });
  result.input = input.value || '';
  return result;
}

function ui(compile) {
  targets.forEach(function(target, i) {
    var element = document.createElement('label');
    element.innerHTML = '<input name="target" type="radio"' + (i === 0 ? ' checked' : '') + '> ' + target.text + ' ';
    element.onchange = compile;
    targetArea.appendChild(element);
    target.element = element.firstChild;
    target.options.forEach(function(option) {
      var element = document.createElement('label');
      element.innerHTML = '<input type="checkbox"' + (option.value ? ' checked' : '') + '> ' + option.text + ' ';
      element.onchange = compile;
      optionArea.appendChild(element);
      option.element = element.firstChild;
    });
  });

  examples.forEach(function(example) {
    var element = document.createElement('option');
    element.textContent = example.name;
    exampleSelect.appendChild(element);
  });
  exampleSelect.selectedIndex = -1;
  exampleSelect.onchange = function() {
    if (exampleSelect.selectedIndex !== -1) {
      input.value = examples[exampleSelect.selectedIndex].content.join('\n') + '\n';
      input.onchange();
    }
    exampleSelect.selectedIndex = -1;
  };

  // Try to restore settings from the previous session
  try {
    var settings = JSON.parse(localStorage.settings);
    targets.forEach(function(target) {
      if (settings.format === target.name) {
        target.element.checked = true;
      }
      var json = settings[target.name];
      if (json) {
        target.options.forEach(function(option) {
          if (option.name in json) {
            option.element.checked = json[option.name];
          }
        });
      }
    });
    input.value = settings.input;
  } catch (e) {
  }
}

function update(result, timeInMS) {
  outputLog.value = result.error || result.log || '';
  outputTree.value = result.tree || '';
  outputCode.value = result.code || '';
  compileTime.textContent = +timeInMS.toFixed(1) + 'ms';
}

function start() {
  ajax('../../build/debug/skewc.js', function(content) {
    var code = content + '\n' + webWorker + '\nwebWorker()';
    var worker = new Worker(URL.createObjectURL(new Blob([code], { type: 'text/javascript' })));
    var busyCompiling = false;
    var outOfDate = false;
    var startTime = null;
    var oldSettings = null;
    var now = this.performance && performance.now
      ? function() { return performance.now(); }
      : function() { return +new Date; };

    function compile() {
      var settings = gatherSettings();
      var newSettings = JSON.stringify(settings);
      if (oldSettings !== newSettings) {
        localStorage.settings = newSettings;
        if (busyCompiling) {
          outOfDate = true;
        } else {
          busyCompiling = true;
          startTime = now();
          worker.postMessage(settings);
        }
      }
    }

    worker.onmessage = function(e) {
      busyCompiling = false;
      if (outOfDate) {
        outOfDate = false;
        compile();
      } else {
        update(e.data, now() - startTime);
      }
    };

    input.oninput = input.onchange = compile;
    ui(compile);
    compile();
  });
}

var targets = [
  {
    name: 'js',
    text: 'JavaScript',
    options: [
      { name: 'minify', text: 'Minify', value: false },
      { name: 'mangle', text: 'Mangle', value: false },
      { name: 'optimize', text: 'Optimize', value: false },
      { name: 'sourceMap', text: 'Source Map', value: false },
      { name: 'singleFile', text: 'Single File', value: true },
    ],
  },
  {
    name: 'cpp',
    text: 'C++',
    options: [
      { name: 'singleFile', text: 'Single File', value: true },
    ],
  },
];

var examples = [
  {
    name: 'FizzBuzz',
    content: [
      'import void print(string text);',
      '',
      'string mod(int i, int n, string text) {',
      '  return i % n == 0 ? text : "";',
      '}',
      '',
      '@EntryPoint',
      'void fizzBuzz() {',
      '  for (var i = 1; i <= 100; i++) {',
      '    var text = mod(i, 3, "Fizz") + mod(i, 5, "Buzz");',
      '    print(text == "" ? i.toString() : text);',
      '  }',
      '}',
    ],
  },
  {
    name: 'Mandelbrot',
    content: [
      'import void print(string text);',
      '',
      '@EntryPoint',
      'void mandelbrotFractal() {',
      '  var shades = " .-:;+=xX$& ";',
      '',
      '  for (var row = 0; row < 24; row++) {',
      '    var y = row / 12.0 - 1;',
      '    var line = "";',
      '',
      '    for (var col = 0; col < 80; col++) {',
      '      var x = col / 30.0 - 2;',
      '      var x0 = x;',
      '      var y0 = y;',
      '      var i = 0;',
      '',
      '      while (i < 11 && x0 * x0 + y0 * y0 <= 4) {',
      '        var x1 = (x0 * x0) - (y0 * y0) + x;',
      '        var y1 = 2 * x0 * y0 + y;',
      '        x0 = x1;',
      '        y0 = y1;',
      '        i++;',
      '      }',
      '',
      '      line += shades.sliceCodeUnit(i);',
      '    }',
      '',
      '    print(line);',
      '  }',
      '}',
    ],
  },
  {
    name: 'Raytracer',
    content: [
      'using math;',
      '',
      'void render(int width, int height, List<int> pixels) {',
      '  assert pixels.size() == width * height;',
      '',
      '  var scene = Scene(Camera(Vector(3, 2, 4), Vector(-1, 0.5, 0)));',
      '  scene.elements = [',
      '    Plane(Checkerboard(), Vector(0, 1, 0), 0),',
      '    Sphere(Shiny(), Vector(0, 1, -0.25), 1),',
      '    Sphere(Shiny(), Vector(-1, 0.5, 1.5), 0.5),',
      '  ];',
      '  scene.lights = [',
      '    Light(Vector(-2, 2.5, 0), Vector(0.49, 0.07, 0.07)),',
      '    Light(Vector(1.5, 2.5, 1.5), Vector(0.07, 0.07, 0.49)),',
      '    Light(Vector(1.5, 2.5, -1.5), Vector(0.07, 0.49, 0.071)),',
      '    Light(Vector(0, 3.5, 0), Vector(0.21, 0.21, 0.35)),',
      '  ];',
      '',
      '  for (var y = 0, i = 0; y < height; y++) {',
      '    var screenY = (y * 2.0 + 1 - height) / width;',
      '    for (var x = 0; x < width; x++, i++) {',
      '      var screenX = (x * 2.0 + 1 - width) / width;',
      '      pixels[i] = scene.trace2D(screenX, -screenY).pack();',
      '    }',
      '  }',
      '}',
      '',
      'class Vector {',
      '  final double x, y, z;',
      '',
      '  @OperatorMultiply',
      '  Vector scale(double s) {',
      '    return Vector(x * s, y * s, z * s);',
      '  }',
      '',
      '  @OperatorDivide',
      '  Vector divide(double s) {',
      '    return this * (1 / s);',
      '  }',
      '',
      '  @OperatorAdd',
      '  Vector add(Vector v) {',
      '    return Vector(x + v.x, y + v.y, z + v.z);',
      '  }',
      '',
      '  @OperatorSubtract',
      '  Vector subtract(Vector v) {',
      '    return Vector(x - v.x, y - v.y, z - v.z);',
      '  }',
      '',
      '  @OperatorMultiply',
      '  Vector multiply(Vector v) {',
      '    return Vector(x * v.x, y * v.y, z * v.z);',
      '  }',
      '',
      '  Vector cross(Vector v) {',
      '    return Vector(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);',
      '  }',
      '',
      '  double dot(Vector v) {',
      '    return x * v.x + y * v.y + z * v.z;',
      '  }',
      '',
      '  double length() {',
      '    return sqrt(dot(this));',
      '  }',
      '',
      '  Vector unit() {',
      '    return this / length();',
      '  }',
      '',
      '  Vector reflectAbout(Vector n) {',
      '    return this - n * (2 * dot(n));',
      '  }',
      '',
      '  int pack() {',
      '    return (int)clamp(x) | (int)clamp(y) << 8 | (int)clamp(z) << 16 | 0xFF000000;',
      '  }',
      '',
      '  static double clamp(double x) {',
      '    if (x < 0) return 0;',
      '    if (x > 1) return 255;',
      '    return 255.999 * x;',
      '  }',
      '}',
      '',
      'namespace Colors {',
      '  final var WHITE = Vector(1, 1, 1);',
      '  final var BLACK = Vector(0, 0, 0);',
      '  final var GRAY = Vector(0.5, 0.5, 0.5);',
      '}',
      '',
      'class Light {',
      '  final Vector point, color;',
      '}',
      '',
      'class Intersection {',
      '  final double t;',
      '  final Element element;',
      '}',
      '',
      'class Element {',
      '  final Surface surface;',
      '',
      '  virtual Intersection intersect(Vector origin, Vector ray);',
      '  virtual Vector normalAt(Vector point);',
      '}',
      '',
      'class SurfaceInfo {',
      '  final Vector diffuse, specular;',
      '  final double reflect, roughness;',
      '}',
      '',
      'interface Surface {',
      '  virtual SurfaceInfo infoAt(Vector point);',
      '}',
      '',
      'class Checkerboard : Surface {',
      '  final var WHITE_INFO = SurfaceInfo(Colors.WHITE, Colors.WHITE, 0.1, 150);',
      '  final var BLACK_INFO = SurfaceInfo(Colors.BLACK, Colors.WHITE, 0.7, 150);',
      '',
      '  override SurfaceInfo infoAt(Vector point) {',
      '    if ((((int)floor(point.x) ^ (int)floor(point.z)) & 1) != 0) {',
      '      return WHITE_INFO;',
      '    }',
      '    return BLACK_INFO;',
      '  }',
      '}',
      '',
      'class Shiny : Surface {',
      '  final var INFO = SurfaceInfo(Colors.WHITE, Colors.GRAY, 0.7, 250);',
      '',
      '  override SurfaceInfo infoAt(Vector point) {',
      '    return INFO;',
      '  }',
      '}',
      '',
      'class Plane : Element {',
      '  final Vector normal;',
      '  final double offset;',
      '',
      '  override Intersection intersect(Vector origin, Vector ray) {',
      '    var t = -(normal.dot(origin) + offset) / normal.dot(ray);',
      '    if (t > 0) return Intersection(t, this);',
      '    return null;',
      '  }',
      '',
      '  override Vector normalAt(Vector point) {',
      '    return Vector(0, 1, 0);',
      '  }',
      '}',
      '',
      'class Sphere : Element {',
      '  final Vector center;',
      '  final double radius;',
      '',
      '  override Intersection intersect(Vector origin, Vector ray) {',
      '    var offset = origin - center;',
      '    var a = ray.dot(ray);',
      '    var b = 2 * ray.dot(offset);',
      '    var c = offset.dot(offset) - radius * radius;',
      '    var discriminant = b * b - 4 * a * c;',
      '    if (discriminant > 0) {',
      '      var t = (-b - sqrt(discriminant)) / (2 * a);',
      '      if (t > 0) {',
      '        return Intersection(t, this);',
      '      }',
      '    }',
      '    return null;',
      '  }',
      '',
      '  override Vector normalAt(Vector point) {',
      '    return (point - center) / radius;',
      '  }',
      '}',
      '',
      'class Camera {',
      '  Vector point, forward, right, up;',
      '',
      '  new(Vector point, Vector lookAt) : point = point {',
      '    forward = (lookAt - point).unit();',
      '    right = forward.cross(Vector(0, -1, 0)).unit();',
      '    up = forward.cross(right).unit();',
      '  }',
      '}',
      '',
      'class Scene {',
      '  List<Element> elements = [];',
      '  List<Light> lights = [];',
      '  Camera camera;',
      '',
      '  Intersection intersect(Vector origin, Vector ray, Element ignore) {',
      '    Intersection closest = null;',
      '    for (var i = 0; i < elements.size(); i++) {',
      '      var element = elements[i];',
      '      if (element != ignore) {',
      '        var hit = element.intersect(origin, ray);',
      '        if (hit != null && (closest == null || hit.t < closest.t)) {',
      '          closest = hit;',
      '        }',
      '      }',
      '    }',
      '    return closest;',
      '  }',
      '',
      '  Vector trace3D(Vector origin, Vector ray, Element ignore, int depth) {',
      '    var hit = intersect(origin, ray, ignore);',
      '    if (hit == null) return Colors.BLACK;',
      '',
      '    var point = origin + ray * hit.t;',
      '    var normal = hit.element.normalAt(point);',
      '    var reflected = ray.reflectAbout(normal);',
      '    var info = hit.element.surface.infoAt(point);',
      '    var color = Colors.BLACK;',
      '',
      '    for (var i = 0; i < lights.size(); i++) {',
      '      var light = lights[i];',
      '      var delta = light.point - point;',
      '',
      '      var shadow = intersect(point, delta, hit.element);',
      '      if (shadow != null && shadow.t < 1) {',
      '        continue;',
      '      }',
      '      delta = delta.unit();',
      '',
      '      // Diffuse',
      '      var weight = max(0, delta.dot(normal));',
      '      color = color + light.color * info.diffuse * weight;',
      '',
      '      // Specular',
      '      weight = pow(max(0, delta.dot(reflected)), info.roughness);',
      '      color = color + light.color * info.specular * weight;',
      '    }',
      '',
      '    // Reflection',
      '    if (depth > 0) {',
      '      var recursive = trace3D(point, reflected, hit.element, depth - 1);',
      '      color = color + recursive * info.reflect;',
      '    }',
      '',
      '    return color;',
      '  }',
      '',
      '  Vector trace2D(double x, double y) {',
      '    var ray = camera.forward + camera.right * x + camera.up * y;',
      '    return trace3D(camera.point, ray.unit(), null, 5);',
      '  }',
      '}',
      '',
      '@EntryPoint',
      'void main() {',
      '  var canvas = `document`.createElement("canvas");',
      '  var context = canvas.getContext("2d");',
      '  var width = 640;',
      '  var height = 480;',
      '  var imageData = context.createImageData(width, height);',
      '  canvas.width = width;',
      '  canvas.height = height;',
      '  render(width, height, new `Int32Array`(imageData.data.buffer));',
      '  context.putImageData(imageData, 0, 0);',
      '  `document`.body.appendChild(canvas);',
      '}',
    ],
  },
];

start();

</script>
