<style>

body {
  font: 12px/15px 'Lucida Grande', sans-serif;
  margin: 20px;
}

textarea {
  font: 12px Monaco, monospace;
}

div {
  display: inline-block;
  vertical-align: top;
  margin: 20px;
}

select {
  width: 100px;
}

#compileTime, #examples {
  font: 12px/15px 'Lucida Grande', sans-serif;
  float: right;
}

label {
  cursor: default;
  -webkit-user-select: none;
  -moz-user-select: -moz-none;
}

#optionArea {
  display: block;
  height: 30px;
  margin-bottom: -30px;
}

</style>
<div>
  <h2>Input <span id="examples">Examples: <select id="exampleSelect"></select></span></h2>
  <textarea id="input" rows="10" cols="80" spellcheck="false" autofocus></textarea>
  <p>
    <span id="compileTime">Loading...</span>
    Target: <span id="targetArea"></span>
    <span id="optionArea"></span>
  </p>
</div>
<div>
  <h2>Log</h2>
  <textarea id="outputLog" rows="10" cols="80" spellcheck="false" readonly></textarea>
</div>
<div>
  <h2>Tree</h2>
  <textarea id="outputTree" rows="20" cols="80" spellcheck="false" readonly></textarea>
</div>
<div>
  <h2>Code</h2>
  <textarea id="outputCode" rows="20" cols="80" spellcheck="false" readonly></textarea>
</div>
<script>

function webWorker() {
  onmessage = function(e) {
    var message = {};
    try {
      var compiler = new Compiler();
      var options = new CompilerOptions();
      switch (e.data.format) {
        case 'js': {
          options.targetFormat = TargetFormat.JAVASCRIPT;
          options.outputFile = e.data.js.singleFile ? '' : 'output.js';
          options.jsMinify = e.data.js.minify;
          options.jsMangle = e.data.js.mangle;
          options.jsSourceMap = e.data.js.sourceMap;
          options.removeAsserts = e.data.js.optimize;
          options.foldAllConstants = e.data.js.optimize;
          options.inlineAllFunctions = e.data.js.optimize;
          options.convertAllInstanceToStatic = e.data.js.optimize;
          break;
        }
        case 'cpp': {
          options.targetFormat = TargetFormat.CPP;
          break;
        }
      }
      options.inputs.push(new Source('<stdin>', e.data.input));
      var result = compiler.compile(options);
      message.log = compiler.log.toString();
      message.tree = result.files.map(lisp.dump).join('\n');
      message.code = result.outputs.map(function(output) {
        return output.name ? '[' + output.name + ']\n' + output.contents : output.contents;
      }).join('\n');
    } catch (e) {
      var text = e + '';
      if (e && e.stack) {
        var stackText = e.stack + '';
        text = stackText.indexOf(text) === 0 ? stackText : text + '\n' + stackText;
      }
      message.error = text;
    }
    postMessage(message);
  };
}

function ajax(url, callback) {
  var xhr = new XMLHttpRequest;
  xhr.onload = function() { callback(xhr.response); };
  xhr.open('GET', url);
  xhr.send();
}

function gatherSettings() {
  var result = {};
  targets.forEach(function(target) {
    if (target.element.checked) {
      result.format = target.name;
    }
    var json = result[target.name] = {};
    target.options.forEach(function(option) {
      json[option.name] = option.element.checked;
      option.element.parentNode.style.display = target.element.checked ? 'inline' : 'none';
    });
  });
  result.input = input.value || '';
  return result;
}

function ui(compile) {
  targets.forEach(function(target, i) {
    var element = document.createElement('label');
    element.innerHTML = '<input name="target" type="radio"' + (i === 0 ? ' checked' : '') + '> ' + target.text + ' ';
    element.onchange = compile;
    targetArea.appendChild(element);
    target.element = element.firstChild;
    target.options.forEach(function(option) {
      var element = document.createElement('label');
      element.innerHTML = '<input type="checkbox"' + (option.value ? ' checked' : '') + '> ' + option.text + ' ';
      element.onchange = compile;
      optionArea.appendChild(element);
      option.element = element.firstChild;
    });
  });

  examples.forEach(function(example) {
    var element = document.createElement('option');
    element.textContent = example.name;
    exampleSelect.appendChild(element);
  });
  exampleSelect.selectedIndex = -1;
  exampleSelect.onchange = function() {
    if (exampleSelect.selectedIndex !== -1) {
      input.value = examples[exampleSelect.selectedIndex].content.join('\n') + '\n';
      input.onchange();
    }
    exampleSelect.selectedIndex = -1;
  };

  // Try to restore settings from the previous session
  try {
    var settings = JSON.parse(localStorage.settings);
    targets.forEach(function(target) {
      if (settings.format === target.name) {
        target.element.checked = true;
      }
      var json = settings[target.name];
      if (json) {
        target.options.forEach(function(option) {
          if (option.name in json) {
            option.element.checked = json[option.name];
          }
        });
      }
    });
    input.value = settings.input;
  } catch (e) {
  }
}

function update(result, timeInMS) {
  outputLog.value = result.error || result.log || '';
  outputTree.value = result.tree || '';
  outputCode.value = result.code || '';
  compileTime.textContent = +timeInMS.toFixed(1) + 'ms';
}

function start() {
  ajax('../../build/debug/skewc.js', function(content) {
    var code = content + '\n' + webWorker + '\nwebWorker()';
    var worker = new Worker(URL.createObjectURL(new Blob([code], { type: 'text/javascript' })));
    var busyCompiling = false;
    var outOfDate = false;
    var startTime = null;
    var oldSettings = null;
    var now = this.performance && performance.now
      ? function() { return performance.now(); }
      : function() { return +new Date; };

    function compile() {
      var settings = gatherSettings();
      var newSettings = JSON.stringify(settings);
      if (oldSettings !== newSettings) {
        localStorage.settings = newSettings;
        if (busyCompiling) {
          outOfDate = true;
        } else {
          busyCompiling = true;
          startTime = now();
          worker.postMessage(settings);
        }
      }
    }

    worker.onmessage = function(e) {
      busyCompiling = false;
      if (outOfDate) {
        outOfDate = false;
        compile();
      } else {
        update(e.data, now() - startTime);
      }
    };

    input.oninput = input.onchange = compile;
    ui(compile);
    compile();
  });
}

var targets = [
  {
    name: 'js',
    text: 'JavaScript',
    options: [
      { name: 'minify', text: 'Minify', value: false },
      { name: 'mangle', text: 'Mangle', value: false },
      { name: 'optimize', text: 'Optimize', value: false },
      { name: 'sourceMap', text: 'Source Map', value: false },
      { name: 'singleFile', text: 'Single File', value: true },
    ],
  },
  {
    name: 'cpp',
    text: 'C++',
    options: [
      { name: 'singleFile', text: 'Single File', value: true },
    ],
  },
];

var examples = [
  {
    name: '99 bottles',
    content: [
      'import void print(string text);',
      '',
      'export void countdown() {',
      '  for (var count = 99; count > 0; count--) {',
      '    println(',
      '      bottles(count) + " on the wall, " + bottles(count) + ". Take one " +',
      '      "down and pass it around, " + bottles(count - 1) + " on the wall.");',
      '  }',
      '}',
      '',
      'void println(string text) {',
      '  print(text + "\n");',
      '}',
      '',
      'string bottles(int count) {',
      '  return count + " bottle" + (count == 1 ? "" : "s") + " of beer";',
      '}',
    ],
  },
  {
    name: 'Raytracer',
    content: [
      'export void render(int width, int height, List<int> pixels) {',
      '  assert pixels.size() == width * height;',
      '',
      '  var scene = Scene(Camera(Vector(3, 2, 4), Vector(-1, 0.5, 0)));',
      '  scene.elements = [',
      '    Plane(Checkerboard(), Vector(0, 1, 0), 0),',
      '    Sphere(Shiny(), Vector(0, 1, -0.25), 1),',
      '    Sphere(Shiny(), Vector(-1, 0.5, 1.5), 0.5),',
      '  ];',
      '  scene.lights = [',
      '    Light(Vector(-2, 2.5, 0), Vector(0.49, 0.07, 0.07)),',
      '    Light(Vector(1.5, 2.5, 1.5), Vector(0.07, 0.07, 0.49)),',
      '    Light(Vector(1.5, 2.5, -1.5), Vector(0.07, 0.49, 0.071)),',
      '    Light(Vector(0, 3.5, 0), Vector(0.21, 0.21, 0.35)),',
      '  ];',
      '',
      '  for (var y = 0, i = 0; y < height; y++) {',
      '    var screenY = (y * 2.0 + 1 - height) / width;',
      '    for (var x = 0; x < width; x++, i++) {',
      '      var screenX = (x * 2.0 + 1 - width) / width;',
      '      pixels.set(i, scene.trace2D(screenX, -screenY).pack());',
      '    }',
      '  }',
      '}',
      '',
      'class Vector {',
      '  final double x, y, z;',
      '',
      '  Vector scale(double s) {',
      '    return Vector(x * s, y * s, z * s);',
      '  }',
      '',
      '  Vector add(Vector v) {',
      '    return Vector(x + v.x, y + v.y, z + v.z);',
      '  }',
      '',
      '  Vector subtract(Vector v) {',
      '    return Vector(x - v.x, y - v.y, z - v.z);',
      '  }',
      '',
      '  Vector multiply(Vector v) {',
      '    return Vector(x * v.x, y * v.y, z * v.z);',
      '  }',
      '',
      '  Vector cross(Vector v) {',
      '    return Vector(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);',
      '  }',
      '',
      '  double dot(Vector v) {',
      '    return x * v.x + y * v.y + z * v.z;',
      '  }',
      '',
      '  double length() {',
      '    return math.sqrt(dot(this));',
      '  }',
      '',
      '  Vector unit() {',
      '    return scale(1 / length());',
      '  }',
      '',
      '  Vector reflectAbout(Vector n) {',
      '    return subtract(n.scale(2 * dot(n)));',
      '  }',
      '',
      '  int pack() {',
      '    return (int)clamp(x) | (int)clamp(y) << 8 | (int)clamp(z) << 16 | 0xFF000000;',
      '  }',
      '',
      '  static double clamp(double x) {',
      '    if (x < 0) return 0;',
      '    if (x > 1) return 255;',
      '    return 255.999 * x;',
      '  }',
      '}',
      '',
      'namespace Colors {',
      '  final var WHITE = Vector(1, 1, 1);',
      '  final var BLACK = Vector(0, 0, 0);',
      '  final var GRAY = Vector(0.5, 0.5, 0.5);',
      '}',
      '',
      'class Light {',
      '  final Vector point, color;',
      '}',
      '',
      'class Intersection {',
      '  final double t;',
      '  final Element element;',
      '}',
      '',
      'class Element {',
      '  final Surface surface;',
      '',
      '  virtual Intersection intersect(Vector origin, Vector ray);',
      '  virtual Vector normalAt(Vector point);',
      '}',
      '',
      'class SurfaceInfo {',
      '  final Vector diffuse, specular;',
      '  final double reflect, roughness;',
      '}',
      '',
      'interface Surface {',
      '  virtual SurfaceInfo infoAt(Vector point);',
      '}',
      '',
      'class Checkerboard : Surface {',
      '  final var WHITE_INFO = SurfaceInfo(Colors.WHITE, Colors.WHITE, 0.1, 150);',
      '  final var BLACK_INFO = SurfaceInfo(Colors.BLACK, Colors.WHITE, 0.7, 150);',
      '',
      '  override SurfaceInfo infoAt(Vector point) {',
      '    if ((((int)math.floor(point.x) ^ (int)math.floor(point.z)) & 1) != 0) {',
      '      return WHITE_INFO;',
      '    }',
      '    return BLACK_INFO;',
      '  }',
      '}',
      '',
      'class Shiny : Surface {',
      '  final var INFO = SurfaceInfo(Colors.WHITE, Colors.GRAY, 0.7, 250);',
      '',
      '  override SurfaceInfo infoAt(Vector point) {',
      '    return INFO;',
      '  }',
      '}',
      '',
      'class Plane : Element {',
      '  final Vector normal;',
      '  final double offset;',
      '',
      '  override Intersection intersect(Vector origin, Vector ray) {',
      '    var t = -(normal.dot(origin) + offset) / normal.dot(ray);',
      '    if (t > 0) return Intersection(t, this);',
      '    return null;',
      '  }',
      '',
      '  override Vector normalAt(Vector point) {',
      '    return Vector(0, 1, 0);',
      '  }',
      '}',
      '',
      'class Sphere : Element {',
      '  final Vector center;',
      '  final double radius;',
      '',
      '  override Intersection intersect(Vector origin, Vector ray) {',
      '    var offset = origin.subtract(center);',
      '    var a = ray.dot(ray);',
      '    var b = 2 * ray.dot(offset);',
      '    var c = offset.dot(offset) - radius * radius;',
      '    var discriminant = b * b - 4 * a * c;',
      '    if (discriminant > 0) {',
      '      var t = (-b - math.sqrt(discriminant)) / (2 * a);',
      '      if (t > 0) {',
      '        return Intersection(t, this);',
      '      }',
      '    }',
      '    return null;',
      '  }',
      '',
      '  override Vector normalAt(Vector point) {',
      '    return point.subtract(center).scale(1 / radius);',
      '  }',
      '}',
      '',
      'class Camera {',
      '  Vector point, forward, right, up;',
      '',
      '  new(Vector point, Vector lookAt) : point = point {',
      '    forward = lookAt.subtract(point).unit();',
      '    right = forward.cross(Vector(0, -1, 0)).unit();',
      '    up = forward.cross(right).unit();',
      '  }',
      '}',
      '',
      'class Scene {',
      '  List<Element> elements = [];',
      '  List<Light> lights = [];',
      '  Camera camera;',
      '',
      '  Intersection intersect(Vector origin, Vector ray, Element ignore) {',
      '    Intersection closest = null;',
      '    for (var i = 0; i < elements.size(); i++) {',
      '      var element = elements.get(i);',
      '      if (element != ignore) {',
      '        var hit = element.intersect(origin, ray);',
      '        if (hit != null && (closest == null || hit.t < closest.t)) {',
      '          closest = hit;',
      '        }',
      '      }',
      '    }',
      '    return closest;',
      '  }',
      '',
      '  Vector trace3D(Vector origin, Vector ray, Element ignore, int depth) {',
      '    var hit = intersect(origin, ray, ignore);',
      '    if (hit == null) return Colors.BLACK;',
      '',
      '    var point = ray.scale(hit.t).add(origin);',
      '    var normal = hit.element.normalAt(point);',
      '    var reflected = ray.reflectAbout(normal);',
      '    var info = hit.element.surface.infoAt(point);',
      '    var color = Colors.BLACK;',
      '',
      '    for (var i = 0; i < lights.size(); i++) {',
      '      var light = lights.get(i);',
      '      var delta = light.point.subtract(point);',
      '',
      '      var shadow = intersect(point, delta, hit.element);',
      '      if (shadow != null && shadow.t < 1) {',
      '        continue;',
      '      }',
      '      delta = delta.unit();',
      '',
      '      // Diffuse',
      '      var weight = math.max(0.0, delta.dot(normal));',
      '      color = light.color.multiply(info.diffuse).scale(weight).add(color);',
      '',
      '      // Specular',
      '      weight = math.pow(math.max(0.0, delta.dot(reflected)), info.roughness);',
      '      color = light.color.multiply(info.specular).scale(weight).add(color);',
      '    }',
      '',
      '    // Reflection',
      '    if (depth > 0) {',
      '      var recursive = trace3D(point, reflected, hit.element, depth - 1);',
      '      color = recursive.scale(info.reflect).add(color);',
      '    }',
      '',
      '    return color;',
      '  }',
      '',
      '  Vector trace2D(double x, double y) {',
      '    var ray = camera.forward.add(camera.right.scale(x)).add(camera.up.scale(y));',
      '    return trace3D(camera.point, ray.unit(), null, 5);',
      '  }',
      '}',
    ],
  },
];

start();

</script>
