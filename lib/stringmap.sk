#if TARGET_JS

  import class StringMap<T> {}

  in StringMap {
    pure inline {
      new() { return `Object`.create(null); }
      @OperatorGet T get(string key) { return `this`[key]; }
      @OperatorSet void set(string key, T value) { `this`[key] = value; }
      @OperatorIn bool containsKey(string key) { return key in `this`; }
      void remove(string key) { delete `this`[key]; }
      List<string> keys() { return `Object`.keys(this); }

      T getOrDefault(string key, T defaultValue) {
        return key in this ? this[key] : defaultValue;
      }

      List<T> values() {
        List<T> values = [];
        for (string key in `this`) values.push(this[key]);
        return values;
      }

      StringMap<T> clone() {
        var clone = StringMap<T>();
        for (string key in `this`) clone[key] = this[key];
        return clone;
      }
    }
  }

#elif TARGET_CPP

  @NeedsInclude("<unordered_map>")
  class StringMap<T> {
    pure {
      new() {}
      @OperatorGet T get(string key) { return _table[key]; }
      T getOrDefault(string key, T defaultValue) { `auto` it = _table.find(key); return it != _table.end() ? it->second : defaultValue; }
      @OperatorSet void set(string key, T value) { _table[key] = value; }
      @OperatorIn bool containsKey(string key) { return _table.count(key) > 0; }
      void remove(string key) { _table.erase(key); }
      List<string> keys() { List<string> keys = []; for (`(auto &)` it in _table) keys.push(it.first); return keys; }
      List<T> values() { List<T> values = []; for (`(auto &)` it in _table) values.push(it.second); return values; }
      StringMap<T> clone() { var clone = StringMap<T>(); clone._table = _table; return clone; }
    }

    private `std::unordered_map<`string`, T>` _table;
  }

#elif TARGET_RUBY

  import class StringMap<T> {
    pure {
      @EmitAs("has_key?") @OperatorIn bool containsKey(string key);
      @EmitAs("delete") bool remove(string key);
      List<string> keys();
      List<T> values();
      StringMap<T> clone();
    }
  }

  in StringMap {
    pure inline {
      new() { return `{}`; }
      @OperatorGet T get(string key) { return `this`[key]; }
      @OperatorSet void set(string key, T value) { `this`[key] = value; }
      T getOrDefault(string key, T defaultValue) { return key in this ? this[key] : defaultValue; }
    }
  }

#else

  import class StringMap<T> {
    pure {
      new();
      @OperatorGet T get(string key);
      T getOrDefault(string key, T defaultValue);
      @OperatorSet void set(string key, T value);
      @OperatorIn bool containsKey(string key);
      void remove(string key);
      List<string> keys();
      List<T> values();
      StringMap<T> clone();
    }
  }

#endif

// This is used by the compiler to implement map literals:
//
//   { "a": false, "b": true } => StringMap.literal<bool>(["a", "b"], [false, true])
//
in StringMap {
  private static pure StringMap<X> literal<X>(List<string> keys, List<X> values) {
    #if TARGET_RUBY
    StringMap<X> map = `{}`;
    #else
    var map = StringMap<X>();
    #endif
    assert keys.size() == values.size();
    for (var i = 0; i < keys.size(); i++) {
      map[keys[i]] = values[i];
    }
    return map;
  }
}
