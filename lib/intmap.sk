#if TARGET_JS

  class IntMap<T> {
    private var _table = `Object`.create(null);

    pure {
      inline {
        @OperatorGet T get(int key) { return _table[key]; }
        @OperatorSet void set(int key, T value) { _table[key] = value; }
        @OperatorIn bool containsKey(int key) { return key in _table; }
        void remove(int key) { delete _table[key]; }
      }

      T getOrDefault(int key, T defaultValue) {
        return key in this ? this[key] : defaultValue;
      }

      List<int> keys() {
        List<int> keys = [];
        for (double key in _table) keys.push((int)key);
        return keys;
      }

      List<T> values() {
        List<T> values = [];
        for (int key in _table) values.push(this[key]);
        return values;
      }

      IntMap<T> clone() {
        var clone = IntMap<T>();
        for (int key in _table) clone[key] = this[key];
        return clone;
      }
    }
  }

#elif TARGET_CPP

  @NeedsInclude("<unordered_map>")
  class IntMap<T> {
    pure {
      new() {}
      @OperatorGet T get(int key) { return _table[key]; }
      T getOrDefault(int key, T defaultValue) { `auto` it = _table.find(key); return it != _table.end() ? it->second : defaultValue; }
      @OperatorSet void set(int key, T value) { _table[key] = value; }
      @OperatorIn bool containsKey(int key) { return _table.count(key) > 0; }
      void remove(int key) { _table.erase(key); }
      List<int> keys() { List<int> keys = []; for (`(auto &)` it in _table) keys.push(it.first); return keys; }
      List<T> values() { List<T> values = []; for (`(auto &)` it in _table) values.push(it.second); return values; }
      IntMap<T> clone() { var clone = IntMap<T>(); clone._table = _table; return clone; }
    }

    private `std::unordered_map<`int`, T>` _table;
  }

#elif TARGET_RUBY

  import class IntMap<T> {
    pure {
      new();
      @EmitAs("has_key?") @OperatorIn bool containsKey(int key);
      @EmitAs("delete") bool remove(int key);
      List<int> keys();
      List<T> values();
      IntMap<T> clone();
    }
  }

  in IntMap {
    pure {
      inline @OperatorGet T get(int key) { return `this`[key]; }
      inline @OperatorSet void set(int key, T value) { `this`[key] = value; }
      T getOrDefault(int key, T defaultValue) { return key in this ? this[key] : defaultValue; }
    }
  }

#else

  import class IntMap<T> {
    pure {
      new();
      @OperatorGet T get(int key);
      T getOrDefault(int key, T defaultValue);
      @OperatorSet void set(int key, T value);
      @OperatorIn bool containsKey(int key);
      void remove(int key);
      List<int> keys();
      List<T> values();
      IntMap<T> clone();
    }
  }

#endif

// This is used by the compiler to implement map literals:
//
//   { 1: false, 2: true } => IntMap.literal<bool>([1, 2], [false, true])
//
in IntMap {
  private static pure IntMap<X> literal<X>(List<int> keys, List<X> values) {
    #if TARGET_RUBY
    IntMap<X> map = `{}`;
    #else
    var map = IntMap<X>();
    #endif
    assert keys.size() == values.size();
    for (var i = 0; i < keys.size(); i++) {
      map[keys[i]] = values[i];
    }
    return map;
  }
}
