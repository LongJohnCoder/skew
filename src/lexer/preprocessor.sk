namespace preprocessor {
  enum Result {
    NO,
    YES,
    ERROR,
  }

  enum State {
    PENDING,
    SELECT,
    IGNORE,
    ERROR,
  }

  void parseWarningOrError(ParserContext context, State state) {
    var start = context.index;
    var token = context.next();
    assert token.kind == .PREPROCESSOR_ERROR || token.kind == .PREPROCESSOR_WARNING;
    var stringToken = context.current();

    // These use a string token unlike C/C++
    if (context.expect(.STRING)) {
      context.tokens.removeRange(start, context.index);
      context.index = start;
      var result = parseStringLiteral(context.log, stringToken.range, stringToken.text);

      // Only add to the log for selected blocks
      if (result != null && state == .SELECT) {
        var range = Range.span(token.range, stringToken.range);
        if (token.kind == .PREPROCESSOR_ERROR) context.log.error(range, result.value);
        else context.log.warning(range, result.value);
      }
    }
  }

  void prepareTokens(Log log, List<Token> tokens, StringMap<bool> defines) {
    var context = ParserContext(log, tokens);
    createParser();

    while (true) {
      var kind = context.current().kind;

      // Stop at the end of the token stream
      if (kind == .END_OF_FILE) {
        break;
      }

      // Start an #if chain
      else if (kind == .PREPROCESSOR_IF) {
        parseIfElseChain(context, defines, .SELECT);
      }

      // Check for #error or #warning
      else if (kind == .PREPROCESSOR_WARNING || kind == .PREPROCESSOR_ERROR) {
        parseWarningOrError(context, .SELECT);
      }

      // All other preprocessor tokens are errors at the top level
      else if (kind == .PREPROCESSOR_ELIF || kind == .PREPROCESSOR_ELSE || kind == .PREPROCESSOR_ENDIF || kind == .INVALID_PREPROCESSOR_DIRECTIVE) {
        context.unexpectedToken();
        break;
      }

      // Skip past all other tokens
      else {
        context.next();
      }
    }
  }

  void parseIfElseChain(ParserContext context, StringMap<bool> defines, State parentState) {
    assert context.current().kind == .PREPROCESSOR_IF;
    var start = context.index;
    context.next();
    var result = evaluate(context.log, pratt.parse(context, .LOWEST), defines);
    State state = parentState != .SELECT || result == .ERROR ? .ERROR : result == .YES ? .SELECT : .PENDING;
    var sliceStart = context.index;
    var sliceEnd = 0;
    var foundElse = false;

    while (true) {
      var kind = context.current().kind;

      // End the current block
      if (state == .SELECT && (kind == .PREPROCESSOR_ELIF || kind == .PREPROCESSOR_ELSE || kind == .PREPROCESSOR_ENDIF)) {
        sliceEnd = context.index;
        state = .IGNORE;
      }

      // Start a nested #if chain
      if (kind == .PREPROCESSOR_IF) {
        parseIfElseChain(context, defines, state);
      }

      // Check for #error or #warning
      else if (kind == .PREPROCESSOR_WARNING || kind == .PREPROCESSOR_ERROR) {
        parseWarningOrError(context, state);
      }

      // An #elif branch
      else if (kind == .PREPROCESSOR_ELIF) {
        if (foundElse) {
          context.unexpectedToken();
          break;
        }
        context.next();
        result = evaluate(context.log, pratt.parse(context, .LOWEST), defines);

        // Select this block if the condition is true
        if (result == .ERROR) {
          state = .ERROR;
        } else if (state == .PENDING && result == .YES) {
          state = .SELECT;
          sliceStart = context.index;
        }
      }

      // The final #else branch
      else if (kind == .PREPROCESSOR_ELSE) {
        if (foundElse) {
          context.unexpectedToken();
          break;
        }
        context.next();
        foundElse = true;

        // Select this block if no other condition was true
        if (state == .PENDING) {
          state = .SELECT;
          sliceStart = context.index;
        }
      }

      // An #endif goes back to the caller
      else if (kind == .PREPROCESSOR_ENDIF) {
        context.next();
        break;
      }

      // Make the error about a missing #endif explicit
      else if (kind == .END_OF_FILE) {
        context.expect(.PREPROCESSOR_ENDIF);
        break;
      }

      // Catch preprocessor typos here
      else if (kind == .INVALID_PREPROCESSOR_DIRECTIVE) {
        context.unexpectedToken();
        break;
      }

      // Skip past all other tokens
      else {
        context.next();
      }
    }

    // Remove everything except the selected branch
    if (state == .IGNORE) {
      assert start <= sliceStart && sliceStart <= sliceEnd && sliceEnd <= context.index;
      context.tokens.removeRange(sliceEnd, context.index);
      context.tokens.removeRange(start, sliceStart);
      context.index = start + sliceEnd - sliceStart;
    }

    // No branch was selected, remove everything
    else {
      assert start <= context.index;
      context.tokens.removeRange(start, context.index);
      context.index = start;
    }
  }

  Result evaluate(Log log, Node node, StringMap<bool> defines) {
    switch (node.kind) {
      case .BOOL {
        return (Result)node.asBool();
      }

      case .NAME {
        var name = node.asString();
        if (name in defines) {
          return (Result)defines[name];
        }
        semanticErrorPreprocessorInvalidSymbol(log, node.range, name);
      }

      case .NOT {
        var value = evaluate(log, node.unaryValue(), defines);
        return value == .ERROR ? .ERROR : (Result)(1 - value);
      }

      case .LOGICAL_OR, .LOGICAL_AND {
        var left = evaluate(log, node.binaryLeft(), defines);
        var right = evaluate(log, node.binaryRight(), defines);
        return left != .ERROR && right != .ERROR ? (Result)(node.kind == .LOGICAL_OR ? left | right : left & right) : .ERROR;
      }

      case .ERROR {
      }

      default {
        assert false;
      }
    }

    return .ERROR;
  }

  class ParenthesisParselet : IPrefixParselet {
    override Node parse(ParserContext context) {
      var token = context.next();
      var value = pratt.parse(context, .LOWEST);
      scanForToken(context, .RIGHT_PARENTHESIS, .STOP_BEFORE_NEXT_STATEMENT);
      return value;
    }
  }

  void createParser() {
    if (pratt != null) return;
    pratt = Pratt();

    // Literals
    pratt.literal(.TRUE, BoolLiteral(true));
    pratt.literal(.FALSE, BoolLiteral(false));
    pratt.literal(.IDENTIFIER, NameLiteral());

    // Unary expressions
    pratt.prefix(.NOT, .UNARY_PREFIX, UnaryPrefix(.NOT));

    // Binary expressions
    pratt.infix(.LOGICAL_AND, .LOGICAL_AND, BinaryInfix(.LOGICAL_AND));
    pratt.infix(.LOGICAL_OR, .LOGICAL_OR, BinaryInfix(.LOGICAL_OR));

    // Other expressions
    pratt.parselet(.LEFT_PARENTHESIS, .LOWEST).prefix = ParenthesisParselet();
  }

  Pratt pratt;
}
