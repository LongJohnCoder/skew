class Token {
  Range range;
  TokenKind kind;
  string text;
}

void prepareTokens(List<Token> tokens) {
  List<int> stack = {};

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens.get(i);
    var tokenKind = token.kind;

    // Note: The check for "token.text.length > 0" is very important. Without
    // it, v8 will continue to deoptimize on codeUnitAt(0) until it hits its
    // deoptimization threshold and then this function will be permanently
    // deoptimized. This isn't so bad by itself but Google Closure Compiler
    // inlines this along with all other tokenizing functions into a single
    // function. Permanent deoptimization inside this inlined function causes
    // tokenizing to be twice as slow.
    var tokenStartsWithGreaterThan = token.text.length > 0 && token.text.codeUnitAt(0) == '>';

    // Retokens on the stack if they aren't working out
    while (stack.length > 0) {
      var top = tokens.get(stack.get(stack.length - 1));
      var topKind = top.kind;

      // Stop parsing a type if we find a token that no type expression uses
      if (topKind == .LESS_THAN && tokenKind != .LESS_THAN &&
          tokenKind != .IDENTIFIER && tokenKind != .IS &&
          tokenKind != .COMMA && tokenKind != .DOT &&
          tokenKind != .FN && tokenKind != .LEFT_PARENTHESIS &&
          tokenKind != .RIGHT_PARENTHESIS &&
          !tokenStartsWithGreaterThan) {
        stack.pop();
      } else {
        break;
      }
    }

    // Group open
    if (tokenKind == .LEFT_PARENTHESIS || tokenKind == .LEFT_BRACE || tokenKind == .LEFT_BRACKET || tokenKind == .LESS_THAN) {
      stack.push(i);
      continue;
    }

    // Group close
    if (tokenKind == .RIGHT_PARENTHESIS || tokenKind == .RIGHT_BRACE || tokenKind == .RIGHT_BRACKET || tokenStartsWithGreaterThan) {
      // Search for a matching opposite token
      while (stack.length > 0) {
        var top = tokens.get(stack.get(stack.length - 1));
        var topKind = top.kind;

        // Don't match closing angle brackets that don't work since they are just operators
        if (tokenStartsWithGreaterThan && topKind != .LESS_THAN) {
          break;
        }

        // Consume the current token
        stack.pop();

        // Special-case angle brackets matches
        if (topKind == .LESS_THAN) {

          // Retentative matches that didn't work out
          if (!tokenStartsWithGreaterThan) {
            continue;
          }

          // Break apart operators that start with a closing angle bracket
          if (tokenKind != .GREATER_THAN) {
            var range = token.range;
            var start = range.start;
            var text = token.text.slice(1, token.text.length);
            TokenKind kind =
              tokenKind == .SHIFT_RIGHT ? .GREATER_THAN :
              tokenKind == .GREATER_THAN_OR_EQUAL ? .ASSIGN :
              tokenKind == .ASSIGN_SHIFT_RIGHT ? .GREATER_THAN_OR_EQUAL :
              .ERROR;
            assert kind != .ERROR;
            tokens.insert(i + 1, Token(Range(range.source, start + 1, range.end), kind, text));
            token.range = Range(range.source, start, start + 1);
            token.text = ">";
          }

          // Convert < and > into bounds for type parameter lists
          top.kind = .START_PARAMETER_LIST;
          token.kind = .END_PARAMETER_LIST;
        }

        // Stop the search since we found a match
        break;
      }
    }
  }
}
