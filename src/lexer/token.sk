class Token {
  Range range;
  TokenKind kind;

  int firstCodeUnit() {
    if (kind == .END_OF_FILE) return 0;
    assert range.start < range.source.contents.size();
    return range.source.contents[range.start];
  }

  string text() {
    return range.toString();
  }
}

void prepareTokens(List<Token> tokens) {
  List<Token> stack = [];
  var count = 0;

  for (var i = 0, n = tokens.size(); i < n; i++) {
    var token = tokens[i];

    // Skip null placeholders after tokens that start with a greater than. Each
    // token that may need to split has enough nulls after it for all the pieces.
    // It's a lot faster to remove null gaps during token preparation than to
    // insert pieces in the middle of the token stream (O(n) vs O(n^2)).
    if (token == null) {
      continue;
    }

    // Compress tokens to eliminate unused null gaps
    tokens[count] = token;
    count++;

    // Tokens that start with a greater than may need to be split
    var tokenKind = token.kind;
    var tokenStartsWithGreaterThan = token.firstCodeUnit() == '>';

    // Remove tokens from the stack if they aren't working out
    while (stack.size() != 0) {
      var top = stack.last();
      var topKind = top.kind;

      // Stop parsing a type if we find a token that no type expression uses
      if (topKind == .LESS_THAN && tokenKind != .LESS_THAN && tokenKind != .IDENTIFIER && tokenKind != .IS &&
          tokenKind != .COMMA && tokenKind != .DOT && tokenKind != .TICK && !tokenStartsWithGreaterThan) {
        stack.pop();
      } else {
        break;
      }
    }

    // Group open
    if (tokenKind == .LEFT_PARENTHESIS || tokenKind == .LEFT_BRACE || tokenKind == .LEFT_BRACKET || tokenKind == .LESS_THAN) {
      stack.push(token);
      continue;
    }

    // Group close
    if (tokenKind == .RIGHT_PARENTHESIS || tokenKind == .RIGHT_BRACE || tokenKind == .RIGHT_BRACKET || tokenStartsWithGreaterThan) {
      // Search for a matching opposite token
      while (stack.size() != 0) {
        var top = stack.last();
        var topKind = top.kind;

        // Don't match closing angle brackets that don't work since they are just operators
        if (tokenStartsWithGreaterThan && topKind != .LESS_THAN) {
          break;
        }

        // Consume the current token
        stack.pop();

        // Special-case angle brackets matches
        if (topKind == .LESS_THAN) {

          // Retentative matches that didn't work out
          if (!tokenStartsWithGreaterThan) {
            continue;
          }

          // Break apart operators that start with a closing angle bracket
          if (tokenKind != .GREATER_THAN) {
            var range = token.range;
            var start = range.start;
            assert i + 1 < tokens.size();
            assert tokens[i + 1] == null;
            assert
              tokenKind == .SHIFT_RIGHT ||
              tokenKind == .GREATER_THAN_OR_EQUAL ||
              tokenKind == .ASSIGN_SHIFT_RIGHT;
            tokens[i + 1] = Token(Range(range.source, start + 1, range.end),
              tokenKind == .SHIFT_RIGHT ? .GREATER_THAN :
              tokenKind == .GREATER_THAN_OR_EQUAL ? .ASSIGN :
              .GREATER_THAN_OR_EQUAL);
            token.range = Range(range.source, start, start + 1);
          }

          // Convert < and > into bounds for type parameter lists
          top.kind = .START_PARAMETER_LIST;
          token.kind = .END_PARAMETER_LIST;
        }

        // Stop the search since we found a match
        break;
      }
    }
  }

  // Trim off the remaining tokens due to null gap removal
  while (tokens.size() > count) {
    tokens.pop();
  }
}
