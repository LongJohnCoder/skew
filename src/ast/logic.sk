in Node {
  void invertBooleanCondition(TypeCache cache) {
    assert kind.isExpression();
    switch (kind) {
      case .BOOL {
        content = BoolContent(!asBool());
        return;
      }

      case .NOT {
        become(unaryValue().remove());
        return;
      }

      case .EQUAL {
        kind = .NOT_EQUAL;
        return;
      }

      case .NOT_EQUAL {
        kind = .EQUAL;
        return;
      }

      case .LOGICAL_OR {
        kind = .LOGICAL_AND;
        binaryLeft().invertBooleanCondition(cache);
        binaryRight().invertBooleanCondition(cache);
        return;
      }

      case .LOGICAL_AND {
        kind = .LOGICAL_OR;
        binaryLeft().invertBooleanCondition(cache);
        binaryRight().invertBooleanCondition(cache);
        return;
      }

      // Non-equality comparison operators involving floating-point numbers
      // can't be inverted because one or both of those values may be NAN.
      // Equality comparisons still work fine because inverting the test
      // inverts the result as expected:
      //
      //   Test        |  Result
      // --------------+----------
      //   0 == NAN    |  false
      //   0 != NAN    |  true
      //   0 < NAN     |  false
      //   0 > NAN     |  false
      //   0 <= NAN    |  false
      //   0 >= NAN    |  false
      //   NAN == NAN  |  false
      //   NAN != NAN  |  true
      //   NAN < NAN   |  false
      //   NAN > NAN   |  false
      //   NAN <= NAN  |  false
      //   NAN >= NAN  |  false
      //
      case .LESS_THAN, .GREATER_THAN, .LESS_THAN_OR_EQUAL, .GREATER_THAN_OR_EQUAL {
        var commonType = cache.commonImplicitType(binaryLeft().type, binaryRight().type);
        if (commonType != null && !commonType.isReal(cache)) {
          switch (kind) {
            case .LESS_THAN { kind = .GREATER_THAN_OR_EQUAL; }
            case .GREATER_THAN { kind = .LESS_THAN_OR_EQUAL; }
            case .LESS_THAN_OR_EQUAL { kind = .GREATER_THAN; }
            case .GREATER_THAN_OR_EQUAL { kind = .LESS_THAN; }
          }
          return;
        }
      }
    }

    // Remove children before clone() so they are moved instead of copied
    var children = removeChildren();
    become(Node.createUnary(.NOT, clone().withChildren(children)).withType(cache.boolType));
  }

  bool blockAlwaysEndsWithReturn() {
    assert kind == .BLOCK;
    if (!hasChildren()) {
      return false;
    }

    for (var i = children.size() - 1; i >= 0; i--) {
      var child = children.get(i);
      switch (child.kind) {
        case .RETURN {
          return true;
        }

        case .IF {
          var trueBlock = child.ifTrue();
          var falseBlock = child.ifFalse();
          if (falseBlock != null && trueBlock.blockAlwaysEndsWithReturn() && falseBlock.blockAlwaysEndsWithReturn()) {
            return true;
          }
        }

        case .SWITCH {
          var value = child.switchValue();
          var cases = child.switchCases();
          var foundDefault = false;
          for (var j = 0; j < cases.size(); j++) {
            var node = cases.get(j);
            if (!node.caseBlock().blockAlwaysEndsWithReturn()) {
              return false;
            }
            if (node.caseValues().size() == 0) {
              foundDefault = true;
            }
          }
          return foundDefault;
        }
      }
    }

    return false;
  }

  bool isNameExpression() {
    return kind == .NAME && (parent.kind != .DOT || this != parent.dotName()) && (!parent.kind.isNamedDeclaration() || this != parent.declarationName());
  }

  bool isDeclarationName() {
    return kind == .NAME && parent.kind.isNamedDeclaration() && this == parent.declarationName();
  }

  bool isStorage() {
    return parent.kind.isUnaryStorageOperator() || parent.kind.isBinaryStorageOperator() && this == parent.binaryLeft();
  }

  bool hasNoSideEffects() {
    switch (kind) {
      case .NAME, .THIS, .BOOL, .INT, .FLOAT, .DOUBLE, .STRING, .NULL { return true; }
      case .CAST, .IMPLICIT_CAST { return castValue().hasNoSideEffects(); }
      case .HOOK { return hookTest().hasNoSideEffects() && hookTrue().hasNoSideEffects() && hookFalse().hasNoSideEffects(); }
      case .DOT { return dotTarget().hasNoSideEffects(); }
      case .UNTYPED { return untypedValue().hasNoSideEffects(); }
      default {
        if (kind.isBinaryOperator() && !kind.isBinaryStorageOperator()) return binaryLeft().hasNoSideEffects() && binaryRight().hasNoSideEffects();
        if (kind.isUnaryOperator() && !kind.isUnaryStorageOperator()) return unaryValue().hasNoSideEffects();
        return false;
      }
    }
  }
}
