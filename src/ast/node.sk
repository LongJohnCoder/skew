enum NodeKind {
  // Structure
  PROGRAM,
  FILE,
  BLOCK,
  NODE_LIST,
  CASE,
  MEMBER_INITIALIZER,
  VARIABLE_CLUSTER,

  // Type declarations
  NAMESPACE,
  ENUM,
  ENUM_FLAGS,
  CLASS,
  STRUCT,
  INTERFACE,

  // Other declarations
  EXTENSION,
  CONSTRUCTOR,
  FUNCTION,
  VARIABLE,
  PARAMETER,
  ALIAS,

  // Statements
  IF,
  FOR,
  FOR_EACH,
  WHILE,
  DO_WHILE,
  RETURN,
  IMPLICIT_RETURN,
  BREAK,
  CONTINUE,
  ASSERT,
  EXPRESSION,
  SWITCH,
  MODIFIER,
  USING,

  // Expressions
  NAME,
  TYPE,
  THIS,
  HOOK,
  NULL,
  TRUE,
  FALSE,
  INT,
  FLOAT,
  DOUBLE,
  STRING,
  INITIALIZER,
  DOT,
  LET,
  CALL,
  SUPER_CALL,
  ERROR,
  SEQUENCE,
  PARAMETERIZE,
  CAST,
  IMPLICIT_CAST,
  LAMBDA,
  DEFAULT,
  UNTYPED,
  VAR,
  FUNCTION_TYPE,

  // Unary operators
  NOT,
  POSITIVE,
  NEGATIVE,
  COMPLEMENT,
  PREFIX_INCREMENT,
  PREFIX_DECREMENT,
  POSTFIX_INCREMENT,
  POSTFIX_DECREMENT,

  // Binary operators
  ADD,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  DIVIDE,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  IN,
  INDEX,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MULTIPLY,
  NOT_EQUAL,
  REMAINDER,
  SHIFT_LEFT,
  SHIFT_RIGHT,
  SUBTRACT,

  // Binary assignment operators
  ASSIGN,
  ASSIGN_ADD,
  ASSIGN_BITWISE_AND,
  ASSIGN_BITWISE_OR,
  ASSIGN_BITWISE_XOR,
  ASSIGN_DIVIDE,
  ASSIGN_MULTIPLY,
  ASSIGN_REMAINDER,
  ASSIGN_SHIFT_LEFT,
  ASSIGN_SHIFT_RIGHT,
  ASSIGN_SUBTRACT,

  // Tertiary assignment operators
  ASSIGN_INDEX,
}

in NodeKind {
  bool isStatement() {
    return this >= VARIABLE_CLUSTER && this <= USING;
  }

  bool isNamedBlockDeclaration() {
    return this >= NAMESPACE && this <= EXTENSION;
  }

  bool isNamedDeclaration() {
    return this >= NAMESPACE && this <= ALIAS;
  }

  bool isEnum() {
    return this >= ENUM && this <= ENUM_FLAGS;
  }

  bool isObject() {
    return this >= CLASS && this <= INTERFACE;
  }

  bool isFunction() {
    return this >= CONSTRUCTOR && this <= FUNCTION;
  }

  bool isExpression() {
    return this >= NAME && this <= ASSIGN_INDEX;
  }

  bool isConstant() {
    return this >= NULL && this <= STRING;
  }

  bool isCall() {
    return this >= CALL && this <= SUPER_CALL;
  }

  bool isUnaryOperator() {
    return this >= NOT && this <= POSTFIX_DECREMENT;
  }

  bool isUnaryStorageOperator() {
    return this >= PREFIX_INCREMENT && this <= POSTFIX_DECREMENT;
  }

  bool isBinaryOperator() {
    return this >= ADD && this <= ASSIGN_SUBTRACT;
  }

  bool isBinaryStorageOperator() {
    return this >= ASSIGN && this <= ASSIGN_SUBTRACT;
  }

  bool isTertiaryOperator() {
    return this == ASSIGN_INDEX;
  }

  bool isCast() {
    return this >= CAST && this <= IMPLICIT_CAST;
  }

  bool isType() {
    return this == TYPE;
  }

  bool isReal() {
    return this >= FLOAT && this <= DOUBLE;
  }

  bool isBool() {
    return this >= TRUE && this <= FALSE;
  }

  bool isError() {
    return this == ERROR;
  }

  bool isLoop() {
    return this >= FOR && this <= DO_WHILE;
  }

  bool isStorage() {
    return this == NAME || this == DOT;
  }

  string prettyPrint() {
    return replace(toString().toLowerCase(), "_", "-");
  }
}

class Node {
  var range = Range.EMPTY;
  NodeKind kind;
  Node parent = null;
  Node sibling = null; // Adjacent declarations with the same name
  List<Node> children = null;
  Type type = null;
  Scope scope = null; // The scope that this node introduces, if any
  Symbol symbol = null;
  Content content = null;

  bool asBool() {
    assert kind.isBool();
    return kind == .TRUE;
  }

  int asInt() {
    assert kind == .INT;
    assert content != null;
    assert content.type() == .INT;
    return ((IntContent)content).value;
  }

  double asDouble() {
    assert kind.isReal();
    assert content != null;
    assert content.type() == .DOUBLE;
    return ((DoubleContent)content).value;
  }

  string asString() {
    assert kind == .NAME || kind == .STRING;
    assert content != null;
    assert content.type() == .STRING;
    return ((StringContent)content).value;
  }

  bool hasChildren() {
    return children != null && children.length > 0;
  }

  int indexInParent() {
    assert parent != null;
    return parent.children.indexOf(this);
  }

  void prependChild(Node node) {
    insertChild(0, node);
  }

  void prependChildren(List<Node> nodes) {
    insertChildren(0, nodes);
  }

  void appendChild(Node node) {
    insertChild(children == null ? 0 : children.length, node);
  }

  void appendChildren(List<Node> nodes) {
    insertChildren(children == null ? 0 : children.length, nodes);
  }

  void insertSiblingBefore(Node node) {
    parent.insertChild(indexInParent(), node);
  }

  void insertSiblingAfter(Node node) {
    parent.insertChild(indexInParent() + 1, node);
  }

  Node removeChildAtIndex(int index) {
    assert index >= 0 && index < children.length;
    var child = children.get(index);
    if (child != null) {
      child.parent = null;
    }
    children.remove(index);
    return child;
  }

  Node remove() {
    if (parent != null) {
      parent.removeChildAtIndex(indexInParent());
    }
    return this;
  }

  List<Node> removeChildren() {
    if (children == null) return {};
    var result = children;
    for (var i = 0; i < children.length; i++) {
      var child = children.get(i);
      if (child != null) {
        child.parent = null;
      }
    }
    children = null;
    return result;
  }

  // Change this node in place to become the provided node. The parent node is
  // not changed, so become() can be called within a nested method and does not
  // need to report the updated node reference to the caller since the reference
  // does not change.
  void become(Node node) {
    kind = node.kind;
    range = node.range;
    sibling = node.sibling;
    removeChildren();
    withChildren(node.removeChildren());
    type = node.type;
    scope = node.scope;
    symbol = node.symbol;
    content = node.content;
  }

  Node replaceWith(Node node) {
    parent.replaceChild(indexInParent(), node);
    return this;
  }

  Node replaceWithNodes(List<Node> nodes) {
    var index = indexInParent();
    for (var i = 0; i < nodes.length; i++) {
      parent.insertChild(index + i + 1, nodes.get(i));
    }
    parent.removeChildAtIndex(index);
    return this;
  }

  void replaceChild(int index, Node node) {
    assert children != null;
    assert index >= 0 && index <= children.length;
    updateParent(node, this);
    var old = children.get(index);
    if (old != null) old.parent = null;
    children.set(index, node);
  }

  void insertChild(int index, Node node) {
    if (children == null) children = {};
    assert index >= 0 && index <= children.length;
    updateParent(node, this);
    children.insert(index, node);
  }

  void insertChildren(int index, List<Node> nodes) {
    if (children == null) children = {};
    assert index >= 0 && index <= children.length;
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes.get(i);
      updateParent(node, this);
      children.insert(index++, node);
    }
  }

  Node clone() {
    var node = Node(kind);
    node.range = range;
    node.type = type;
    node.symbol = symbol;
    node.content = content;
    if (children != null) {
      node.children = {};
      for (var i = 0; i < children.length; i++) {
        var child = children.get(i);
        node.appendChild(child != null ? child.clone() : null);
      }
    }
    return node;
  }

  Node withRange(Range value) {
    range = value;
    return this;
  }

  Node withType(Type value) {
    type = value;
    return this;
  }

  Node withSymbol(Symbol value) {
    symbol = value;
    return this;
  }

  Node withContent(Content value) {
    content = value;
    return this;
  }

  Node withChildren(List<Node> nodes) {
    assert children == null;
    for (var i = 0; i < nodes.length; i++) {
      updateParent(nodes.get(i), this);
    }
    children = nodes;
    return this;
  }

  Node firstNonExtensionSibling() {
    var node = this;
    while (node != null && node.kind == .EXTENSION) {
      node = node.sibling;
    }
    return node;
  }

  void appendToSiblingChain(Node node) {
    var last = this;
    while (last.sibling != null) {
      last = last.sibling;
    }
    last.sibling = node;
  }

  static void updateParent(Node node, Node parent) {
    if (node != null) {
      assert node.parent == null;
      node.parent = parent;
    }
  }
}

enum ContentType {
  INT,
  DOUBLE,
  STRING,
}

class Content {
  virtual ContentType type();

  static bool equal(Content left, Content right) {
    if (left == right) return true;
    if (left != null && right != null) {
      var type = left.type();
      if (type == right.type()) {
        switch (type) {
          case .INT { return ((IntContent)left).value == ((IntContent)right).value; }
          case .DOUBLE { return ((DoubleContent)left).value == ((DoubleContent)right).value; }
          case .STRING { return ((StringContent)left).value == ((StringContent)right).value; }
        }
      }
    }
    return false;
  }
}

class IntContent : Content {
  final int value;

  override ContentType type() {
    return .INT;
  }
}

class DoubleContent : Content {
  final double value;

  override ContentType type() {
    return .DOUBLE;
  }
}

class StringContent : Content {
  final string value;

  override ContentType type() {
    return .STRING;
  }
}
