enum NodeKind {
  // Structure
  PROGRAM,
  FILE,
  BLOCK,
  NODE_LIST,
  CASE,
  MEMBER_INITIALIZER,
  VARIABLE_CLUSTER,

  // Type declarations
  NAMESPACE,
  ENUM,
  ENUM_FLAGS,
  CLASS,
  INTERFACE,

  // Other declarations
  EXTENSION,
  CONSTRUCTOR,
  FUNCTION,
  VARIABLE,
  PARAMETER,
  ALIAS,

  // Statements
  IF,
  FOR,
  FOR_EACH,
  WHILE,
  DO_WHILE,
  RETURN,
  BREAK,
  CONTINUE,
  ASSERT,
  ASSERT_CONST,
  EXPRESSION,
  SWITCH,
  MODIFIER,
  USING,

  // Expressions
  NAME,
  TYPE,
  THIS,
  HOOK,
  NULL,
  BOOL,
  INT,
  FLOAT,
  DOUBLE,
  STRING,
  LIST,
  DOT,
  DOT_ARROW, // Used for C++ interop
  DOT_COLON, // Used for C++ interop
  CALL,
  SUPER_CALL,
  ERROR,
  SEQUENCE,
  PARAMETERIZE,
  CAST,
  IMPLICIT_CAST,
  UNTYPED,
  TYPED,
  VAR,

  // Unary operators
  NOT,
  POSITIVE,
  NEGATIVE,
  COMPLEMENT,
  PREFIX_INCREMENT,
  PREFIX_DECREMENT,
  POSTFIX_INCREMENT,
  POSTFIX_DECREMENT,
  DEREFERENCE, // Used for C++ interop
  ADDRESS_OF, // Used for C++ interop

  // Binary operators
  ADD,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  DIVIDE,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  IN,
  INDEX,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MULTIPLY,
  NOT_EQUAL,
  REMAINDER,
  SHIFT_LEFT,
  SHIFT_RIGHT,
  SUBTRACT,

  // Binary assignment operators
  ASSIGN,
  ASSIGN_ADD,
  ASSIGN_BITWISE_AND,
  ASSIGN_BITWISE_OR,
  ASSIGN_BITWISE_XOR,
  ASSIGN_DIVIDE,
  ASSIGN_MULTIPLY,
  ASSIGN_REMAINDER,
  ASSIGN_SHIFT_LEFT,
  ASSIGN_SHIFT_RIGHT,
  ASSIGN_SUBTRACT,

  // Ternary assignment operators
  ASSIGN_INDEX,
}

in NodeKind {
  bool isStatement() {
    return this >= VARIABLE_CLUSTER && this <= USING;
  }

  bool isNamedBlockDeclaration() {
    return this >= NAMESPACE && this <= EXTENSION;
  }

  bool isNamedDeclaration() {
    return this >= NAMESPACE && this <= ALIAS;
  }

  bool isEnum() {
    return this >= ENUM && this <= ENUM_FLAGS;
  }

  bool isObject() {
    return this >= CLASS && this <= INTERFACE;
  }

  bool isFunction() {
    return this >= CONSTRUCTOR && this <= FUNCTION;
  }

  bool isAssert() {
    return this >= ASSERT && this <= ASSERT_CONST;
  }

  bool isExpression() {
    return this >= NAME && this <= ASSIGN_INDEX;
  }

  bool isConstant() {
    return this >= NULL && this <= STRING;
  }

  bool isCall() {
    return this >= CALL && this <= SUPER_CALL;
  }

  bool isUnaryOperator() {
    return this >= NOT && this <= ADDRESS_OF;
  }

  bool isUnaryStorageOperator() {
    return this >= PREFIX_INCREMENT && this <= POSTFIX_DECREMENT;
  }

  bool isBinaryOperator() {
    return this >= ADD && this <= ASSIGN_SUBTRACT;
  }

  bool isBinaryStorageOperator() {
    return this >= ASSIGN && this <= ASSIGN_SUBTRACT;
  }

  bool isTernaryOperator() {
    return this == ASSIGN_INDEX;
  }

  bool isCast() {
    return this >= CAST && this <= IMPLICIT_CAST;
  }

  bool isTypeHole() {
    return this >= UNTYPED && this <= TYPED;
  }

  bool isType() {
    return this == TYPE;
  }

  bool isReal() {
    return this >= FLOAT && this <= DOUBLE;
  }

  bool isError() {
    return this == ERROR;
  }

  bool isJump() {
    return this >= RETURN && this <= CONTINUE;
  }

  bool isDot() {
    return this >= DOT && this <= DOT_COLON;
  }

  bool isLoop() {
    return this >= FOR && this <= DO_WHILE;
  }

  bool isStorage() {
    return this == NAME || this == DOT;
  }

  string prettyPrint() {
    return toString().toLowerCase().replace("_", "-");
  }
}

class Node {
  var range = Range.EMPTY;
  NodeKind kind;
  Node parent = null;
  Node sibling = null; // Adjacent declarations with the same name
  List<Node> children = null;
  Type type = null;
  Scope scope = null; // The scope that this node introduces, if any
  Symbol symbol = null;
  Content content = null;

  bool hasChildren() {
    return children != null && children.size() > 0;
  }

  bool isLastChild() {
    return parent.lastChild() == this;
  }

  Node lastChild() {
    return children.get(children.size() - 1);
  }

  int indexInParent() {
    assert parent != null;
    return parent.children.indexOf(this);
  }

  void prependChild(Node node) {
    insertChild(0, node);
  }

  void prependChildren(List<Node> nodes) {
    insertChildren(0, nodes);
  }

  void appendChild(Node node) {
    insertChild(children == null ? 0 : children.size(), node);
  }

  void appendChildren(List<Node> nodes) {
    insertChildren(children == null ? 0 : children.size(), nodes);
  }

  void insertSiblingBefore(Node node) {
    parent.insertChild(indexInParent(), node);
  }

  void insertSiblingAfter(Node node) {
    parent.insertChild(indexInParent() + 1, node);
  }

  Node removeChildAtIndex(int index) {
    assert index >= 0 && index < children.size();
    var child = children.get(index);
    if (child != null) {
      child.parent = null;
    }
    children.remove(index);
    return child;
  }

  Node remove() {
    if (parent != null) {
      parent.removeChildAtIndex(indexInParent());
    }
    return this;
  }

  List<Node> removeChildren() {
    if (children == null) return [];
    var result = children;
    for (var i = 0; i < children.size(); i++) {
      var child = children.get(i);
      if (child != null) {
        child.parent = null;
      }
    }
    children = null;
    return result;
  }

  // Change this node in place to become the provided node. The parent node is
  // not changed, so become() can be called within a nested method and does not
  // need to report the updated node reference to the caller since the reference
  // does not change.
  void become(Node node) {
    kind = node.kind;
    range = node.range;
    sibling = node.sibling;
    removeChildren();
    withChildren(node.removeChildren());
    type = node.type;
    scope = node.scope;
    symbol = node.symbol;
    content = node.content;
  }

  Node replaceWith(Node node) {
    parent.replaceChild(indexInParent(), node);
    return this;
  }

  void swapWith(Node node) {
    Node parentA = parent;
    Node parentB = node.parent;
    int indexA = indexInParent();
    int indexB = node.indexInParent();
    parentA.children.set(indexA, node);
    parentB.children.set(indexB, this);
    parent = parentB;
    node.parent = parentA;
  }

  Node replaceWithNodes(List<Node> nodes) {
    var index = indexInParent();
    for (var i = 0; i < nodes.size(); i++) {
      parent.insertChild(index + i + 1, nodes.get(i));
    }
    parent.removeChildAtIndex(index);
    return this;
  }

  void replaceChild(int index, Node node) {
    assert children != null;
    assert index >= 0 && index <= children.size();
    updateParent(node, this);
    var old = children.get(index);
    if (old != null) old.parent = null;
    children.set(index, node);
  }

  void insertChild(int index, Node node) {
    if (children == null) children = [];
    assert index >= 0 && index <= children.size();
    updateParent(node, this);
    children.insert(index, node);
  }

  void insertChildren(int index, List<Node> nodes) {
    if (children == null) children = [];
    assert index >= 0 && index <= children.size();
    for (var i = 0; i < nodes.size(); i++) {
      var node = nodes.get(i);
      updateParent(node, this);
      children.insert(index, node);
      index++;
    }
  }

  Node clone() {
    var node = Node(kind);
    node.range = range;
    node.type = type;
    node.symbol = symbol;
    node.content = content;
    if (children != null) {
      node.children = [];
      for (var i = 0; i < children.size(); i++) {
        var child = children.get(i);
        node.appendChild(child != null ? child.clone() : null);
      }
    }
    return node;
  }

  Node withRange(Range value) {
    range = value;
    return this;
  }

  Node withType(Type value) {
    type = value;
    return this;
  }

  Node withSymbol(Symbol value) {
    symbol = value;
    return this;
  }

  Node withContent(Content value) {
    content = value;
    return this;
  }

  Node withChildren(List<Node> nodes) {
    assert children == null;
    for (var i = 0; i < nodes.size(); i++) {
      updateParent(nodes.get(i), this);
    }
    children = nodes;
    return this;
  }

  Node firstNonExtensionSibling() {
    var node = this;
    while (node != null && node.kind == .EXTENSION) {
      node = node.sibling;
    }
    return node;
  }

  void appendToSiblingChain(Node node) {
    var last = this;
    while (last.sibling != null) {
      last = last.sibling;
    }
    last.sibling = node;
  }

  static void updateParent(Node node, Node parent) {
    if (node != null) {
      assert node.parent == null;
      node.parent = parent;
    }
  }
}
