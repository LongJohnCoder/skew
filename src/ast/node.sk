enum NodeKind {
  // Structure
  PROGRAM,
  FILE,
  BLOCK,
  NODE_LIST,
  CASE,
  VARIABLE_CLUSTER,

  // Type declarations
  NAMESPACE,
  ENUM,
  ENUM_FLAGS,
  CLASS,
  STRUCT,
  INTERFACE,

  // Other declarations
  EXTENSION,
  CONSTRUCTOR,
  FUNCTION,
  VARIABLE,
  PARAMETER,
  USING_ALIAS,

  // Statements
  IF,
  FOR,
  FOREACH,
  WHILE,
  DO_WHILE,
  RETURN,
  BREAK,
  CONTINUE,
  ASSERT,
  EXPRESSION,
  SWITCH,
  MODIFIER,
  USING_NAMESPACE,

  // Expressions
  NAME,
  TYPE,
  NULL,
  THIS,
  TRUE,
  FALSE,
  HOOK,
  INT,
  FLOAT,
  DOUBLE,
  STRING,
  INITIALIZER,
  DOT,
  DOT_CALL,
  CALL,
  SUPER_CALL,
  NEW,
  ERROR,
  SEQUENCE,
  PARAMETERIZE,
  CAST,
  IMPLICIT_CAST,
  LAMBDA,
  DEFAULT,

  // Unary operators
  NOT,
  POSITIVE,
  NEGATIVE,
  COMPLEMENT,
  PREFIX_INCREMENT,
  PREFIX_DECREMENT,
  POSTFIX_INCREMENT,
  POSTFIX_DECREMENT,

  // Binary operators
  ADD,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  DIVIDE,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_OR_EQUAL,
  IN,
  INDEX,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MULTIPLY,
  NOT_EQUAL,
  REMAINDER,
  SHIFT_LEFT,
  SHIFT_RIGHT,
  SUBTRACT,

  // Binary assignment operators
  ASSIGN,
  ASSIGN_ADD,
  ASSIGN_BITWISE_AND,
  ASSIGN_BITWISE_OR,
  ASSIGN_BITWISE_XOR,
  ASSIGN_DIVIDE,
  ASSIGN_MULTIPLY,
  ASSIGN_REMAINDER,
  ASSIGN_SHIFT_LEFT,
  ASSIGN_SHIFT_RIGHT,
  ASSIGN_SUBTRACT,

  // Tertiary assignment operators
  ASSIGN_INDEX,
}

in NodeKind {
  bool isStatement() {
    return this >= NAMESPACE && this <= USING_NAMESPACE;
  }

  bool isNamedBlockDeclaration() {
    return this >= NAMESPACE && this <= EXTENSION;
  }

  bool isObjectDeclaration() {
    return this >= CLASS && this <= INTERFACE;
  }

  bool isNamedDeclaration() {
    return this >= NAMESPACE && this <= USING_ALIAS;
  }

  bool isFunctionDeclaration() {
    return this >= CONSTRUCTOR && this <= FUNCTION;
  }

  bool isExpression() {
    return this >= NAME && this <= ASSIGN_INDEX;
  }

  bool isUnaryOperator() {
    return this >= NOT && this <= POSTFIX_DECREMENT;
  }

  bool isBinaryOperator() {
    return this >= ADD && this <= ASSIGN_SHIFT_RIGHT;
  }

  bool isTertiaryOperator() {
    return this == ASSIGN_INDEX;
  }
}

class Node {
  NodeKind kind;
  Range range = Range.EMPTY;
  Node parent = null;
  Node sibling = null; // Adjacent declarations with the same name
  List<Node> children = null;
  Type type = null;
  Scope scope = null; // The scope that this node introduces, if any
  Symbol symbol = null;
  Content content = null;

  int asInt() {
    assert content != null;
    assert content.type() == ContentType.INT;
    return ((IntContent)content).value;
  }

  double asDouble() {
    assert content != null;
    assert content.type() == ContentType.DOUBLE;
    return ((DoubleContent)content).value;
  }

  string asString() {
    assert content != null;
    assert content.type() == ContentType.STRING;
    return ((StringContent)content).value;
  }

  bool hasChildren() {
    return children != null && children.length > 0;
  }

  int indexInParent() {
    assert parent != null;
    return parent.children.indexOf(this);
  }

  void prependChild(Node node) {
    insertChild(0, node);
  }

  void prependChildren(List<Node> nodes) {
    insertChildren(0, nodes);
  }

  void appendChild(Node node) {
    insertChild(children == null ? 0 : children.length, node);
  }

  void appendChildren(List<Node> nodes) {
    insertChildren(children == null ? 0 : children.length, nodes);
  }

  void insertSiblingBefore(Node node) {
    parent.insertChild(indexInParent(), node);
  }

  void insertSiblingAfter(Node node) {
    parent.insertChild(indexInParent() + 1, node);
  }

  Node remove() {
    if (parent != null) {
      int index = indexInParent();
      assert index >= 0 && index < parent.children.length;
      parent.children.remove(index);
      parent = null;
    }
    return this;
  }

  List<Node> removeChildren() {
    if (children == null) return {};
    List<Node> result = children;
    int i;
    for (i = 0; i < children.length; i++) {
      children.get(i).parent = null;
    }
    children = null;
    return result;
  }

  void replaceWith(Node node) {
    updateParent(node, parent);
    parent.children.set(indexInParent(), node);
    parent = null;
  }

  void insertChild(int index, Node node) {
    if (children == null) children = {};
    assert index >= 0 && index <= children.length;
    updateParent(node, this);
    children.insert(index, node);
  }

  void insertChildren(int index, List<Node> nodes) {
    if (children == null) children = {};
    assert index >= 0 && index <= children.length;
    int i;
    for (i = 0; i < nodes.length; i++) {
      Node node = nodes.get(i);
      updateParent(node, this);
      children.insert(index++, node);
    }
  }

  Node clone() {
    Node node = new Node(kind);
    node.range = range;
    node.children = {};
    node.type = type;
    node.symbol = symbol;
    node.content = content.clone();
    int i;
    for (i = 0; i < children.length; i++) {
      node.appendChild(children.get(i).clone());
    }
    return node;
  }

  Node withRange(Range value) {
    range = value;
    return this;
  }

  Node withType(Type value) {
    type = value;
    return this;
  }

  Node withContent(Content value) {
    content = value;
    return this;
  }

  Node withChildren(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      updateParent(nodes.get(i), this);
    }
    children = nodes;
    return this;
  }

  static void updateParent(Node node, Node parent) {
    if (node != null) {
      assert node.parent == null;
      node.parent = parent;
    }
  }
}

enum ContentType {
  INT,
  DOUBLE,
  STRING,
}

class Content {
  virtual ContentType type();
  virtual Content clone();
}

class IntContent : Content {
  int value;

  override ContentType type() {
    return ContentType.INT;
  }

  override Content clone() {
    return new IntContent(value);
  }
}

class DoubleContent : Content {
  double value;

  override ContentType type() {
    return ContentType.DOUBLE;
  }

  override Content clone() {
    return new DoubleContent(value);
  }
}

class StringContent : Content {
  string value;

  override ContentType type() {
    return ContentType.STRING;
  }

  override Content clone() {
    return new StringContent(value);
  }
}
