enum NodeKind {
  // Structure
  PROGRAM
  FILE
  BLOCK
  NODE_LIST
  CASE
  CATCH
  MEMBER_INITIALIZER
  VARIABLE_CLUSTER

  // Type declarations
  NAMESPACE
  ENUM
  ENUM_FLAGS
  CLASS
  INTERFACE

  // Other declarations
  EXTENSION
  CONSTRUCTOR
  FUNCTION
  VARIABLE
  PARAMETER
  PREPROCESSOR_DEFINE
  ALIAS

  // Statements
  IF
  TRY
  FOR
  FOR_EACH
  WHILE
  DO_WHILE
  RETURN
  BREAK
  CONTINUE
  THROW
  ASSERT
  ASSERT_CONST
  EXPRESSION
  SWITCH
  MODIFIER
  USING
  PREPROCESSOR_WARNING
  PREPROCESSOR_ERROR
  PREPROCESSOR_IF

  // Expressions
  NAME
  TYPE
  THIS
  HOOK
  NULL
  BOOL
  INT
  FLOAT
  DOUBLE
  STRING
  LIST
  MAP
  KEY_VALUE
  DOT
  DOT_ARROW // Used for C++ binding
  DOT_COLON // Used for C++ binding
  CALL
  SUPER_CALL
  ERROR
  SEQUENCE
  PARAMETERIZE
  CAST
  IMPLICIT_CAST
  QUOTED
  VAR
  ANNOTATION
  PREPROCESSOR_HOOK
  PREPROCESSOR_SEQUENCE

  // Unary operators
  NOT
  POSITIVE
  NEGATIVE
  COMPLEMENT
  PREFIX_INCREMENT
  PREFIX_DECREMENT
  POSTFIX_INCREMENT
  POSTFIX_DECREMENT
  NEW                 // Used for binding
  DELETE              // Used for binding
  PREFIX_DEREFERENCE  // Used for C++ binding
  PREFIX_REFERENCE    // Used for C++ binding
  POSTFIX_DEREFERENCE // Used for C++ binding
  POSTFIX_REFERENCE   // Used for C++ binding

  // Binary operators
  ADD
  BITWISE_AND
  BITWISE_OR
  BITWISE_XOR
  COMPARE // Used for operator overloading
  DIVIDE
  EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  IN
  INDEX
  IS // Used for JavaScript binding
  LESS_THAN
  LESS_THAN_OR_EQUAL
  LOGICAL_AND
  LOGICAL_OR
  MULTIPLY
  NOT_EQUAL
  POWER
  REMAINDER
  SHIFT_LEFT
  SHIFT_RIGHT
  SUBTRACT

  // Binary assignment operators
  ASSIGN
  ASSIGN_ADD
  ASSIGN_DIVIDE
  ASSIGN_MULTIPLY
  ASSIGN_REMAINDER
  ASSIGN_SUBTRACT

  // Binary bitwise assignment operators
  ASSIGN_BITWISE_AND
  ASSIGN_BITWISE_OR
  ASSIGN_BITWISE_XOR
  ASSIGN_SHIFT_LEFT
  ASSIGN_SHIFT_RIGHT

  // Ternary assignment operators
  ASSIGN_INDEX
}

in NodeKind {
  bool isStatement() {
    return this >= VARIABLE_CLUSTER && this <= PREPROCESSOR_IF
  }

  bool isNamedBlockDeclaration() {
    return this >= NAMESPACE && this <= EXTENSION
  }

  bool isNamedDeclaration() {
    return this >= NAMESPACE && this <= ALIAS
  }

  bool isEnum() {
    return this >= ENUM && this <= ENUM_FLAGS
  }

  bool isObject() {
    return this >= CLASS && this <= INTERFACE
  }

  bool isFunction() {
    return this >= CONSTRUCTOR && this <= FUNCTION
  }

  bool isAssert() {
    return this >= ASSERT && this <= ASSERT_CONST
  }

  bool isExpression() {
    return this >= NAME && this <= ASSIGN_INDEX
  }

  bool isConstant() {
    return this >= NULL && this <= STRING
  }

  bool isCall() {
    return this >= CALL && this <= SUPER_CALL
  }

  bool isUnaryOperator() {
    return this >= NOT && this <= POSTFIX_REFERENCE
  }

  bool isUnaryTypeOperator() {
    return this >= POSTFIX_DEREFERENCE && this <= POSTFIX_REFERENCE
  }

  bool isUnaryStorageOperator() {
    return this >= PREFIX_INCREMENT && this <= POSTFIX_DECREMENT
  }

  bool isBinaryOperator() {
    return this >= ADD && this <= ASSIGN_SHIFT_RIGHT
  }

  bool isBinaryStorageOperator() {
    return this >= ASSIGN && this <= ASSIGN_SHIFT_RIGHT
  }

  bool isBinaryBitwiseStorageOperator() {
    return this >= ASSIGN_BITWISE_AND && this <= ASSIGN_SHIFT_RIGHT
  }

  bool isTernaryOperator() {
    return this == ASSIGN_INDEX
  }

  bool isCast() {
    return this >= CAST && this <= IMPLICIT_CAST
  }

  bool isReal() {
    return this >= FLOAT && this <= DOUBLE
  }

  bool isJump() {
    return this >= RETURN && this <= THROW
  }

  bool isDot() {
    return this >= DOT && this <= DOT_COLON
  }

  bool isLoop() {
    return this >= FOR && this <= DO_WHILE
  }

  bool isStorage() {
    return this == NAME || this == DOT
  }

  string prettyPrint() {
    return toString().toLowerCase().replaceAll("_", "-")
  }
}

enum flags NodeFlags {
  NEEDS_PREPROCESSOR
  IS_LIBRARY_FILE
}

class Node {
  Range range = .EMPTY
  NodeKind kind
  Node parent = null
  Node sibling = null // Adjacent declarations with the same name
  List<Node> children = null
  Type type = null
  Scope scope = null // The scope that this node introduces, if any
  Symbol symbol = null
  Content content = null
  NodeFlags flags = 0

  bool hasChildren() {
    return children != null && children.size() > 0
  }

  bool needsPreprocessor() {
    assert kind == .FILE
    return (flags & .NEEDS_PREPROCESSOR) != 0
  }

  bool isLibraryFile() {
    assert kind == .FILE
    return (flags & .IS_LIBRARY_FILE) != 0
  }

  bool isLastChild() {
    return parent.lastChild() == this
  }

  Node lastChild() {
    return children.last()
  }

  int indexInParent() {
    assert parent != null
    return parent.children.indexOf(this)
  }

  void prependChild(Node node) {
    insertChild(0, node)
  }

  void prependChildren(List<Node> nodes) {
    insertChildren(0, nodes)
  }

  void appendChild(Node node) {
    insertChild(children == null ? 0 : children.size(), node)
  }

  void appendChildren(List<Node> nodes) {
    insertChildren(children == null ? 0 : children.size(), nodes)
  }

  void insertSiblingBefore(Node node) {
    parent.insertChild(indexInParent(), node)
  }

  void insertSiblingAfter(Node node) {
    parent.insertChild(indexInParent() + 1, node)
  }

  Node removeChildAtIndex(int index) {
    assert index >= 0 && index < children.size()
    var child = children[index]
    if (child != null) {
      child.parent = null
    }
    children.removeAt(index)
    return child
  }

  Node remove() {
    if (parent != null) {
      parent.removeChildAtIndex(indexInParent())
    }
    return this
  }

  List<Node> removeChildren() {
    if (children == null) return []
    var result = children
    for (var i = 0; i < children.size(); i++) {
      var child = children[i]
      if (child != null) {
        child.parent = null
      }
    }
    children = null
    return result
  }

  // Change this node in place to become the provided node. The parent node is
  // not changed, so become() can be called within a nested method and does not
  // need to report the updated node reference to the caller since the reference
  // does not change.
  void become(Node node) {
    kind = node.kind
    range = node.range
    sibling = node.sibling
    removeChildren()
    withChildren(node.removeChildren())
    type = node.type
    scope = node.scope
    symbol = node.symbol
    content = node.content
    flags = node.flags
  }

  Node replaceWith(Node node) {
    parent.replaceChild(indexInParent(), node)
    return this
  }

  void swapWith(Node node) {
    Node parentA = parent
    Node parentB = node.parent
    int indexA = indexInParent()
    int indexB = node.indexInParent()
    parentA.children[indexA] = node
    parentB.children[indexB] = this
    parent = parentB
    node.parent = parentA
  }

  Node replaceWithNodes(List<Node> nodes) {
    var index = indexInParent()
    for (var i = 0; i < nodes.size(); i++) {
      parent.insertChild(index + i + 1, nodes[i])
    }
    parent.removeChildAtIndex(index)
    return this
  }

  void replaceChild(int index, Node node) {
    assert children != null
    assert index >= 0 && index < children.size()
    updateParent(node, this)
    var old = children[index]
    if (old != null) old.parent = null
    children[index] = node
  }

  void insertChild(int index, Node node) {
    if (children == null) children = []
    assert index >= 0 && index <= children.size()
    updateParent(node, this)
    children.insert(index, node)
  }

  void insertChildren(int index, List<Node> nodes) {
    if (children == null) children = []
    assert index >= 0 && index <= children.size()
    for (var i = 0; i < nodes.size(); i++) {
      var node = nodes[i]
      updateParent(node, this)
      children.insert(index, node)
      index++
    }
  }

  Node clone() {
    var node = Node(kind)
    node.range = range
    node.type = type
    node.symbol = symbol
    node.content = content
    node.flags = flags
    if (children != null) {
      node.children = []
      for (var i = 0; i < children.size(); i++) {
        var child = children[i]
        node.appendChild(child != null ? child.clone() : null)
      }
    }
    return node
  }

  Node withRange(Range value) {
    range = value
    return this
  }

  Node withType(Type value) {
    type = value
    return this
  }

  Node withSymbol(Symbol value) {
    symbol = value
    return this
  }

  Node withContent(Content value) {
    content = value
    return this
  }

  Node withChildren(List<Node> nodes) {
    assert children == null
    for (var i = 0; i < nodes.size(); i++) {
      updateParent(nodes[i], this)
    }
    children = nodes
    return this
  }

  void appendToSiblingChain(Node node) {
    var last = this
    while (last.sibling != null) {
      last = last.sibling
    }
    last.sibling = node
  }

  static void updateParent(Node node, Node parent) {
    if (node != null) {
      assert node.parent == null
      node.parent = parent
    }
  }
}
