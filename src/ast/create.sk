in Node {
  static Node createProgram(List<Node> files) {
    assert checkAllNodeKinds(files, NodeKindCheck(NodeKind.FILE));
    return Node(NodeKind.PROGRAM).withChildren(files);
  }

  static Node createFile(Node block) {
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.FILE).withChildren({ block });
  }

  static Node createBlock(List<Node> statements) {
    return Node(NodeKind.BLOCK).withChildren(statements);
  }

  static Node createNodeList(List<Node> nodes) {
    return Node(NodeKind.NODE_LIST).withChildren(nodes);
  }

  static Node createCase(List<Node> values, Node block) {
    assert checkAllNodeKinds(values, NodeKindIsExpression());
    assert block.kind == NodeKind.BLOCK;
    values.push(block);
    return Node(NodeKind.CASE).withChildren(values);
  }

  static Node createVariableCluster(Node type, List<Node> variables) {
    assert type.kind.isExpression();
    assert checkAllNodeKinds(variables, NodeKindCheck(NodeKind.VARIABLE));
    variables.unshift(type);
    return Node(NodeKind.VARIABLE_CLUSTER).withChildren(variables);
  }

  static Node createMemberInitializer(Node name, Node value) {
    assert name.kind == NodeKind.NAME;
    assert value.kind.isExpression();
    return Node(NodeKind.MEMBER_INITIALIZER).withChildren({ name, value });
  }

  static Node createNamespace(Node name, Node block) {
    assert name == null || name.kind == NodeKind.NAME;
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.NAMESPACE).withChildren({ name, block });
  }

  static Node createEnum(Node name, Node block) {
    assert name.kind == NodeKind.NAME;
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.ENUM).withChildren({ name, block });
  }

  static Node createEnumFlags(Node name, Node block) {
    assert name.kind == NodeKind.NAME;
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.ENUM_FLAGS).withChildren({ name, block });
  }

  static Node createObject(NodeKind kind, Node name, Node parameters, Node bases, Node block) {
    assert kind.isObject();
    assert name.kind == NodeKind.NAME;
    assert parameters == null || checkAllNodeListKinds(parameters, NodeKindCheck(NodeKind.PARAMETER));
    assert bases == null || checkAllNodeListKinds(bases, NodeKindIsExpression());
    assert block.kind == NodeKind.BLOCK;
    return Node(kind).withChildren({ name, block, bases, parameters });
  }

  static Node createClass(Node name, Node parameters, Node bases, Node block) {
    return createObject(NodeKind.CLASS, name, parameters, bases, block);
  }

  static Node createStruct(Node name, Node parameters, Node bases, Node block) {
    return createObject(NodeKind.STRUCT, name, parameters, bases, block);
  }

  static Node createInterface(Node name, Node parameters, Node bases, Node block) {
    return createObject(NodeKind.INTERFACE, name, parameters, bases, block);
  }

  static Node createExtension(Node name, Node bases, Node block) {
    assert name.kind == NodeKind.NAME;
    assert bases == null || checkAllNodeListKinds(bases, NodeKindIsExpression());
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.EXTENSION).withChildren({ name, block, bases });
  }

  static Node createConstructor(Node name, Node arguments, Node block, Node superInitializer, Node memberInitializers) {
    assert name.kind == NodeKind.NAME;
    assert checkAllNodeListKinds(arguments, NodeKindCheck(NodeKind.VARIABLE));
    assert block == null || block.kind == NodeKind.BLOCK;
    assert superInitializer == null || superInitializer.kind == NodeKind.SUPER_CALL;
    assert memberInitializers == null || checkAllNodeListKinds(memberInitializers, NodeKindCheck(NodeKind.MEMBER_INITIALIZER));
    return Node(NodeKind.CONSTRUCTOR).withChildren({ name, arguments, block, superInitializer, memberInitializers });
  }

  static Node createFunction(Node name, Node arguments, Node block, Node result) {
    assert name.kind == NodeKind.NAME;
    assert checkAllNodeListKinds(arguments, NodeKindCheck(NodeKind.VARIABLE));
    assert block == null || block.kind == NodeKind.BLOCK;
    assert result.kind.isExpression();
    return Node(NodeKind.FUNCTION).withChildren({ name, arguments, block, result });
  }

  static Node createVariable(Node name, Node type, Node value) {
    assert name.kind == NodeKind.NAME;
    assert type == null || type.kind.isExpression();
    assert value == null || value.kind.isExpression();
    return Node(NodeKind.VARIABLE).withChildren({ name, type, value });
  }

  static Node createParameter(Node name, Node bound) {
    assert name.kind == NodeKind.NAME;
    assert bound == null || bound.kind.isExpression();
    return Node(NodeKind.PARAMETER).withChildren({ name, bound });
  }

  static Node createAlias(Node name, Node value) {
    assert name.kind == NodeKind.NAME;
    assert value.kind.isExpression();
    return Node(NodeKind.ALIAS).withChildren({ name, value });
  }

  static Node createUsingAlias(Node name, Node value) {
    assert name.kind == NodeKind.NAME;
    assert value.kind.isExpression();
    return Node(NodeKind.USING_ALIAS).withChildren({ name, value });
  }

  static Node createUsingNamespace(Node value) {
    assert value.kind.isExpression();
    return Node(NodeKind.USING_NAMESPACE).withChildren({ value });
  }

  static Node createIf(Node test, Node trueNode, Node falseNode) {
    assert test.kind.isExpression();
    assert trueNode.kind == NodeKind.BLOCK;
    assert falseNode == null || falseNode.kind == NodeKind.BLOCK;
    return Node(NodeKind.IF).withChildren({ test, trueNode, falseNode });
  }

  static Node createFor(Node setup, Node test, Node update, Node block) {
    assert setup == null || setup.kind.isExpression() || setup.kind == NodeKind.VARIABLE_CLUSTER;
    assert test == null || test.kind.isExpression();
    assert update == null || update.kind.isExpression();
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.FOR).withChildren({ setup, test, update, block });
  }

  static Node createForEach(Node variable, Node value, Node block) {
    assert variable.kind == NodeKind.VARIABLE;
    assert value.kind.isExpression();
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.FOR_EACH).withChildren({ variable, value, block });
  }

  static Node createWhile(Node test, Node block) {
    assert test.kind.isExpression();
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.WHILE).withChildren({ test, block });
  }

  static Node createDoWhile(Node block, Node test) {
    assert test == null || test.kind.isExpression();
    assert block.kind == NodeKind.BLOCK;
    return Node(NodeKind.DO_WHILE).withChildren({ test, block });
  }

  static Node createReturn(Node value) {
    assert value == null || value.kind.isExpression();
    return Node(NodeKind.RETURN).withChildren({ value });
  }

  static Node createImplicitReturn(Node value) {
    assert value == null || value.kind.isExpression();
    return Node(NodeKind.IMPLICIT_RETURN).withChildren({ value });
  }

  static Node createBreak() {
    return Node(NodeKind.BREAK);
  }

  static Node createContinue() {
    return Node(NodeKind.CONTINUE);
  }

  static Node createAssert(Node value) {
    assert value.kind.isExpression();
    return Node(NodeKind.ASSERT).withChildren({ value });
  }

  static Node createExpression(Node value) {
    assert value.kind.isExpression();
    return Node(NodeKind.EXPRESSION).withChildren({ value });
  }

  static Node createModifier(Node name, List<Node> statements) {
    assert name.kind == NodeKind.NAME;
    assert checkAllNodeKinds(statements, NodeKindIsStatement());
    statements.unshift(name);
    return Node(NodeKind.MODIFIER).withChildren(statements);
  }

  static Node createSwitch(Node value, List<Node> cases) {
    assert value.kind.isExpression();
    assert checkAllNodeKinds(cases, NodeKindIsCaseOrDefault());
    cases.unshift(value);
    return Node(NodeKind.SWITCH).withChildren(cases);
  }

  static Node createName(string name) {
    return Node(NodeKind.NAME).withContent(StringContent(name));
  }

  static Node createType(Type type) {
    assert type != null;
    return Node(NodeKind.TYPE).withType(type);
  }

  static Node createNull() {
    return Node(NodeKind.NULL);
  }

  static Node createThis() {
    return Node(NodeKind.THIS);
  }

  static Node createTrue() {
    return Node(NodeKind.TRUE);
  }

  static Node createFalse() {
    return Node(NodeKind.FALSE);
  }

  static Node createHook(Node test, Node trueNode, Node falseNode) {
    assert test.kind.isExpression();
    assert trueNode.kind.isExpression();
    assert falseNode.kind.isExpression();
    return Node(NodeKind.HOOK).withChildren({ test, trueNode, falseNode });
  }

  static Node createInt(int value) {
    return Node(NodeKind.INT).withContent(IntContent(value));
  }

  static Node createFloat(double value) {
    return Node(NodeKind.FLOAT).withContent(DoubleContent(value));
  }

  static Node createDouble(double value) {
    return Node(NodeKind.DOUBLE).withContent(DoubleContent(value));
  }

  static Node createString(string value) {
    return Node(NodeKind.STRING).withContent(StringContent(value));
  }

  static Node createInitializer(List<Node> values) {
    assert checkAllNodeKinds(values, NodeKindIsExpression());
    return Node(NodeKind.INITIALIZER).withChildren(values);
  }

  static Node createDot(Node value, Node name) {
    assert value == null || value.kind.isExpression();
    assert name == null || name.kind == NodeKind.NAME;
    return Node(NodeKind.DOT).withChildren({ value, name });
  }

  static Node createLet(Node variable, Node value) {
    assert variable.kind == NodeKind.VARIABLE;
    assert value.kind.isExpression();
    return Node(NodeKind.LET).withChildren({ variable, value });
  }

  static Node createCall(Node value, List<Node> arguments) {
    assert value.kind.isExpression();
    assert checkAllNodeKinds(arguments, NodeKindIsExpression());
    arguments.unshift(value);
    return Node(NodeKind.CALL).withChildren(arguments);
  }

  static Node createSuperCall(List<Node> arguments) {
    assert checkAllNodeKinds(arguments, NodeKindIsExpression());
    return Node(NodeKind.SUPER_CALL).withChildren(arguments);
  }

  // Error nodes represent parse errors. They exist to allow a valid AST to
  // be produced from an invalid parse after parser recovery, which is most
  // useful when the compiler is being run as part of an IDE.
  static Node createError() {
    return Node(NodeKind.ERROR);
  }

  static Node createBind(Node value) {
    assert value.kind.isExpression();
    return Node(NodeKind.BIND).withChildren({ value });
  }

  static Node createSequence(List<Node> values) {
    assert checkAllNodeKinds(values, NodeKindIsExpression());
    return Node(NodeKind.SEQUENCE).withChildren(values);
  }

  static Node createParameterize(Node type, List<Node> types) {
    assert type.kind.isExpression();
    assert checkAllNodeKinds(types, NodeKindIsExpression());
    types.unshift(type);
    return Node(NodeKind.PARAMETERIZE).withChildren(types);
  }

  static Node createCast(Node type, Node value) {
    assert type.kind.isExpression();
    assert value.kind.isExpression();
    return Node(NodeKind.CAST).withChildren({ type, value });
  }

  static Node createImplicitCast(Node type, Node value) {
    assert type.kind.isExpression();
    assert value.kind.isExpression();
    return Node(NodeKind.IMPLICIT_CAST).withChildren({ type, value });
  }

  static Node createLambda(List<Node> arguments, Node block) {
    assert checkAllNodeKinds(arguments, NodeKindCheck(NodeKind.VARIABLE));
    assert block.kind == NodeKind.BLOCK;
    arguments.push(block);
    return Node(NodeKind.LAMBDA).withChildren(arguments);
  }

  static Node createDefault(Node type) {
    assert type.kind.isExpression();
    return Node(NodeKind.DEFAULT).withChildren({ type });
  }

  static Node createVar() {
    return Node(NodeKind.VAR);
  }

  static Node createFunctionType(Node result, List<Node> arguments) {
    assert result.kind.isExpression();
    assert checkAllNodeKinds(arguments, NodeKindIsExpression());
    arguments.unshift(result);
    return Node(NodeKind.FUNCTION_TYPE).withChildren(arguments);
  }

  static Node createUnary(NodeKind kind, Node value) {
    assert kind.isUnaryOperator();
    assert value.kind.isExpression();
    return Node(kind).withChildren({ value });
  }

  static Node createAssign(Node left, Node right) {
    return createBinary(NodeKind.ASSIGN, left, right);
  }

  static Node createBinary(NodeKind kind, Node left, Node right) {
    assert kind.isBinaryOperator();
    assert left.kind.isExpression();
    assert right.kind.isExpression();

    // Automatically convert an index nested inside an assignment to ASSIGN_INDEX
    if (kind == NodeKind.ASSIGN && left.kind == NodeKind.INDEX) {
      Node target = left.binaryLeft();
      Node index = left.binaryRight();
      return createTertiary(NodeKind.ASSIGN_INDEX, target.remove(), index.remove(), right);
    }

    return Node(kind).withChildren({ left, right });
  }

  static Node createTertiary(NodeKind kind, Node left, Node middle, Node right) {
    assert kind.isTertiaryOperator();
    assert left.kind.isExpression();
    assert middle.kind.isExpression();
    assert right.kind.isExpression();
    return Node(kind).withChildren({ left, middle, right });
  }
}

interface INodeKindCheck {
  virtual bool call(Node node);
}

class NodeKindCheck : INodeKindCheck {
  NodeKind kind;

  override bool call(Node node) {
    return node.kind == kind;
  }
}

class NodeKindIsCaseOrDefault : INodeKindCheck {
  override bool call(Node node) {
    return node.kind == NodeKind.CASE || node.kind == NodeKind.DEFAULT;
  }
}

class NodeKindIsStatement : INodeKindCheck {
  override bool call(Node node) {
    return node.kind.isStatement();
  }
}

class NodeKindIsExpression : INodeKindCheck {
  override bool call(Node node) {
    return node.kind.isExpression();
  }
}

bool checkAllNodeListKinds(Node node, INodeKindCheck check) {
  assert node != null;
  assert node.kind == NodeKind.NODE_LIST;
  assert node.children != null;
  return checkAllNodeKinds(node.children, check);
}

bool checkAllNodeKinds(List<Node> nodes, INodeKindCheck check) {
  assert nodes != null;
  int i;
  for (i = 0; i < nodes.length; i++) {
    if (!check.call(nodes.get(i))) {
      return false;
    }
  }
  return true;
}
