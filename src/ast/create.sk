in Node {
  static Node createProgram(List<Node> files) {
    assert checkAllNodeKinds(files, nodeKindCheck(.FILE));
    return Node(.PROGRAM).withChildren(files);
  }

  static Node createFile(Node block) {
    assert block.kind == .BLOCK;
    return Node(.FILE).withChildren([block]);
  }

  static Node createBlock(List<Node> statements) {
    return Node(.BLOCK).withChildren(statements);
  }

  static Node createNodeList(List<Node> nodes) {
    return Node(.NODE_LIST).withChildren(nodes);
  }

  static Node createCase(List<Node> values, Node block) {
    assert checkAllNodeKinds(values, nodeKindIsExpression);
    assert block.kind == .BLOCK;
    values.push(block);
    return Node(.CASE).withChildren(values);
  }

  static Node createVariableCluster(Node type, List<Node> variables) {
    assert type.kind.isExpression();
    assert checkAllNodeKinds(variables, nodeKindCheck(.VARIABLE));
    variables.unshift(type);
    return Node(.VARIABLE_CLUSTER).withChildren(variables);
  }

  static Node createMemberInitializer(Node name, Node value) {
    assert name.kind == .NAME;
    assert value.kind.isExpression();
    return Node(.MEMBER_INITIALIZER).withChildren([name, value]);
  }

  static Node createNamespace(Node name, Node block) {
    assert name == null || name.kind == .NAME;
    assert block.kind == .BLOCK;
    return Node(.NAMESPACE).withChildren([name, block]);
  }

  static Node createEnum(Node name, Node block) {
    assert name.kind == .NAME;
    assert block.kind == .BLOCK;
    return Node(.ENUM).withChildren([name, block]);
  }

  static Node createEnumFlags(Node name, Node block) {
    assert name.kind == .NAME;
    assert block.kind == .BLOCK;
    return Node(.ENUM_FLAGS).withChildren([name, block]);
  }

  static Node createObject(NodeKind kind, Node name, Node parameters, Node bases, Node block) {
    assert kind.isObject();
    assert name.kind == .NAME;
    assert parameters == null || checkAllNodeListKinds(parameters, nodeKindCheck(.PARAMETER));
    assert bases == null || checkAllNodeListKinds(bases, nodeKindIsExpression);
    assert block.kind == .BLOCK;
    return Node(kind).withChildren([name, block, bases, parameters]);
  }

  static Node createClass(Node name, Node parameters, Node bases, Node block) {
    return createObject(.CLASS, name, parameters, bases, block);
  }

  static Node createStruct(Node name, Node parameters, Node bases, Node block) {
    return createObject(.STRUCT, name, parameters, bases, block);
  }

  static Node createInterface(Node name, Node parameters, Node bases, Node block) {
    return createObject(.INTERFACE, name, parameters, bases, block);
  }

  static Node createExtension(Node name, Node bases, Node block) {
    assert name.kind == .NAME;
    assert bases == null || checkAllNodeListKinds(bases, nodeKindIsExpression);
    assert block.kind == .BLOCK;
    return Node(.EXTENSION).withChildren([name, block, bases]);
  }

  static Node createConstructor(Node name, Node arguments, Node block, Node superInitializer, Node memberInitializers) {
    assert name.kind == .NAME;
    assert checkAllNodeListKinds(arguments, nodeKindCheck(.VARIABLE));
    assert block == null || block.kind == .BLOCK;
    assert superInitializer == null || superInitializer.kind == .SUPER_CALL;
    assert memberInitializers == null || checkAllNodeListKinds(memberInitializers, nodeKindCheck(.MEMBER_INITIALIZER));
    return Node(.CONSTRUCTOR).withChildren([name, arguments, block, superInitializer, memberInitializers]);
  }

  static Node createFunction(Node name, Node arguments, Node block, Node result) {
    assert name.kind == .NAME;
    assert checkAllNodeListKinds(arguments, nodeKindCheck(.VARIABLE));
    assert block == null || block.kind == .BLOCK;
    assert result.kind.isExpression();
    return Node(.FUNCTION).withChildren([name, arguments, block, result]);
  }

  static Node createVariable(Node name, Node type, Node value) {
    assert name.kind == .NAME;
    assert type == null || type.kind.isExpression();
    assert value == null || value.kind.isExpression();
    return Node(.VARIABLE).withChildren([name, type, value]);
  }

  static Node createParameter(Node name, Node bound) {
    assert name.kind == .NAME;
    assert bound == null || bound.kind.isExpression();
    return Node(.PARAMETER).withChildren([name, bound]);
  }

  static Node createAlias(Node name, Node value) {
    assert name.kind == .NAME;
    assert value.kind.isExpression();
    return Node(.ALIAS).withChildren([name, value]);
  }

  static Node createUsing(Node value) {
    assert value.kind.isExpression();
    return Node(.USING).withChildren([value]);
  }

  static Node createIf(Node test, Node trueNode, Node falseNode) {
    assert test.kind.isExpression();
    assert trueNode.kind == .BLOCK;
    assert falseNode == null || falseNode.kind == .BLOCK;
    return Node(.IF).withChildren([test, trueNode, falseNode]);
  }

  static Node createFor(Node setup, Node test, Node update, Node block) {
    assert setup == null || setup.kind.isExpression() || setup.kind == .VARIABLE_CLUSTER;
    assert test == null || test.kind.isExpression();
    assert update == null || update.kind.isExpression();
    assert block.kind == .BLOCK;
    return Node(.FOR).withChildren([setup, test, update, block]);
  }

  static Node createForEach(Node variable, Node value, Node block) {
    assert variable.kind == .VARIABLE;
    assert value.kind.isExpression();
    assert block.kind == .BLOCK;
    return Node(.FOR_EACH).withChildren([variable, value, block]);
  }

  static Node createWhile(Node test, Node block) {
    assert test.kind.isExpression();
    assert block.kind == .BLOCK;
    return Node(.WHILE).withChildren([test, block]);
  }

  static Node createDoWhile(Node block, Node test) {
    assert test == null || test.kind.isExpression();
    assert block.kind == .BLOCK;
    return Node(.DO_WHILE).withChildren([test, block]);
  }

  static Node createReturn(Node value) {
    assert value == null || value.kind.isExpression();
    return Node(.RETURN).withChildren([value]);
  }

  static Node createImplicitReturn(Node value) {
    assert value == null || value.kind.isExpression();
    return Node(.IMPLICIT_RETURN).withChildren([value]);
  }

  static Node createBreak() {
    return Node(.BREAK);
  }

  static Node createContinue() {
    return Node(.CONTINUE);
  }

  static Node createAssert(NodeKind kind, Node value) {
    assert kind == .ASSERT || kind == .ASSERT_CONST;
    assert value.kind.isExpression();
    return Node(kind).withChildren([value]);
  }

  static Node createExpression(Node value) {
    assert value.kind.isExpression();
    return Node(.EXPRESSION).withChildren([value]);
  }

  static Node createModifier(Node name, List<Node> statements) {
    assert name.kind == .NAME;
    assert checkAllNodeKinds(statements, node => node.kind.isStatement());
    statements.unshift(name);
    return Node(.MODIFIER).withChildren(statements);
  }

  static Node createSwitch(Node value, List<Node> cases) {
    assert value.kind.isExpression();
    assert checkAllNodeKinds(cases, node => node.kind == .CASE || node.kind == .DEFAULT);
    cases.unshift(value);
    return Node(.SWITCH).withChildren(cases);
  }

  static Node createName(string name) {
    return Node(.NAME).withContent(StringContent(name));
  }

  static Node createType(Type type) {
    assert type != null;
    return Node(.TYPE).withType(type);
  }

  static Node createNull() {
    return Node(.NULL);
  }

  static Node createThis() {
    return Node(.THIS);
  }

  static Node createHook(Node test, Node trueNode, Node falseNode) {
    assert test.kind.isExpression();
    assert trueNode.kind.isExpression();
    assert falseNode.kind.isExpression();
    return Node(.HOOK).withChildren([test, trueNode, falseNode]);
  }

  static Node createBool(bool value) {
    return Node(.BOOL).withContent(BoolContent(value));
  }

  static Node createInt(int value) {
    return Node(.INT).withContent(IntContent(value));
  }

  static Node createFloat(double value) {
    return Node(.FLOAT).withContent(DoubleContent(value));
  }

  static Node createDouble(double value) {
    return Node(.DOUBLE).withContent(DoubleContent(value));
  }

  static Node createString(string value) {
    return Node(.STRING).withContent(StringContent(value));
  }

  static Node createList(List<Node> values) {
    assert checkAllNodeKinds(values, nodeKindIsExpression);
    return Node(.LIST).withChildren(values);
  }

  static Node createDot(Node value, Node name) {
    assert value == null || value.kind.isExpression();
    assert name == null || name.kind == .NAME;
    return Node(.DOT).withChildren([value, name]);
  }

  static Node createLet(Node variable, Node value) {
    assert variable.kind == .VARIABLE;
    assert value.kind.isExpression();
    return Node(.LET).withChildren([variable, value]);
  }

  static Node createCall(Node value, List<Node> arguments) {
    assert value.kind.isExpression();
    assert checkAllNodeKinds(arguments, nodeKindIsExpression);
    arguments.unshift(value);
    return Node(.CALL).withChildren(arguments);
  }

  static Node createSuperCall(List<Node> arguments) {
    assert checkAllNodeKinds(arguments, nodeKindIsExpression);
    return Node(.SUPER_CALL).withChildren(arguments);
  }

  // Error nodes represent parse errors. They exist to allow a valid AST to
  // be produced from an invalid parse after parser recovery, which is most
  // useful when the compiler is being run as part of an IDE.
  static Node createError() {
    return Node(.ERROR);
  }

  static Node createSequence(List<Node> values) {
    assert checkAllNodeKinds(values, nodeKindIsExpression);
    return Node(.SEQUENCE).withChildren(values);
  }

  static Node createParameterize(Node type, List<Node> types) {
    assert type.kind.isExpression();
    assert checkAllNodeKinds(types, nodeKindIsExpression);
    types.unshift(type);
    return Node(.PARAMETERIZE).withChildren(types);
  }

  static Node createCast(Node type, Node value) {
    assert type.kind.isExpression();
    assert value.kind.isExpression();
    return Node(.CAST).withChildren([type, value]);
  }

  static Node createImplicitCast(Node type, Node value) {
    assert type.kind.isExpression();
    assert value.kind.isExpression();
    return Node(.IMPLICIT_CAST).withChildren([type, value]);
  }

  static Node createLambda(List<Node> arguments, Node block) {
    assert checkAllNodeKinds(arguments, nodeKindCheck(.VARIABLE));
    assert block.kind == .BLOCK;
    arguments.push(block);
    return Node(.LAMBDA).withChildren(arguments);
  }

  static Node createDefault(Node type) {
    assert type.kind.isExpression();
    return Node(.DEFAULT).withChildren([type]);
  }

  // Untyped nodes use the error type but don't report an error, thus silently
  // allowing the value to be used in any way. This is useful for writing the
  // binding layer for native code generation.
  static Node createUntyped(Node type) {
    assert type.kind.isExpression();
    return Node(.UNTYPED).withChildren([type]);
  }

  static Node createVar() {
    return Node(.VAR);
  }

  static Node createFunctionType(Node result, List<Node> arguments) {
    assert result.kind.isExpression();
    assert checkAllNodeKinds(arguments, nodeKindIsExpression);
    arguments.unshift(result);
    return Node(.FUNCTION_TYPE).withChildren(arguments);
  }

  static Node createUnary(NodeKind kind, Node value) {
    assert kind.isUnaryOperator();
    assert value.kind.isExpression();
    return Node(kind).withChildren([value]);
  }

  static Node createAssign(Node left, Node right) {
    return createBinary(.ASSIGN, left, right);
  }

  static Node createBinary(NodeKind kind, Node left, Node right) {
    assert kind.isBinaryOperator();
    assert left.kind.isExpression();
    assert right.kind.isExpression();

    // Automatically convert an index nested inside an assignment to ASSIGN_INDEX
    if (kind == .ASSIGN && left.kind == .INDEX) {
      var target = left.binaryLeft();
      var index = left.binaryRight();
      return createTertiary(.ASSIGN_INDEX, target.remove(), index.remove(), right);
    }

    return Node(kind).withChildren([left, right]);
  }

  static Node createTertiary(NodeKind kind, Node left, Node middle, Node right) {
    assert kind.isTertiaryOperator();
    assert left.kind.isExpression();
    assert middle.kind.isExpression();
    assert right.kind.isExpression();
    return Node(kind).withChildren([left, middle, right]);
  }
}

alias NodeKindCheck = bool fn(Node);
final NodeKindCheck nodeKindIsExpression = node => node.kind.isExpression();

NodeKindCheck nodeKindCheck(NodeKind kind) {
  return node => node.kind == kind;
}

bool checkAllNodeListKinds(Node node, NodeKindCheck check) {
  assert node != null;
  assert node.kind == .NODE_LIST;
  assert node.children != null;
  return checkAllNodeKinds(node.children, check);
}

bool checkAllNodeKinds(List<Node> nodes, NodeKindCheck check) {
  assert nodes != null;
  for (var i = 0; i < nodes.length; i++) {
    if (!check(nodes.get(i))) {
      return false;
    }
  }
  return true;
}
