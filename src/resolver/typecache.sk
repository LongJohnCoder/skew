class TypeCache {
  Type globalType = createType(new Symbol("<global>", SymbolKind.GLOBAL_NAMESPACE));
  Type nullType = createType(new Symbol("null", SymbolKind.OTHER));

  // All expressions that have syntax and/or semantic errors have this type,
  // which silences all further errors related to that expression. When the
  // compiler comes a cross a symbol or expression of this type, it just skips
  // over it because an error has already been logged and further errors will
  // most likely just be noise.
  Type errorType = createType(new Symbol("<error>", SymbolKind.OTHER));

  // // TODO: Load these from Skew library code
  // Type voidType = null;
  // Type intType = null;
  // Type boolType = null;
  // Type floatType = null;
  // Type doubleType = null;
  // Type stringType = null;

  Type voidType = createType(new Symbol("void", SymbolKind.OTHER_TYPE));
  Type intType = createType(new Symbol("int", SymbolKind.STRUCT));
  Type boolType = createType(new Symbol("bool", SymbolKind.STRUCT));
  Type floatType = createType(new Symbol("float", SymbolKind.STRUCT));
  Type doubleType = createType(new Symbol("double", SymbolKind.STRUCT));
  Type stringType = createType(new Symbol("string", SymbolKind.STRUCT));

  IntMap<List<Type>> hashTable = new IntMap<List<Type>>();

  static Type createType(Symbol symbol) {
    Type type = new Type(symbol);
    symbol.type = type;
    symbol.flags = symbol.flags | SymbolFlag.INITIALIZED;
    return type;
  }

  static Type commonBaseClass(Type left, Type right) {
    Type a;
    for (a = left; a != null; a = a.baseClass()) {
      Type b;
      for (b = right; b != null; b = b.baseClass()) {
        if (a == b) {
          return a;
        }
      }
    }
    return null;
  }

  static int computeHashCode(Symbol symbol, List<Type> relevantTypes) {
    int seed = symbol == null ? -1 : symbol.type.uniqueID;
    int i;
    for (i = 0; i < relevantTypes.length; i++) {
      seed = hashCombine(seed, relevantTypes.get(i).uniqueID);
    }
    return seed;
  }

  static bool areTypeListsEqual(List<Type> left, List<Type> right) {
    int n = left.length;
    if (n != right.length) {
      return false;
    }
    int i;
    for (i = 0; i < n; i++) {
      if (left.get(i) != right.get(i)) {
        return false;
      }
    }
    return true;
  }

  Environment merge(Environment before, Environment after) {
    Environment clone = before.clone();
    int i;
    for (i = 0; i < clone.parameters.length; i++) {
      clone.types.set(i, substitute(clone.types.get(i), after));
    }
    for (i = 0; i < after.parameters.length; i++) {
      Symbol parameter = after.parameters.get(i);
      if (clone.parameters.indexOf(parameter) == -1) {
        clone.parameters.push(parameter);
        clone.types.push(after.types.get(i));
      }
    }
    return clone;
  }

  Type substitute(Type type, Environment environment) {
    if (!type.hasRelevantTypes()) {
      int index = environment.parameters.indexOf(type.symbol);
      return index >= 0 ? environment.types.get(index) : type;
    }
    List<Type> relevantTypes = {};
    int i;
    for (i = 0; i < type.relevantTypes.length; i++) {
      relevantTypes.push(substitute(type.relevantTypes.get(i), environment));
    }
    return parameterize(type.symbol, relevantTypes);
  }

  Type parameterize(Symbol symbol, List<Type> relevantTypes) {
    if (symbol != null) {
      assert symbol.hasParameters();
      assert !symbol.type.isParameterized();
      assert symbol.parameters.length == relevantTypes.length;
    }

    // Hash the symbol along with all types
    int hash = computeHashCode(symbol, relevantTypes);
    List<Type> existingTypes = hashTable.getOrDefault(hash, null);

    // Check existing types in that hash bucket for a match
    if (existingTypes != null) {
      int i;
      for (i = 0; i < existingTypes.length; i++) {
        Type existing = existingTypes.get(i);
        if (symbol == existing.symbol && areTypeListsEqual(relevantTypes, existing.relevantTypes)) {
          return existing;
        }
      }
    }

    // Make a new hash bucket
    else {
      existingTypes = {};
      hashTable.set(hash, existingTypes);
    }

    // We didn't find a match, so make the type for the first time
    Type type = new Type(symbol);
    type.relevantTypes = relevantTypes;
    if (symbol != null) {
      type.environment = new Environment(symbol.parameters, relevantTypes);
      List<Member> members = symbol.type.members.values();
      int i;
      for (i = 0; i < members.length; i++) {
        Member member = members.get(i);
        Member clone = new Member(member.symbol);
        clone.dependency = member;
        clone.environment = type.environment;
        type.addMember(clone);
      }
    }
    existingTypes.push(type);
    return type;
  }

  Type functionType(Type result, List<Type> arguments) {
    arguments.unshift(result);
    return parameterize(null, arguments);
  }

  bool canCastToNumeric(Type type) {
    return type.isNumeric(this) || type.isBool(this);
  }

  Type commonImplicitType(Type left, Type right) {
    // Short-circuit early for identical types
    if (left == right) return left;

    // Check implicit conversions
    if (canImplicitlyConvert(left, right)) return right;
    if (canImplicitlyConvert(right, left)) return left;

    // Implement common implicit types for numeric types
    if (left.isNumeric(this) && right.isNumeric(this)) {
      return left.isInteger(this) && right.isInteger(this) ? intType :
        left.isFloat(this) && right.isFloat(this) ? floatType :
        doubleType;
    }

    // Check for a common base class
    if (left.isClass() && right.isClass()) {
      return commonBaseClass(left, right);
    }

    return null;
  }

  bool canImplicitlyConvert(Type from, Type to) {
    if (from == to) return true;
    if (from.isNull(this) && to.isReference()) return true;
    if ((from.isInteger(this) || from.isFloat(this)) && to.isDouble(this)) return true;
    if (from.isEnum() && (to.isInt(this) || to.isDouble(this))) return true;
    if (from.hasBaseType(to)) return true;
    return false;
  }

  bool canExplicitlyConvert(Type from, Type to) {
    if (canImplicitlyConvert(from, to)) return true;
    if (canCastToNumeric(from) && canCastToNumeric(to)) return true;
    if (to.hasBaseType(from)) return true;
    return false;
  }
}
