class ConstantFolder {
  final TypeCache cache;
  final CompilerOptions options;

  bool targetHasNoNestedScopes() {
    return options.target == .JAVASCRIPT;
  }

  void flatten(Node node, Content content) {
    node.removeChildren();
    switch (content.type()) {
      case .BOOL { node.kind = .BOOL; }
      case .INT { node.kind = .INT; }
      case .DOUBLE { node.kind = node.type == cache.floatType ? .FLOAT : .DOUBLE; }
      case .STRING { node.kind = .STRING; }
    }
    node.content = content;
  }

  // Use this instead of Node.become(Node.createTrue()) to avoid more GC
  void flattenBool(Node node, bool value) {
    assert node.type.isIgnored(cache) || node.type.isBool(cache);
    flatten(node, BoolContent(value));
  }

  // Use this instead of Node.become(Node.createInt()) to avoid more GC
  void flattenInt(Node node, int value) {
    assert node.type.isIgnored(cache) || node.type.isInteger(cache);
    flatten(node, IntContent(value));
  }

  // Use this instead of Node.become(Node.createDouble()) to avoid more GC
  void flattenReal(Node node, double value) {
    assert node.type.isIgnored(cache) || node.type.isReal(cache);
    flatten(node, DoubleContent(value));
  }

  // Use this instead of Node.become(Node.createString()) to avoid more GC
  void flattenString(Node node, string value) {
    assert node.type.isIgnored(cache) || node.type.isString(cache);
    flatten(node, StringContent(value));
  }

  static bool blockContainsVariableCluster(Node node) {
    assert node.kind == .BLOCK;
    if (node.hasChildren()) {
      var children = node.children;
      for (var i = 0, n = children.size(); i < n; i++) {
        if (children[i].kind == .VARIABLE_CLUSTER) {
          return true;
        }
      }
    }
    return false;
  }

  void foldConstants(Node node) {
    var kind = node.kind;

    // Transform "a + (b + c)" => "(a + b) + c" before operands are folded
    if (kind == .ADD && node.type.isString(cache)) {
      rotateStringConcatenation(node);
    }

    // Fold operands before folding this node
    if (node.hasChildren()) {
      var children = node.children;
      for (var i = 0, n = children.size(); i < n; i++) {
        var child = children[i];
        if (child != null) {
          foldConstants(child);
        }
      }
    }

    // Separating the case bodies into separate functions makes the JavaScript JIT go faster
    switch (kind) {
      case .BLOCK { foldBlock(node); }
      case .CALL { foldCall(node); }
      case .CAST, .IMPLICIT_CAST { foldCast(node); }
      case .HOOK { foldHook(node); }
      case .NAME { foldName(node); }
      case .SEQUENCE { foldSequence(node); }
      case .VARIABLE_CLUSTER { foldVariableCluster(node); }
      default {
        if (kind.isUnaryOperator()) foldUnaryOperator(node, kind);
        else if (kind.isBinaryOperator()) foldBinaryOperator(node, kind);
      }
    }
  }

  void rotateStringConcatenation(Node node) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    assert left.type.isString(cache) || left.type.isIgnored(cache);
    assert right.type.isString(cache) || right.type.isIgnored(cache);

    if (right.kind == .ADD) {
      var rightLeft = right.binaryLeft();
      var rightRight = right.binaryRight();
      assert rightLeft.type.isString(cache) || rightLeft.type.isIgnored(cache);
      assert rightRight.type.isString(cache) || rightRight.type.isIgnored(cache);
      left.swapWith(right);
      left.swapWith(rightRight);
      left.swapWith(rightLeft);
    }
  }

  void foldStringConcatenation(Node node) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    assert left.type.isString(cache) || left.type.isIgnored(cache);
    assert right.type.isString(cache) || right.type.isIgnored(cache);

    if (right.kind == .STRING) {
      // "a" + "b" => "ab"
      if (left.kind == .STRING) {
        flattenString(node, left.asString() + right.asString());
      }

      else if (left.kind == .ADD) {
        var leftLeft = left.binaryLeft();
        var leftRight = left.binaryRight();
        assert leftLeft.type.isString(cache) || leftLeft.type.isIgnored(cache);
        assert leftRight.type.isString(cache) || leftRight.type.isIgnored(cache);

        // (a + "b") + "c" => a + "bc"
        if (leftRight.kind == .STRING) {
          flattenString(leftRight, leftRight.asString() + right.asString());
          node.become(left.remove());
        }
      }
    }
  }

  int foldFor(Node node) {
    var test = node.forTest();
    if (test != null && test.isFalse()) {
      var setup = node.forSetup();

      // Remove "for (; false; c) d;" entirely
      if (setup == null || setup.hasNoSideEffects()) {
        node.remove();
        return -1;
      }

      // Replace "for (var a = 0; false; c) d;" with "var a = 0;"
      else if (setup.kind == .VARIABLE_CLUSTER) {
        if (targetHasNoNestedScopes()) {
          node.replaceWith(setup.remove());
        }

        // This loop can't be folded completely because that would pollute the
        // enclosing scope in targets where that matters
        else {
          var update = node.forUpdate();
          var block = node.forBlock();
          if (update != null) {
            update.replaceWith(null);
          }
          block.removeChildren();
          block.children = [];
        }
      }

      // Replace "for (a; false; c) d;" with "a;"
      else {
        node.replaceWith(Node.createExpression(setup.remove()));
      }
    }
    return 0;
  }

  int foldTry(Node node) {
    // A try block without any statements cannot possibly throw
    if (node.tryBlock().blockStatements().size() == 0) {
      node.remove();
      return -1;
    }

    return 0;
  }

  int foldIf(Node node) {
    var test = node.ifTest();
    var trueBlock = node.ifTrue();
    var falseBlock = node.ifFalse();

    // No reason to keep an empty "else" block
    if (falseBlock != null && !falseBlock.hasChildren()) {
      falseBlock.replaceWith(null);
      falseBlock = null;
    }

    // Always true if statement
    if (test.isTrue()) {
      // Remove dead code in the "else" block
      if (falseBlock != null) {
        falseBlock.replaceWith(null);
      }

      // Be careful not to pollute the enclosing scope in targets where that matters
      if (targetHasNoNestedScopes() || !blockContainsVariableCluster(trueBlock)) {
        var replacements = trueBlock.removeChildren();
        node.replaceWithNodes(replacements);
        return replacements.size() - 1;
      }
    }

    // Always false if statement
    else if (test.isFalse()) {
      // Remove entirely
      if (falseBlock == null) {
        node.remove();
        return -1;
      }

      // Be careful not to pollute the enclosing scope in targets where that matters
      if (targetHasNoNestedScopes() || !blockContainsVariableCluster(falseBlock)) {
        var replacements = falseBlock.removeChildren();
        node.replaceWithNodes(replacements);
        return replacements.size() - 1;
      }

      // Otherwise, transform to an "if (true) { ... }" statement
      test.replaceWith(Node.createBool(true).withType(test.type));
      trueBlock.replaceWith(falseBlock.replaceWith(null));
    }

    // Remove if statements with empty true blocks
    else if (!trueBlock.hasChildren()) {
      // "if (a) {} else b();" => "if (!a) b();"
      if (falseBlock != null && falseBlock.hasChildren()) {
        test.invertBooleanCondition(cache);
        trueBlock.swapWith(falseBlock);
        trueBlock.replaceWith(null);
      }

      // "if (a()) {}" => "a();"
      else if (test.hasNoSideEffects()) {
        node.remove();
        return -1;
      }

      // "if (a) {}" => ""
      else {
        node.become(Node.createExpression(test.remove()));
      }
    }

    return 0;
  }

  int foldSwitch(Node node) {
    // Remove the default case if it's empty
    var cases = node.switchCases();
    if (cases.hasChildren()) {
      var last = cases.lastChild();
      if (!last.caseValues().hasChildren() && !last.caseBlock().hasChildren()) {
        last.remove();

        // If the default case is empty, all other empty cases can be removed too
        for (var i = cases.children.size() - 1; i >= 0; i--) {
          var statement = cases.children[i];
          if (!statement.caseBlock().hasChildren()) {
            statement.remove();
          }
        }
      }
    }

    // Replace "switch (foo) {}" with "foo;"
    if (!cases.hasChildren()) {
      var value = node.switchValue();
      node.replaceWith(Node.createExpression(value.remove()).withRange(node.range));
      return -1;
    }

    return 0;
  }

  void foldVariableCluster(Node node) {
    var variables = node.clusterVariables();
    for (var i = 0; i < variables.size(); i++) {
      var variable = variables[i];
      if (variable.symbol.isConst()) {
        variable.remove();
      }
    }
  }

  void foldBlock(Node node) {
    var children = node.children;

    for (var i = 0; i < children.size(); i++) {
      var child = children[i];
      var kind = child.kind;

      // Remove everything after a jump
      if (kind.isJump()) {
        for (var j = children.size() - 1; j > i; j--) {
          node.removeChildAtIndex(j);
        }
        break;
      }

      // Remove constants and "while (false) { ... }" entirely
      if (kind == .EXPRESSION && child.expressionValue().hasNoSideEffects() ||
          kind == .WHILE && child.whileTest().isFalse()) {
        node.removeChildAtIndex(i);
        i--;
      }

      // Reduce for loops that will never execute
      else if (kind == .FOR) {
        i += foldFor(child);
      }

      // Remove unused try statements since they can cause deoptimizations
      else if (kind == .TRY) {
        i += foldTry(child);
      }

      // Statically evaluate if statements where possible
      else if (kind == .IF) {
        i += foldIf(child);
      }

      // Fold switch statements
      else if (kind == .SWITCH) {
        i += foldSwitch(child);
      }
    }
  }

  void foldName(Node node) {
    if (node.symbol != null && node.symbol.constant != null) {
      flatten(node, node.symbol.constant);
    }
  }

  void foldCall(Node node) {
    if (node.kind == .CALL) {
      var value = node.callValue();
      if (value.kind == .DOT) {
        var target = value.dotTarget();
        var name = value.dotName();
        if (target != null && target.kind.isConstant() && name != null && name.kind == .NAME && name.asString() == "toString") {
          string text;
          switch (target.kind) {
            case .BOOL { text = target.asBool().toString(); }
            case .INT { text = target.asInt().toString(); }
            case .FLOAT, .DOUBLE { text = target.asDouble().toString(); }
            case .STRING { text = target.asString(); }
            default { return; }
          }
          flattenString(node, text);
        }
      }
    }
  }

  void foldCast(Node node) {
    var type = node.castType().type;
    var value = node.castValue();
    var valueKind = value.kind;

    // Cast "bool" values
    if (valueKind == .BOOL) {
      if (type.isBool(cache)) flattenBool(node, (bool)value.asBool());
      else if (type.isInteger(cache)) flattenInt(node, (int)value.asBool());
      else if (type.isReal(cache)) flattenReal(node, (double)value.asBool());
    }

    // Cast "int" values
    else if (valueKind == .INT) {
      if (type.isBool(cache)) flattenBool(node, (bool)value.asInt());
      else if (type.isInteger(cache)) flattenInt(node, (int)value.asInt());
      else if (type.isReal(cache)) flattenReal(node, (double)value.asInt());
    }

    // Cast "float" or "double" values
    else if (valueKind.isReal()) {
      if (type.isBool(cache)) flattenBool(node, (bool)value.asDouble());
      else if (type.isInteger(cache)) flattenInt(node, (int)value.asDouble());
      else if (type.isReal(cache)) flattenReal(node, (double)value.asDouble());
    }
  }

  void foldUnaryOperator(Node node, NodeKind kind) {
    var value = node.unaryValue();
    var valueKind = value.kind;

    // Fold "bool" values
    if (valueKind == .BOOL) {
      if (kind == .NOT) flattenBool(node, !value.asBool());
    }

    // Fold "int" values
    else if (valueKind == .INT) {
      if (kind == .POSITIVE) flattenInt(node, +value.asInt());
      else if (kind == .NEGATIVE) flattenInt(node, -value.asInt());
      else if (kind == .COMPLEMENT) flattenInt(node, ~value.asInt());
    }

    // Fold "float" or "double" values
    else if (valueKind.isReal()) {
      if (kind == .POSITIVE) flattenReal(node, +value.asDouble());
      else if (kind == .NEGATIVE) flattenReal(node, -value.asDouble());
    }

    // Partial evaluation ("!!`x`" isn't necessarily "!!x" if we don't know the type)
    else if (kind == .NOT && !value.type.isIgnored(cache)) {
      switch (valueKind) {
        case .NOT, .EQUAL, .NOT_EQUAL, .LOGICAL_OR, .LOGICAL_AND, .LESS_THAN, .GREATER_THAN, .LESS_THAN_OR_EQUAL, .GREATER_THAN_OR_EQUAL {
          value.invertBooleanCondition(cache);
          node.become(value);
        }
      }
    }
  }

  void foldConstantAddOrSubtract(Node node, Node variable, Node constant, int delta) {
    var isAdd = node.kind == .ADD;
    var needsContentUpdate = delta != 0;
    var isRightConstant = constant == node.binaryRight();
    var shouldNegateConstant = !isAdd && isRightConstant;
    var value = constant.asInt();

    // Make this an add for simplicity
    if (shouldNegateConstant) {
      value = -value;
    }

    // Include the delta from the parent node if present
    value += delta;

    // Apply addition identities
    if (value == 0) {
      node.become(variable.remove());
      return;
    }

    // Check for nested addition or subtraction
    if (variable.kind == .ADD || variable.kind == .SUBTRACT) {
      var left = variable.binaryLeft();
      var right = variable.binaryRight();
      assert left.type.isInt(cache) || left.type.isIgnored(cache);
      assert right.type.isInt(cache) || right.type.isIgnored(cache);

      // (a + 1) + 2 => a + 3
      var isLeftConstant = left.kind == .INT;
      if (isLeftConstant || right.kind == .INT) {
        foldConstantAddOrSubtract(variable, isLeftConstant ? right : left, isLeftConstant ? left : right, value);
        node.become(variable);
        return;
      }
    }

    // Adjust the value so it has the correct sign
    if (shouldNegateConstant) {
      value = -value;
    }

    // The negative sign can often be removed by code transformation
    if (value < 0) {
      // a + -1 => a - 1
      // a - -1 => a + 1
      if (isRightConstant) {
        node.kind = isAdd ? .SUBTRACT : .ADD;
        value = -value;
        needsContentUpdate = true;
      }

      // -1 + a => a - 1
      else if (isAdd) {
        node.kind = .SUBTRACT;
        value = -value;
        variable.swapWith(constant);
        needsContentUpdate = true;
      }
    }

    // Avoid extra allocations
    if (needsContentUpdate) {
      constant.content = IntContent(value);
    }

    // Also handle unary negation on "variable"
    foldAddOrSubtract(node);
  }

  void foldAddOrSubtract(Node node) {
    var isAdd = node.kind == .ADD;
    var left = node.binaryLeft();
    var right = node.binaryRight();

    // -a + b => b - a
    if (left.kind == .NEGATIVE && isAdd) {
      left.become(left.unaryValue().replaceWith(null));
      left.swapWith(right);
      node.kind = .SUBTRACT;
    }

    // a + -b => a - b
    // a - -b => a + b
    else if (right.kind == .NEGATIVE) {
      right.become(right.unaryValue().replaceWith(null));
      node.kind = isAdd ? .SUBTRACT : .ADD;
    }
  }

  void foldConstantMultiply(Node node, Node variable, Node constant) {
    // Canonicalize multiplication order
    if (node.binaryLeft() == constant) {
      variable.swapWith(constant);
    }

    // Apply identities
    var value = constant.asInt();
    if (value == 0) {
      if (variable.hasNoSideEffects()) {
        node.become(constant.remove());
      }
      return;
    }
    if (value == 1) {
      node.become(variable.remove());
      return;
    }

    // Multiply by a power of 2 should be a left-shift operation, which is
    // more concise and always faster (or at least never slower) than the
    // alternative. Division can't be replaced by a right-shift operation
    // because that would lead to incorrect results for negative numbers.
    var shift = logBase2(value);
    if (shift != -1) {
      constant.content = IntContent(shift);
      node.kind = .SHIFT_LEFT;
    }
  }

  void foldBinaryOperatorWithConstant(Node node, Node left, Node right) {
    // There are lots of other folding opportunities for most binary operators
    // here but those usually have a negligible performance and/or size impact
    // on the generated code and instead slow the compiler down. Only certain
    // ones are implemented below.
    switch (node.kind) {
      // These are important for dead code elimination
      case .LOGICAL_AND {
        if (left.isFalse() || right.isTrue()) node.become(left.remove());
        else if (left.isTrue()) node.become(right.remove());
      }
      case .LOGICAL_OR {
        if (left.isTrue() || right.isFalse()) node.become(left.remove());
        else if (left.isFalse()) node.become(right.remove());
      }

      // Constants are often added up in compound expressions. Folding
      // addition/subtraction improves minification in JavaScript and often
      // helps with readability.
      case .ADD, .SUBTRACT {
        if (left.kind == .INT) foldConstantAddOrSubtract(node, right, left, 0);
        else if (right.kind == .INT) foldConstantAddOrSubtract(node, left, right, 0);
        else foldAddOrSubtract(node);
      }

      // Multiplication is special-cased here because in JavaScript, optimizing
      // away the general-purpose Math.imul() function may result in large
      // speedups when it's implemented with a polyfill.
      case .MULTIPLY {
        if (left.kind == .INT) foldConstantMultiply(node, right, left);
        else if (right.kind == .INT) foldConstantMultiply(node, left, right);
      }
    }
  }

  void foldBinaryOperator(Node node, NodeKind kind) {
    if (kind == .ADD && node.type.isString(cache)) {
      foldStringConcatenation(node);
      return;
    }

    var left = node.binaryLeft();
    var right = node.binaryRight();
    if (left.kind != right.kind) {
      foldBinaryOperatorWithConstant(node, left, right);
      return;
    }

    // Fold equality operators
    if (left.kind == .STRING) {
      switch (kind) {
        case .EQUAL { flattenBool(node, left.asString() == right.asString()); }
        case .NOT_EQUAL { flattenBool(node, left.asString() != right.asString()); }
        case .LESS_THAN { flattenBool(node, left.asString() < right.asString()); }
        case .GREATER_THAN { flattenBool(node, left.asString() > right.asString()); }
        case .LESS_THAN_OR_EQUAL { flattenBool(node, left.asString() <= right.asString()); }
        case .GREATER_THAN_OR_EQUAL { flattenBool(node, left.asString() >= right.asString()); }
      }
    }

    // Fold "bool" values
    else if (left.kind == .BOOL) {
      switch (kind) {
        case .LOGICAL_AND { flattenBool(node, left.asBool() && right.asBool()); }
        case .LOGICAL_OR { flattenBool(node, left.asBool() || right.asBool()); }
        case .EQUAL { flattenBool(node, left.asBool() == right.asBool()); }
        case .NOT_EQUAL { flattenBool(node, left.asBool() != right.asBool()); }
      }
    }

    // Fold "int" values
    else if (left.kind == .INT) {
      switch (kind) {
        case .ADD { flattenInt(node, left.asInt() + right.asInt()); }
        case .SUBTRACT { flattenInt(node, left.asInt() - right.asInt()); }
        case .MULTIPLY { flattenInt(node, left.asInt() * right.asInt()); }
        case .DIVIDE { flattenInt(node, left.asInt() / right.asInt()); }
        case .REMAINDER { flattenInt(node, left.asInt() % right.asInt()); }
        case .SHIFT_LEFT { flattenInt(node, left.asInt() << right.asInt()); }
        case .SHIFT_RIGHT { flattenInt(node, left.asInt() >> right.asInt()); }
        case .BITWISE_AND { flattenInt(node, left.asInt() & right.asInt()); }
        case .BITWISE_OR { flattenInt(node, left.asInt() | right.asInt()); }
        case .BITWISE_XOR { flattenInt(node, left.asInt() ^ right.asInt()); }
        case .EQUAL { flattenBool(node, left.asInt() == right.asInt()); }
        case .NOT_EQUAL { flattenBool(node, left.asInt() != right.asInt()); }
        case .LESS_THAN { flattenBool(node, left.asInt() < right.asInt()); }
        case .GREATER_THAN { flattenBool(node, left.asInt() > right.asInt()); }
        case .LESS_THAN_OR_EQUAL { flattenBool(node, left.asInt() <= right.asInt()); }
        case .GREATER_THAN_OR_EQUAL { flattenBool(node, left.asInt() >= right.asInt()); }
      }
    }

    // Fold "float" and "double" values
    else if (left.kind.isReal()) {
      switch (kind) {
        case .ADD { flattenReal(node, left.asDouble() + right.asDouble()); }
        case .SUBTRACT { flattenReal(node, left.asDouble() - right.asDouble()); }
        case .MULTIPLY { flattenReal(node, left.asDouble() * right.asDouble()); }
        case .DIVIDE { flattenReal(node, left.asDouble() / right.asDouble()); }
        case .EQUAL { flattenBool(node, left.asDouble() == right.asDouble()); }
        case .NOT_EQUAL { flattenBool(node, left.asDouble() != right.asDouble()); }
        case .LESS_THAN { flattenBool(node, left.asDouble() < right.asDouble()); }
        case .GREATER_THAN { flattenBool(node, left.asDouble() > right.asDouble()); }
        case .LESS_THAN_OR_EQUAL { flattenBool(node, left.asDouble() <= right.asDouble()); }
        case .GREATER_THAN_OR_EQUAL { flattenBool(node, left.asDouble() >= right.asDouble()); }
      }
    }
  }

  void foldHook(Node node) {
    var test = node.hookTest();
    if (test.isTrue()) {
      node.become(node.hookTrue().remove());
    } else if (test.isFalse()) {
      node.become(node.hookFalse().remove());
    }
  }

  void foldSequence(Node node) {
    // Remove all children without side effects that aren't the result
    var i = 0;
    while (i + 1 < node.children.size()) {
      if (node.children[i].hasNoSideEffects()) {
        node.removeChildAtIndex(i);
      } else {
        i++;
      }
    }

    // Replace a single-element sequence with the single element
    if (node.children.size() == 1) {
      node.become(node.children[0].remove());
    }

    // Otherwise, try to drop the result if it has no side effects
    else {
      var last = node.children[i];
      if (last.hasNoSideEffects() && node.parent.kind == .EXPRESSION) {
        last.remove();
      }
    }
  }
}
