class ConstantFolder {
  TypeCache cache;

  void flattenBool(Node node, bool value) {
    assert node.type.isError(cache) || node.type.isBool(cache);
    node.removeChildren();
    node.kind = value ? .TRUE : .FALSE;
    node.content = null;
  }

  void flattenInt(Node node, int value) {
    assert node.type.isError(cache) || node.type.isInteger(cache);
    node.removeChildren();
    node.kind = .INT;
    node.content = IntContent(value);
  }

  void flattenReal(Node node, double value) {
    assert node.type.isError(cache) || node.type.isReal(cache);
    node.removeChildren();
    node.kind = node.type == cache.floatType ? .FLOAT : .DOUBLE;
    node.content = DoubleContent(value);
  }

  static bool blockContainsVariableCluster(Node node) {
    assert node.kind == .BLOCK;
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        if (node.children.get(i).kind == .VARIABLE_CLUSTER) {
          return true;
        }
      }
    }
    return false;
  }

  void foldConstants(Node node) {
    var kind = node.kind;

    // Fold operands first
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null) {
          foldConstants(child);
        }
      }

      // Test these here since hasChildren() must be true
      if (kind == .BLOCK) {
        foldBlock(node);
        return;
      } else if (kind == .SEQUENCE) {
        foldSequence(node);
        return;
      }
    }

    // Separating the if blocks into separate functions makes the JavaScript JIT go faster
    if (kind == .NAME) foldName(node);
    else if (kind.isCast()) foldCast(node);
    else if (kind.isUnaryOperator()) foldUnaryOperator(node, kind);
    else if (kind.isBinaryOperator()) foldBinaryOperator(node, kind);
    else if (kind == .HOOK) foldHook(node);
  }

  void foldBlock(Node node) {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children.get(i);

      // Remove constants and "while (false) { ... }" entirely
      if (child.kind == .EXPRESSION && child.expressionValue().hasNoSideEffects() ||
          child.kind == .WHILE && child.whileTest().kind == .FALSE) {
        node.removeChildAtIndex(i);
        i--;
      }

      // Reduce for loops that will never execute
      else if (child.kind == .FOR) {
        var test = child.forTest();
        if (test != null && test.kind == .FALSE) {
          var setup = child.forSetup();

          // Remove "for (; false; c) d;" entirely
          if (setup == null || setup.hasNoSideEffects()) {
            node.removeChildAtIndex(i);
            i--;
          }

          // Replace "for (a; false; c) d;" with "a;"
          else if (setup.kind != .VARIABLE_CLUSTER) {
            child.replaceWith(Node.createExpression(setup.remove()));
          }

          // The code "for (var a = 0; false; c) d;" can't be folded
          // completely because that would pollute the enclosing scope
          else {
            var update = child.forUpdate();
            if (update != null) {
              update.replaceWith(null);
            }
            child.forBlock().removeChildren();
          }
        }
      }

      // Statically evaluate if statements where possible
      else if (child.kind == .IF) {
        var test = child.ifTest();
        var testKind = test.kind;
        var trueBlock = child.ifTrue();
        var falseBlock = child.ifFalse();

        // Always true if statement
        if (testKind == .TRUE) {
          // Remove dead code in the "else" block
          if (falseBlock != null) {
            falseBlock.replaceWith(null);
          }

          // Be careful not to pollute the enclosing scope
          if (!blockContainsVariableCluster(trueBlock)) {
            var replacements = trueBlock.removeChildren();
            child.replaceWithNodes(replacements);
            i += replacements.length - 1;
          }
        }

        // Always false if statement
        else if (testKind == .FALSE) {

          // Remove entirely
          if (falseBlock == null) {
            node.removeChildAtIndex(i);
            i--;
          }

          // Be careful not to pollute the enclosing scope
          else if (!blockContainsVariableCluster(falseBlock)) {
            var replacements = falseBlock.removeChildren();
            child.replaceWithNodes(replacements);
            i += replacements.length - 1;
          }

          // Otherwise, transform to an "if (true) { ... }" statement
          else {
            test.replaceWith(Node.createTrue().withType(test.type));
            trueBlock.replaceWith(falseBlock.replaceWith(null));
          }
        }
      }
    }
  }

  void foldName(Node node) {
    if (node.symbol != null && node.symbol.isEnumValue()) {
      flattenInt(node, (int)node.symbol.enumValue);
    }
  }

  void foldCast(Node node) {
    var type = node.castType().type;
    var value = node.castValue();
    var valueKind = value.kind;

    // Cast "bool" values
    if (valueKind.isBool()) {
      if (type.isBool(cache)) flattenBool(node, (bool)value.asBool());
      else if (type.isInteger(cache)) flattenInt(node, (int)value.asBool());
      else if (type.isReal(cache)) flattenReal(node, (double)value.asBool());
    }

    // Cast "int" values
    else if (valueKind == .INT) {
      if (type.isBool(cache)) flattenBool(node, (bool)value.asInt());
      else if (type.isInteger(cache)) flattenInt(node, (int)value.asInt());
      else if (type.isReal(cache)) flattenReal(node, (double)value.asInt());
    }

    // Cast "float" or "double" values
    else if (valueKind.isReal()) {
      if (type.isBool(cache)) flattenBool(node, (bool)value.asDouble());
      else if (type.isInteger(cache)) flattenInt(node, (int)value.asDouble());
      else if (type.isReal(cache)) flattenReal(node, (double)value.asDouble());
    }
  }

  void foldUnaryOperator(Node node, NodeKind kind) {
    var value = node.unaryValue();
    var valueKind = value.kind;

    // Fold "bool" values
    if (valueKind.isBool()) {
      if (kind == .NOT) flattenBool(node, !value.asBool());
    }

    // Fold "int" values
    else if (valueKind == .INT) {
      if (kind == .POSITIVE) flattenInt(node, +value.asInt());
      else if (kind == .NEGATIVE) flattenInt(node, -value.asInt());
      else if (kind == .COMPLEMENT) flattenInt(node, ~value.asInt());
    }

    // Fold "float" or "double" values
    else if (valueKind.isReal()) {
      if (kind == .POSITIVE) flattenReal(node, +value.asDouble());
      else if (kind == .NEGATIVE) flattenReal(node, -value.asDouble());
    }

    // Partial evaluation
    else if (kind == .NOT) {
      switch (valueKind) {
        case .NOT, .EQUAL, .NOT_EQUAL, .LOGICAL_OR, .LOGICAL_AND, .LESS_THAN, .GREATER_THAN, .LESS_THAN_OR_EQUAL, .GREATER_THAN_OR_EQUAL {
          value.invertBooleanCondition(cache);
          node.become(value);
        }
      }
    }
  }

  void foldBinaryOperator(Node node, NodeKind kind) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    var valueKind = left.kind;
    if (valueKind != right.kind && (!left.kind.isBool() || !right.kind.isBool())) {
      return;
    }

    // Fold "bool" values
    if (valueKind.isBool()) {
      switch (kind) {
        case .LOGICAL_AND { flattenBool(node, left.asBool() && right.asBool()); }
        case .LOGICAL_OR { flattenBool(node, left.asBool() || right.asBool()); }
        case .EQUAL { flattenBool(node, left.asBool() == right.asBool()); }
        case .NOT_EQUAL { flattenBool(node, left.asBool() != right.asBool()); }
      }
    }

    // Fold "int" values
    else if (valueKind == .INT) {
      switch (kind) {
        case .ADD { flattenInt(node, left.asInt() + right.asInt()); }
        case .SUBTRACT { flattenInt(node, left.asInt() - right.asInt()); }
        case .MULTIPLY { flattenInt(node, left.asInt() * right.asInt()); }
        case .DIVIDE { flattenInt(node, left.asInt() / right.asInt()); }
        case .REMAINDER { flattenInt(node, left.asInt() % right.asInt()); }
        case .SHIFT_LEFT { flattenInt(node, left.asInt() << right.asInt()); }
        case .SHIFT_RIGHT { flattenInt(node, left.asInt() >> right.asInt()); }
        case .BITWISE_AND { flattenInt(node, left.asInt() & right.asInt()); }
        case .BITWISE_OR { flattenInt(node, left.asInt() | right.asInt()); }
        case .BITWISE_XOR { flattenInt(node, left.asInt() ^ right.asInt()); }
        case .EQUAL { flattenBool(node, left.asInt() == right.asInt()); }
        case .NOT_EQUAL { flattenBool(node, left.asInt() != right.asInt()); }
        case .LESS_THAN { flattenBool(node, left.asInt() < right.asInt()); }
        case .GREATER_THAN { flattenBool(node, left.asInt() > right.asInt()); }
        case .LESS_THAN_OR_EQUAL { flattenBool(node, left.asInt() <= right.asInt()); }
        case .GREATER_THAN_OR_EQUAL { flattenBool(node, left.asInt() >= right.asInt()); }
      }
    }

    // Fold "float" and "double" values
    else if (valueKind.isReal()) {
      switch (kind) {
        case .ADD { flattenReal(node, left.asDouble() + right.asDouble()); }
        case .SUBTRACT { flattenReal(node, left.asDouble() - right.asDouble()); }
        case .MULTIPLY { flattenReal(node, left.asDouble() * right.asDouble()); }
        case .DIVIDE { flattenReal(node, left.asDouble() / right.asDouble()); }
        case .EQUAL { flattenBool(node, left.asDouble() == right.asDouble()); }
        case .NOT_EQUAL { flattenBool(node, left.asDouble() != right.asDouble()); }
        case .LESS_THAN { flattenBool(node, left.asDouble() < right.asDouble()); }
        case .GREATER_THAN { flattenBool(node, left.asDouble() > right.asDouble()); }
        case .LESS_THAN_OR_EQUAL { flattenBool(node, left.asDouble() <= right.asDouble()); }
        case .GREATER_THAN_OR_EQUAL { flattenBool(node, left.asDouble() >= right.asDouble()); }
      }
    }
  }

  void foldHook(Node node) {
    var testKind = node.hookTest().kind;
    if (testKind == .TRUE) {
      node.replaceWith(node.hookTrue().remove());
    } else if (testKind == .FALSE) {
      node.replaceWith(node.hookFalse().remove());
    }
  }

  void foldSequence(Node node) {
    // Remove all children without side effects that aren't the result
    var i = 0;
    while (i + 1 < node.children.length) {
      if (node.children.get(i).hasNoSideEffects()) {
        node.removeChildAtIndex(i);
      } else {
        i++;
      }
    }

    // Replace a single-element sequence with the single element
    if (node.children.length == 1) {
      node.become(node.children.get(0).remove());
    }

    // Otherwise, try to drop the result if it has no side effects
    else {
      var last = node.children.get(i);
      if (last.hasNoSideEffects() && node.parent.kind == .EXPRESSION) {
        last.remove();
      }
    }
  }
}
