class ConstantFolder {
  TypeCache cache;

  void flattenBool(Node node, bool value) {
    assert node.type.isError(cache) || node.type.isBool(cache);
    node.removeChildren();
    node.kind = value ? NodeKind.TRUE : NodeKind.FALSE;
    node.content = null;
  }

  void flattenInt(Node node, int value) {
    assert node.type.isError(cache) || node.type.isInteger(cache);
    node.removeChildren();
    node.kind = NodeKind.INT;
    node.content = new IntContent(value);
  }

  void flattenReal(Node node, double value) {
    assert node.type.isError(cache) || node.type.isReal(cache);
    node.removeChildren();
    node.kind = node.type == cache.floatType ? NodeKind.FLOAT : NodeKind.DOUBLE;
    node.content = new DoubleContent(value);
  }

  void foldConstants(Node node) {
    NodeKind kind = node.kind;

    // Fold operands first
    if (node.hasChildren()) {
      int i;
      for (i = 0; i < node.children.length; i++) {
        Node child = node.children.get(i);
        if (child != null) foldConstants(child);
      }
    }

    // Symbols
    if (kind == NodeKind.NAME) {
      if (node.symbol != null && node.symbol.isEnumValue()) {
        flattenInt(node, (int)node.symbol.enumValue);
      }
    }

    // Casts
    else if (kind.isCast()) {
      Type type = node.castType().type;
      Node value = node.castValue();
      NodeKind valueKind = value.kind;

      // Cast "bool" values
      if (valueKind.isBool()) {
        if (type.isBool(cache)) flattenBool(node, (bool)value.asBool());
        else if (type.isInteger(cache)) flattenInt(node, (int)value.asBool());
        else if (type.isReal(cache)) flattenReal(node, (double)value.asBool());
      }

      // Cast "int" values
      else if (valueKind == NodeKind.INT) {
        if (type.isBool(cache)) flattenBool(node, (bool)value.asInt());
        else if (type.isInteger(cache)) flattenInt(node, (int)value.asInt());
        else if (type.isReal(cache)) flattenReal(node, (double)value.asInt());
      }

      // Cast "float" or "double" values
      else if (valueKind.isReal()) {
        if (type.isBool(cache)) flattenBool(node, (bool)value.asDouble());
        else if (type.isInteger(cache)) flattenInt(node, (int)value.asDouble());
        else if (type.isReal(cache)) flattenReal(node, (double)value.asDouble());
      }
    }

    // Unary operators
    else if (kind.isUnaryOperator()) {
      Node value = node.unaryValue();
      NodeKind valueKind = value.kind;

      // Fold "bool" values
      if (valueKind.isBool()) {
        if (kind == NodeKind.NOT) flattenBool(node, !value.asBool());
      }

      // Fold "int" values
      else if (valueKind == NodeKind.INT) {
        if (kind == NodeKind.POSITIVE) flattenInt(node, +value.asInt());
        else if (kind == NodeKind.NEGATIVE) flattenInt(node, -value.asInt());
        else if (kind == NodeKind.COMPLEMENT) flattenInt(node, ~value.asInt());
      }

      // Fold "float" or "double" values
      else if (valueKind.isReal()) {
        if (kind == NodeKind.POSITIVE) flattenReal(node, +value.asDouble());
        else if (kind == NodeKind.NEGATIVE) flattenReal(node, -value.asDouble());
      }
    }

    // Binary operators
    else if (kind.isBinaryOperator()) {
      Node left = node.binaryLeft();
      Node right = node.binaryRight();
      NodeKind valueKind = left.kind;
      if (valueKind != right.kind) return;

      // Fold "bool" values
      if (valueKind.isBool()) {
        switch (kind) {
          case NodeKind.LOGICAL_AND { flattenBool(node, left.asBool() && right.asBool()); }
          case NodeKind.LOGICAL_OR { flattenBool(node, left.asBool() || right.asBool()); }
          case NodeKind.EQUAL { flattenBool(node, left.asBool() == right.asBool()); }
          case NodeKind.NOT_EQUAL { flattenBool(node, left.asBool() != right.asBool()); }
        }
      }

      // Fold "int" values
      else if (valueKind == NodeKind.INT) {
        switch (kind) {
          case NodeKind.ADD { flattenInt(node, left.asInt() + right.asInt()); }
          case NodeKind.SUBTRACT { flattenInt(node, left.asInt() - right.asInt()); }
          case NodeKind.MULTIPLY { flattenInt(node, left.asInt() * right.asInt()); }
          case NodeKind.DIVIDE { flattenInt(node, left.asInt() / right.asInt()); }
          case NodeKind.REMAINDER { flattenInt(node, left.asInt() % right.asInt()); }
          case NodeKind.SHIFT_LEFT { flattenInt(node, left.asInt() << right.asInt()); }
          case NodeKind.SHIFT_RIGHT { flattenInt(node, left.asInt() >> right.asInt()); }
          case NodeKind.BITWISE_AND { flattenInt(node, left.asInt() & right.asInt()); }
          case NodeKind.BITWISE_OR { flattenInt(node, left.asInt() | right.asInt()); }
          case NodeKind.BITWISE_XOR { flattenInt(node, left.asInt() ^ right.asInt()); }
          case NodeKind.EQUAL { flattenBool(node, left.asInt() == right.asInt()); }
          case NodeKind.NOT_EQUAL { flattenBool(node, left.asInt() != right.asInt()); }
          case NodeKind.LESS_THAN { flattenBool(node, left.asInt() < right.asInt()); }
          case NodeKind.GREATER_THAN { flattenBool(node, left.asInt() > right.asInt()); }
          case NodeKind.LESS_THAN_OR_EQUAL { flattenBool(node, left.asInt() <= right.asInt()); }
          case NodeKind.GREATER_THAN_OR_EQUAL { flattenBool(node, left.asInt() >= right.asInt()); }
        }
      }

      // Fold "float" and "double" values
      else if (valueKind.isReal()) {
        switch (kind) {
          case NodeKind.ADD { flattenReal(node, left.asDouble() + right.asDouble()); }
          case NodeKind.SUBTRACT { flattenReal(node, left.asDouble() - right.asDouble()); }
          case NodeKind.MULTIPLY { flattenReal(node, left.asDouble() * right.asDouble()); }
          case NodeKind.DIVIDE { flattenReal(node, left.asDouble() / right.asDouble()); }
          case NodeKind.EQUAL { flattenBool(node, left.asDouble() == right.asDouble()); }
          case NodeKind.NOT_EQUAL { flattenBool(node, left.asDouble() != right.asDouble()); }
          case NodeKind.LESS_THAN { flattenBool(node, left.asDouble() < right.asDouble()); }
          case NodeKind.GREATER_THAN { flattenBool(node, left.asDouble() > right.asDouble()); }
          case NodeKind.LESS_THAN_OR_EQUAL { flattenBool(node, left.asDouble() <= right.asDouble()); }
          case NodeKind.GREATER_THAN_OR_EQUAL { flattenBool(node, left.asDouble() >= right.asDouble()); }
        }
      }
    }
  }
}
