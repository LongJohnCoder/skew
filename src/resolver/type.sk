class Type {
  Symbol symbol;
  StringMap<Symbol> members = new StringMap<Symbol>();

  // This contains types used in the definition of this type. Classes derive
  // from at most one base class and implement any number of interfaces.
  // Interfaces can extend any number of other interfaces. Structs are just
  // named tuples and cannot derive from or implement any other types.
  // Functions have one relevant type per argument variable followed by one
  // return type for non-constructor functions. Type parameters may have one
  // type bound.
  List<Type> relevantTypes = null;

  // All type parameters for this type, used for generics
  List<Type> parameters = null;

  void addMember(Symbol member) {
    member.enclosingSymbol = symbol;
    members.set(member.name, member);
  }

  Symbol findMember(string name) {
    return members.getOrDefault(name, null);
  }

  string toString() {
    Symbol enclosingSymbol = symbol.enclosingSymbol;
    return (enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace() ? enclosingSymbol.type.toString().append(".") : "").append(symbol.name);
  }

  bool isVoid(TypeCache cache) {
    return this == cache.voidType;
  }

  bool isInt(TypeCache cache) {
    return this == cache.intType;
  }

  bool isNull(TypeCache cache) {
    return this == cache.nullType;
  }

  bool isBool(TypeCache cache) {
    return this == cache.boolType;
  }

  bool isFloat(TypeCache cache) {
    return this == cache.floatType;
  }

  bool isDouble(TypeCache cache) {
    return this == cache.doubleType;
  }

  bool isString(TypeCache cache) {
    return this == cache.stringType;
  }

  bool isError(TypeCache cache) {
    return this == cache.errorType;
  }

  bool isCyclic(TypeCache cache) {
    return this == cache.cyclicType;
  }

  bool isNamespace() {
    return symbol.kind.isNamespace();
  }

  bool isEnum() {
    return symbol.kind.isEnum();
  }

  bool isObject() {
    return symbol.kind.isObject();
  }

  bool isClass() {
    return symbol.kind == SymbolKind.CLASS;
  }

  bool isStruct() {
    return symbol.kind == SymbolKind.STRUCT;
  }

  bool isInterface() {
    return symbol.kind == SymbolKind.INTERFACE;
  }

  bool isReference() {
    return isClass() || isInterface();
  }

  bool isInteger(TypeCache cache) {
    return isInt(cache) || isEnum();
  }

  bool isReal(TypeCache cache) {
    return isFloat(cache) || isDouble(cache);
  }

  bool isNumeric(TypeCache cache) {
    return isInteger(cache) || isReal(cache);
  }
}
