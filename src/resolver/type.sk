class Type {
  StringMap<Member> members = new StringMap<Member>();
  Environment environment = null;

  // The symbol that declared this type, if any. Function types don't have a
  // declaring symbol, so this will be null for function types.
  Symbol symbol;

  // This contains types used in the definition of this type. Classes derive
  // from at most one base class and implement any number of interfaces.
  // Interfaces can extend any number of other interfaces. Structs are just
  // named tuples and cannot derive from or implement any other types.
  // Functions have one return type followed by a relevant type for each
  // argument variable. Type parameters are either unbounded or have a single
  // type bound.
  List<Type> relevantTypes = null;

  // Give each type a unique integer as a hash code
  static int nextUniqueID = 0;
  int uniqueID = nextUniqueID++;

  Member constructor() {
    if (symbol == null) return null;
    return members.getOrDefault("new", null);
  }

  bool hasBaseType(Type type) {
    if (isParameter()) {
      Type upper = bound();
      return upper != null && upper.hasBaseType(type);
    }
    if (!isClass() && !isInterface()) {
      return false;
    }
    if (this == type) {
      return true;
    }
    if (relevantTypes != null) {
      int i;
      for (i = 0; i < relevantTypes.length; i++) {
        if (relevantTypes.get(i).hasBaseType(type)) {
          return true;
        }
      }
    }
    return false;
  }

  void addMember(Member member) {
    member.enclosingType = this;
    members.set(member.symbol.name, member);
  }

  void copyMembersFrom(Type other) {
    List<Member> otherMembers = other.members.values();
    int i;
    for (i = 0; i < otherMembers.length; i++) {
      Member member = otherMembers.get(i);
      if (!members.has(member.symbol.name)) {
        members.set(member.symbol.name, member);
      }
    }
  }

  Member findMember(string name) {
    return members.getOrDefault(name, null);
  }

  string toString() {
    // Special-case functions
    if (isFunction()) {
      string text = resultType().toString().append(" fn(");
      List<Type> arguments = argumentTypes();
      int i;
      for (i = 0; i < arguments.length; i++) {
        if (i > 0) text = text.append(", ");
        text = text.append(arguments.get(i).toString());
      }
      return text.append(")");
    }

    // Special-case generic types
    if (hasParameters()) {
      List<string> parts = {};
      int i;
      for (i = 0; i < symbol.parameters.length; i++) {
        Symbol parameter = symbol.parameters.get(i);
        if (environment != null) {
          int index = environment.parameters.indexOf(parameter);
          if (index != -1) {
            parts.push(environment.types.get(index).toString());
            continue;
          }
        }
        parts.push(parameter.name);
      }
      return symbol.fullName().append("<").append(", ".join(parts)).append(">");
    }

    return symbol.fullName();
  }

  bool hasParameters() {
    return symbol != null && symbol.hasParameters();
  }

  bool isParameterized() {
    return environment != null;
  }

  bool hasRelevantTypes() {
    return relevantTypes != null && relevantTypes.length > 0;
  }

  Type baseClass() {
    assert isClass();
    return hasRelevantTypes() ? relevantTypes.get(0) : null;
  }

  Type bound() {
    assert isParameter();
    return hasRelevantTypes() ? relevantTypes.get(0) : null;
  }

  bool dependsOnParameter(Symbol parameter) {
    if (hasRelevantTypes()) {
      int i;
      for (i = 0; i < relevantTypes.length; i++) {
        Type type = relevantTypes.get(i);
        if (type.symbol == parameter || type.dependsOnParameter(parameter)) {
          return true;
        }
      }
    }
    return false;
  }

  Type resultType() {
    assert isFunction();
    assert hasRelevantTypes();
    return relevantTypes.get(0);
  }

  List<Type> argumentTypes() {
    assert isFunction();
    assert hasRelevantTypes();
    return relevantTypes.slice(1, relevantTypes.length);
  }

  bool isVoid(TypeCache cache) {
    return this == cache.voidType;
  }

  bool isInt(TypeCache cache) {
    return this == cache.intType;
  }

  bool isNull(TypeCache cache) {
    return this == cache.nullType;
  }

  bool isBool(TypeCache cache) {
    return this == cache.boolType;
  }

  bool isFloat(TypeCache cache) {
    return this == cache.floatType;
  }

  bool isDouble(TypeCache cache) {
    return this == cache.doubleType;
  }

  bool isString(TypeCache cache) {
    return this == cache.stringType;
  }

  bool isError(TypeCache cache) {
    return this == cache.errorType;
  }

  bool isFunction() {
    return symbol == null;
  }

  bool isNamespace() {
    return symbol != null && symbol.kind.isNamespace();
  }

  bool isEnum() {
    return symbol != null && symbol.kind.isEnum();
  }

  bool isEnumFlags() {
    return symbol != null && symbol.kind == SymbolKind.ENUM_FLAGS;
  }

  bool isParameter() {
    return symbol != null && symbol.kind == SymbolKind.PARAMETER;
  }

  bool isObject() {
    return symbol != null && symbol.kind.isObject();
  }

  bool isClass() {
    return symbol != null && symbol.kind == SymbolKind.CLASS;
  }

  bool isStruct() {
    return symbol != null && symbol.kind == SymbolKind.STRUCT;
  }

  bool isInterface() {
    return symbol != null && symbol.kind == SymbolKind.INTERFACE;
  }

  bool isReference() {
    return isClass() || isInterface() || isFunction();
  }

  bool isInteger(TypeCache cache) {
    return isInt(cache) || isEnum();
  }

  bool isReal(TypeCache cache) {
    return isFloat(cache) || isDouble(cache);
  }

  bool isNumeric(TypeCache cache) {
    return isInteger(cache) || isReal(cache);
  }
}
