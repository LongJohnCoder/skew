class Type {
  final var members = StringMap<Member>();

  // The symbol that declared this type, if any. Non-generic function types
  // don't have a declaring symbol, so this will be null for those types.
  Symbol symbol;

  // This contains types used in the definition of this type. Classes derive
  // from at most one base class and implement any number of interfaces.
  // Interfaces can extend any number of other interfaces. Structs are just
  // named tuples and cannot derive from or implement any other types.
  // Functions have one return type followed by a relevant type for each
  // argument variable. Type parameters are either unbounded or have a single
  // type bound.
  List<Type> relevantTypes = null;

  // Types that have been substituted for the type parameters of this symbol.
  // If non-null, the length must equal symbol.parameters.size().
  List<Type> substitutions = null;

  // Give each type a unique integer as a hash code
  static var nextUniqueID = -1;
  var uniqueID = generateUniqueID();

  static int generateUniqueID() {
    nextUniqueID++;
    return nextUniqueID;
  }

  // Enforce a consistent symbol iteration order
  List<Member> sortedMembers() {
    var result = members.values();
    result.sort(MemberComparison.INSTANCE);
    return result;
  }

  Member constructor() {
    if (symbol == null) return null;
    return members.getOrDefault("new", null);
  }

  bool hasBaseType(Type type) {
    if (isParameter()) {
      var upper = bound();
      return upper != null && upper.hasBaseType(type);
    }
    if (!isClass() && !isInterface()) {
      return false;
    }
    if (this == type) {
      return true;
    }
    if (relevantTypes != null) {
      for (var i = 0; i < relevantTypes.size(); i++) {
        if (relevantTypes.get(i).hasBaseType(type)) {
          return true;
        }
      }
    }
    return false;
  }

  void addMember(Member member) {
    members.set(member.symbol.name, member);
  }

  void copyMembersFrom(Type other) {
    var otherMembers = other.members.values();
    for (var i = 0; i < otherMembers.size(); i++) {
      var member = otherMembers.get(i);
      if (!members.has(member.symbol.name)) {
        members.set(member.symbol.name, member);
      }
    }
  }

  Member findMember(string name) {
    return members.getOrDefault(name, null);
  }

  static string environmentToString(List<Symbol> parameters, List<Type> substitutions) {
    assert parameters.size() == substitutions.size();
    var text = "[";
    for (var i = 0; i < parameters.size(); i++) {
      if (i > 0) text += ", ";
      text += parameters.get(i).name + " => " + substitutions.get(i);
    }
    return text + "]";
  }

  string toString() {
    assert substitutions == null || substitutions.size() == symbol.parameters.size();

    // Special-case generic types
    var parameterText = "";
    if (hasParameters()) {
      parameterText = "<";
      for (var i = 0; i < symbol.parameters.size(); i++) {
        if (i > 0) parameterText += ", ";
        parameterText += isParameterized() ? substitutions.get(i).toString() : symbol.parameters.get(i).name;
      }
      parameterText += ">";
    }

    // Special-case functions
    if (isFunction()) {
      var text = resultType() + " fn" + parameterText + "(";
      var arguments = argumentTypes();
      for (var i = 0; i < arguments.size(); i++) {
        if (i > 0) text += ", ";
        text += arguments.get(i);
      }
      return text + ")";
    }

    return symbol.fullName() + parameterText;
  }

  bool hasParameters() {
    return symbol != null && symbol.hasParameters();
  }

  bool isParameterized() {
    return substitutions != null;
  }

  bool hasRelevantTypes() {
    return relevantTypes != null && relevantTypes.size() > 0;
  }

  Type baseClass() {
    assert isClass();
    if (!hasRelevantTypes()) return null;
    var first = relevantTypes.get(0);
    return first.isClass() ? first : null;
  }

  Type bound() {
    assert isParameter();
    return hasRelevantTypes() ? relevantTypes.get(0) : null;
  }

  bool dependsOnParameter(Symbol parameter) {
    if (symbol == parameter ||
        hasParameters() && symbol.parameters.indexOf(parameter) >= 0 ||
        isParameterized() && substitutions.indexOf(parameter.type) >= 0) {
      return true;
    }
    if (hasRelevantTypes()) {
      for (var i = 0; i < relevantTypes.size(); i++) {
        var type = relevantTypes.get(i);
        if (type.dependsOnParameter(parameter)) {
          return true;
        }
      }
    }
    return false;
  }

  Type resultType() {
    assert isFunction();
    assert hasRelevantTypes();
    return relevantTypes.get(0);
  }

  List<Type> argumentTypes() {
    assert isFunction();
    assert hasRelevantTypes();
    return relevantTypes.slice(1, relevantTypes.size());
  }

  bool isVoid(TypeCache cache) {
    return this == cache.voidType;
  }

  bool isInt(TypeCache cache) {
    return this == cache.intType;
  }

  bool isNull(TypeCache cache) {
    return this == cache.nullType;
  }

  bool isBool(TypeCache cache) {
    return this == cache.boolType;
  }

  bool isFloat(TypeCache cache) {
    return this == cache.floatType;
  }

  bool isDouble(TypeCache cache) {
    return this == cache.doubleType;
  }

  bool isString(TypeCache cache) {
    return this == cache.stringType;
  }

  bool isPrimitive() {
    return symbol != null && symbol.isPrimitive();
  }

  bool isList(TypeCache cache) {
    return symbol == cache.listType.symbol;
  }

  bool isError(TypeCache cache) {
    return this == cache.errorType;
  }

  bool isFunction() {
    // Generic function types have a symbol but non-generic function types don't
    return symbol == null || symbol.kind.isFunction();
  }

  bool isNamespace() {
    return symbol != null && symbol.kind.isNamespace();
  }

  bool isEnum() {
    return symbol != null && symbol.kind.isEnum();
  }

  bool isRegularEnum() {
    return symbol != null && symbol.kind == .ENUM;
  }

  bool isEnumFlags() {
    return symbol != null && symbol.kind == .ENUM_FLAGS;
  }

  bool isParameter() {
    return symbol != null && symbol.kind.isParameter();
  }

  bool isObject() {
    return symbol != null && symbol.kind.isObject();
  }

  bool isClass() {
    return symbol != null && symbol.kind == .CLASS;
  }

  bool isInterface() {
    return symbol != null && symbol.kind == .INTERFACE;
  }

  bool isReference() {
    if (isClass()) return !isPrimitive();
    return isInterface() || isFunction() || isParameter() && bound() != null;
  }

  bool isInteger(TypeCache cache) {
    return isInt(cache) || isEnum();
  }

  bool isReal(TypeCache cache) {
    return isFloat(cache) || isDouble(cache);
  }

  bool isNumeric(TypeCache cache) {
    return isInteger(cache) || isReal(cache);
  }
}
