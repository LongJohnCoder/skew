namespace InstanceToStaticPass {
  void run(CallGraph graph, Resolver resolver) {
    for (var i = 0; i < graph.callInfo.size(); i++) {
      var info = graph.callInfo.get(i);
      var symbol = info.symbol;
      var enclosingSymbol = symbol.enclosingSymbol;
      if (symbol.kind == .INSTANCE_FUNCTION && !symbol.isImport() && symbol.node.functionBlock() != null && (
          enclosingSymbol.isImport() || enclosingSymbol.kind.isEnum() ||
          (resolver.options.convertAllInstanceToStatic || symbol.isInline()) && !symbol.isExport() && !symbol.isVirtual())) {

        // Recursively replace "this" with the new explicit argument. This must
        // be done after all call sites are updated in case that step introduced
        // more "this" expressions.
        var thisSymbol = resolver.createSymbol("this", .LOCAL_VARIABLE);
        thisSymbol.type = enclosingSymbol.type;

        // Make sure to handle types with type parameters
        if (enclosingSymbol.hasParameters()) {

          // This method may also have type parameters itself
          if (symbol.parameters == null) {
            symbol.parameters = [];
          }

          // Add any type parameters from the enclosing type to the end of
          // the type parameter list for this function (this function may
          // also have type parameters of its own)
          for (var i = 0; i < enclosingSymbol.parameters.size(); i++) {
            var parameter = enclosingSymbol.parameters.get(i);
            var clone = resolver.createSymbol(parameter.name, .FUNCTION_PARAMETER);
            clone.type = Type(clone);
            symbol.parameters.push(clone);
          }
        }

        thisSymbol.type = resolver.cache.ensureTypeIsParameterized(thisSymbol.type);
        recursivelyReplaceThis(symbol.node.functionBlock(), thisSymbol);

        // Change the instance function to a static function
        symbol.kind = .GLOBAL_FUNCTION;
        symbol.flags |= .STATIC;

        // Add an argument for "this"
        var arguments = symbol.type.argumentTypes();
        arguments.unshift(thisSymbol.type);
        resolver.createFunctionType(symbol, symbol.type.resultType(), arguments);
        thisSymbol.node = Node.createVariable(createThis(thisSymbol), Node.createType(thisSymbol.type), null).withSymbol(thisSymbol);
        symbol.node.functionArguments().insertChild(0, thisSymbol.node);

        // Update all call sites
        for (var j = 0; j < info.callSites.size(); j++) {
          var callSite = info.callSites.get(j);
          var value = callSite.callValue();
          Node target;
          Node name;
          if (value.kind == .DOT) {
            target = value.dotTarget().replaceWith(null);
            name = value.dotName().replaceWith(null);
          } else {
            assert value.kind == .NAME;
            target = Node.createThis().withType(thisSymbol.type);
            name = value.replaceWith(null);
          }

          // Make sure to parameterize the new symbol type
          var targetSubstitutions = target.type != null ? target.type.substitutions : null;
          var nameSubstitutions = name.type != null ? name.type.substitutions : null;
          if (targetSubstitutions != null || nameSubstitutions != null) {
            List<Type> types = [];

            // This function's original type parameters, if any, come first
            if (nameSubstitutions != null) {
              for (var i = 0; i < nameSubstitutions.size(); i++) {
                types.push(nameSubstitutions.get(i));
              }
            }

            // The enclosing symbol's type parameters have just been added after
            if (targetSubstitutions != null) {
              for (var i = 0; i < targetSubstitutions.size(); i++) {
                types.push(targetSubstitutions.get(i));
              }
            }

            name.type = resolver.cache.parameterize(symbol.type, types);
          } else {
            name.type = symbol.type;
          }

          // Inject the argument for "this" at the call site
          callSite.replaceChild(0, name);
          callSite.insertChild(1, target);
        }
      }
    }
  }

  Node createThis(Symbol symbol) {
    return Node.createName(symbol.name).withSymbol(symbol).withType(symbol.type);
  }

  void recursivelyReplaceThis(Node node, Symbol symbol) {
    if (node.kind == .THIS) {
      node.become(createThis(symbol).withRange(node.range));
    }

    else if (node.isNameExpression() && node.symbol != null && (node.symbol.kind == .INSTANCE_FUNCTION || node.symbol.kind == .INSTANCE_VARIABLE)) {
      node.become(Node.createDot(createThis(symbol), node.clone()).withType(node.type).withRange(node.range).withSymbol(node.symbol));
    }

    else if (node.hasChildren()) {
      for (var i = 0; i < node.children.size(); i++) {
        var child = node.children.get(i);
        if (child != null) {
          recursivelyReplaceThis(child, symbol);
        }
      }
    }
  }
}
