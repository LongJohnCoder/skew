class InstanceToStaticPass {
  static void run(Node program, CompilerOptions options) {
    var graph = CallGraph(program);
    for (var i = 0; i < graph.callInfo.length; i++) {
      var info = graph.callInfo.get(i);
      var symbol = info.symbol;
      var enclosingSymbol = symbol.enclosingSymbol;
      if (symbol.kind == .INSTANCE_FUNCTION && !symbol.isImportOrExport() && symbol.node.functionBlock() != null && (
          enclosingSymbol.isImport() || enclosingSymbol.kind.isEnum() || options.optimize && options.targetFormat == .JS && !symbol.isVirtual())) {

        // Change the instance function to a static function
        symbol.kind = .GLOBAL_FUNCTION;
        symbol.flags = symbol.flags | SymbolFlag.STATIC;
        var thisSymbol = Symbol("this", .LOCAL_VARIABLE);
        thisSymbol.type = enclosingSymbol.type;
        symbol.node.functionArguments().insertChild(0, Node.createVariable(Node.createName("this").withSymbol(thisSymbol), Node.createType(thisSymbol.type), null).withSymbol(thisSymbol));

        // Update all call sites
        for (var j = 0; j < info.callSites.length; j++) {
          var callSite = info.callSites.get(j);
          switch (callSite.kind) {
            case .CALL {
              var value = callSite.callValue();
              Node target;
              Node name;
              if (value.kind == .DOT) {
                target = value.dotTarget().remove();
                name = value.dotName().remove();
              } else {
                assert value.kind == .NAME;
                target = Node.createThis();
                name = value.remove();
              }
              callSite.replaceChild(0, name);
              callSite.insertChild(1, target);
            }

            case .BIND {
              assert false; // TODO
            }

            default {
              assert false;
            }
          }
        }

        // Recursively replace "this" with the new explicit argument. This must
        // be done after all call sites are updated in case that step introduced
        // more "this" expressions.
        recursivelyReplaceThis(symbol.node.functionBlock(), thisSymbol);
      }
    }
  }

  static Node createThis(Symbol symbol) {
    return Node.createName(symbol.name).withSymbol(symbol).withType(symbol.type);
  }

  static void recursivelyReplaceThis(Node node, Symbol symbol) {
    if (node.kind == .THIS) {
      node.become(createThis(symbol).withRange(node.range));
    }

    else if (node.isNameExpression() && (node.symbol.kind == .INSTANCE_FUNCTION || node.symbol.kind == .INSTANCE_VARIABLE)) {
      node.become(Node.createDot(createThis(symbol), node.clone()).withType(node.type).withRange(node.range));
    }

    else if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null) {
          recursivelyReplaceThis(child, symbol);
        }
      }
    }
  }
}
