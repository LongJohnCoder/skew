enum MatchKind {
  NONE,
  INEXACT,
  EXACT,
}

enum CastKind {
  IMPLICIT_CAST,
  EXPLICIT_CAST,
}

enum AllowDeclaration {
  ALLOW_TOP_LEVEL,
  ALLOW_TOP_OR_OBJECT_LEVEL,
}

class ResolveContext {
  Scope scope = null;

  // Keep track of the nearest enclosing node for certain node types
  Node loop = null;
  Node switchValue = null;
  Symbol symbolForThis = null;
  Symbol functionSymbol = null;

  static ResolveContext fromNode(Node node) {
    var context = ResolveContext();
    if (node.parent == null && node.symbol.enclosingSymbol != null) {
      assert node.symbol.enclosingSymbol.kind.isTypeWithInstances();
      context.symbolForThis = node.symbol.enclosingSymbol;
      context.scope = context.symbolForThis.node.scope;
      assert context.scope != null;
    }
    while (node != null) {
      if (context.scope == null) context.scope = node.scope;
      if (context.loop == null && node.kind.isLoop()) context.loop = node;
      if (context.switchValue == null && node.kind == .SWITCH) context.switchValue = node.switchValue();
      if (context.symbolForThis == null && node.symbol != null && node.symbol.kind.isTypeWithInstances()) context.symbolForThis = node.symbol;
      if (context.functionSymbol == null && node.kind.isFunction()) context.functionSymbol = node.symbol;
      node = node.parent;
    }
    return context;
  }
}

class MemberRangeComparison : Comparison<Member> {
  override int compare(Member left, Member right) {
    return left.symbol.node.range.start - right.symbol.node.range.start;
  }
}

class Resolver {
  static var comparison = MemberRangeComparison();
  var context = ResolveContext();
  ConstantFolder constantFolder = null;
  List<Node> parsedDeclarations = null;
  List<Node> parsedBlocks = null;
  Type typeContext = null;
  Type resultType = null;
  Symbol entryPointSymbol = null;
  final List<Symbol> allSymbols = [];
  final var cache = TypeCache();
  final Log log;
  final CompilerOptions options;

  void run(Node program) {
    assert program.kind == .PROGRAM;
    var globalScope = Scope(null);
    cache.insertGlobals(globalScope);
    constantFolder = ConstantFolder(cache);
    prepareNode(program, globalScope);
    cache.linkGlobals(globalScope);
    resolve(program, null);
  }

  void prepareNode(Node node, Scope scope) {
    parsedDeclarations = [];
    parsedBlocks = [];
    setupScopesAndSymbols(node, scope);
    accumulateSymbolFlags();
    setSymbolKindsAndMergeSiblings();
    processUsingStatements();
  }

  Scope setupBlock(Node node, Scope scope) {
    // Just use the existing scope from named block declarations
    if (!node.parent.kind.isNamedBlockDeclaration() && !node.parent.kind.isLoop()) {
      scope = Scope(scope);
    }
    node.scope = scope;
    parsedBlocks.push(node);

    // Declarations at the file level go in the global scope
    if (node.parent.kind == .FILE) {
      scope.type = cache.globalType;
    }

    // Declarations in a block declaration go in that block's type
    else {
      var parentSymbol = node.parent.symbol;
      if (parentSymbol != null && parentSymbol.type != null) {
        scope.type = parentSymbol.type;
      }
    }

    return scope;
  }

  void setupNamedDeclaration(Node node, Scope scope) {
    var declarationName = node.declarationName();
    if (declarationName != null && node.symbol == null) {
      var name = declarationName.asString();
      var member = scope.findLocal(name);
      Symbol symbol;

      // Append this symbol the linked list of sibling nodes
      if (member != null) {
        symbol = member.symbol;

        // The symbol for "void" has no corresponding node
        if (symbol.node != null) {
          symbol.node.appendToSiblingChain(node);
        }
      }

      // Make a symbol
      else {
        symbol = createSymbol(name, .OTHER);
        symbol.node = node;
        if (scope.type != null) {
          symbol.enclosingSymbol = scope.type.symbol;
        }
        member = Member(symbol);
        scope.insert(member);
      }

      // Link the node with its symbol
      parsedDeclarations.push(node);
      declarationName.symbol = symbol;
      node.symbol = symbol;

      // Create a type for block declarations so that declarations inside the
      // block can be linked as siblings with declarations inside other adjacent
      // block declarations:
      //
      //   // Both "Bar" declarations are siblings linked through the type "Foo"
      //   namespace Foo { in Bar {} }
      //   namespace Foo { class Bar {} }
      //
      if (symbol.type == null && node.kind.isNamedBlockDeclaration()) {
        symbol.type = Type(symbol);
      }
    }
  }

  void setupScopesAndSymbols(Node node, Scope scope) {
    // The root program introduces the global scope
    if (node.kind == .PROGRAM) {
      node.scope = scope;
    }

    // Remember each scope on the node that introduced that scope
    else if (node.kind == .BLOCK) {
      scope = setupBlock(node, scope); // Outlined for JIT performance
    }

    // Declare this node if needed
    if (node.kind.isNamedDeclaration()) {
      setupNamedDeclaration(node, scope); // Outlined for JIT performance
    }

    // Also introduce a scope on object declarations for the type parameters
    // and on function declarations for the arguments
    if (node.kind.isNamedBlockDeclaration() || node.kind.isFunction() || node.kind.isLoop()) {
      scope = Scope(scope);
      node.scope = scope;
    }

    // Automatically traverse the children of all nodes. There can't be any
    // statements inside expressions since we currently don't have lambda
    // expressions.
    if (node.hasChildren() && !node.kind.isExpression()) {
      for (var i = 0; i < node.children.size(); i++) {
        var child = node.children[i];
        if (child != null) setupScopesAndSymbols(child, scope);
      }
    }
  }

  SymbolFlag symbolFlagsForNode(Node node) {
    SymbolFlag flags = 0;
    var parent = node.parent;

    // Make sure modifiers are detected for variables inside a variable cluster
    if (parent.kind == .VARIABLE_CLUSTER) {
      parent = parent.parent;
    }

    // Keep accumulating modifiers that are immediately nested inside each other
    while (parent != null && parent.kind == .MODIFIER) {
      var modifierName = parent.modifierName();
      var name = modifierName.asString();
      if (node.kind == .EXTENSION) {
        semanticErrorUnexpectedModifier(log, modifierName.range, name, "on an extension block");
      } else {
        var flag = nameToSymbolFlag.getOrDefault(name, 0);
        if (flag == 0) {
          flag = .HAS_ANNOTATIONS;
        } else if ((flags & flag) != 0) {
          semanticWarningDuplicateModifier(log, modifierName.range, name);
        }
        flags |= flag;
      }
      parent = parent.parent;
    }

    // Mark nodes directly inside extension blocks for easy checking later
    if (parent != null && parent.kind == .BLOCK && parent.parent.kind == .EXTENSION) {
      flags |= .FROM_EXTENSION;
    }

    return flags;
  }

  void accumulateSymbolFlags() {
    for (var i = 0; i < parsedDeclarations.size(); i++) {
      var node = parsedDeclarations[i];
      node.symbol.flags |= symbolFlagsForNode(node);
    }
  }

  bool checkParentsForLocalVariable(Node node) {
    for (node = node.parent; node != null; node = node.parent) {
      if (node.kind.isFunction()) {
        return true;
      }
    }
    return false;
  }

  void setSymbolKindsAndMergeSiblings() {
    for (var i = 0; i < parsedDeclarations.size(); i++) {
      var node = parsedDeclarations[i];
      var symbol = node.symbol;

      // Skip all node in a sibling chain other than the first node
      if (symbol.node != node) {
        continue;
      }

      // The declaration name isn't null here because symbol != null
      var declarationName = node.declarationName();
      var kind = node.kind;

      for (var sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        // Extensions off of block declarations are fine
        if (sibling.kind == .EXTENSION && kind.isNamedBlockDeclaration()) {
          continue;
        }

        // Merge block declarations with extension blocks
        if (sibling.kind != .EXTENSION && sibling.kind.isNamedBlockDeclaration()) {
          if (kind == .EXTENSION || kind == .NAMESPACE && sibling.kind == .NAMESPACE) {
            kind = sibling.kind;
            continue;
          }
        }

        // Disallow all other merges
        Node siblingName = sibling.declarationName();
        semanticErrorDuplicateSymbol(log, siblingName.range, siblingName.asString(), declarationName.range);
      }

      // Disconnect all sibling variable and function declarations. All errors
      // about duplicate symbols should have already been logged by now. New
      // symbols are created for each node but are not inserted into the scope
      // so that the contents of the duplicate nodes can still be type-checked.
      var previous = node;
      for (var sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        if (sibling.kind == .VARIABLE || sibling.kind.isFunction()) {
          Symbol disconnected = createSymbol(symbol.name, .OTHER);
          sibling.symbol = disconnected;
          disconnected.enclosingSymbol = symbol.enclosingSymbol;
          disconnected.node = sibling;
          previous.sibling = sibling.sibling;
        } else {
          previous = sibling;
        }
      }

      // Set the symbol kind
      switch (kind) {
        case .NAMESPACE { symbol.kind = .NAMESPACE; }
        case .ENUM { symbol.kind = .ENUM; }
        case .ENUM_FLAGS { symbol.kind = .ENUM_FLAGS; }
        case .CLASS { symbol.kind = .CLASS; }
        case .INTERFACE { symbol.kind = .INTERFACE; }
        case .FUNCTION { symbol.kind = .GLOBAL_FUNCTION; }
        case .CONSTRUCTOR { symbol.kind = .CONSTRUCTOR_FUNCTION; }
        case .VARIABLE { symbol.kind = .GLOBAL_VARIABLE; }
        case .PARAMETER { symbol.kind = symbol.enclosingSymbol != null ? .OBJECT_PARAMETER : .FUNCTION_PARAMETER; }
        case .ALIAS { symbol.kind = .ALIAS; }
        case .EXTENSION { semanticErrorExtensionMissingTarget(log, declarationName.range, declarationName.asString()); }
        default { assert false; }
      }
    }

    // Distinguish between global and instance functions and variables now that
    // all symbols have a kind associated with them
    for (var i = 0; i < parsedDeclarations.size(); i++) {
      var node = parsedDeclarations[i];
      var symbol = node.symbol;

      // Change non-static global functions/variables to instance
      if (!symbol.isStatic() && (symbol.isObjectMember() || symbol.isEnumMember() && symbol.isFromExtension())) {
        if (symbol.kind == .GLOBAL_FUNCTION) symbol.kind = .INSTANCE_FUNCTION;
        else if (symbol.kind == .GLOBAL_VARIABLE) symbol.kind = .INSTANCE_VARIABLE;
      }

      // Change global variables to local
      else if (symbol.kind == .GLOBAL_VARIABLE && checkParentsForLocalVariable(node)) {
        symbol.kind = .LOCAL_VARIABLE;
      }
    }
  }

  void processUsingStatements() {
    for (var i = 0; i < parsedBlocks.size(); i++) {
      var block = parsedBlocks[i];

      // Empty blocks will have a children array of null
      if (!block.hasChildren()) {
        continue;
      }

      // Add symbols from using statements. These must be added after symbols
      // have finished being registered because using statements only import
      // symbols from their namespace if there isn't already an existing symbol:
      //
      //   namespace Foo { class Bar {} }
      //   using Foo;
      //   class Bar {} // This is not an error
      //
      List<Symbol> insertedSymbols = null;
      for (var j = 0; j < block.children.size(); j++) {
        var statement = block.children[j];
        if (statement.kind != .USING) {
          continue;
        }

        // Resolve the namespace as an absolute name
        var value = statement.usingValue();
        resolveGlobalUsingValue(value);
        if (value.type.isIgnored(cache)) {
          continue;
        }
        var symbol = value.type.symbol;
        if (symbol == null) {
          continue;
        }

        // Unlike a using alias, using statements must be a namespace. While
        // this could in theory support arbitrary types, it's more readable and
        // gives clearer errors to limit this to namespaces.
        if (!symbol.kind.isNamespace()) {
          semanticErrorBadUsing(log, value.range);
          continue;
        }

        // Lazily allocate this list to reduce allocations
        if (insertedSymbols == null) {
          insertedSymbols = [];
        }

        // Copy each non-namespace symbol into this namespace if not already
        // present. If a symbol is already present but was due to another
        // using namespace statement, then mark the symbol as ambiguous.
        var members = symbol.type.sortedMembers();
        for (var k = 0; k < members.size(); k++) {
          var member = members[k];
          var memberSymbol = member.symbol;
          if (memberSymbol.kind == .NAMESPACE) {
            continue;
          }

          // Look for a symbol with the same name already in this scope
          var current = block.scope.findLocal(memberSymbol.name);
          if (current == null) {
            insertedSymbols.push(memberSymbol);
            block.scope.insertLocal(member);
            continue;
          }

          // Only merge with other symbols that were also inserted by this pass
          var currentSymbol = current.symbol;
          if (!(currentSymbol in insertedSymbols)) {
            continue;
          }

          // Only add the symbol if it's not already in the ambiguous symbol list
          if (currentSymbol.kind != .AMBIGUOUS) {
            if (memberSymbol != currentSymbol) {
              var collision = createSymbol(memberSymbol.name, .AMBIGUOUS);
              collision.identicalMembers = [current, member];
              block.scope.locals[memberSymbol.name] = Member(collision);
              insertedSymbols.push(collision);
            }
          } else if (!(member in currentSymbol.identicalMembers)) {
            currentSymbol.identicalMembers.push(member);
          }
        }
      }
    }
  }

  void resolveGlobalUsingValue(Node node) {
    node.type = cache.errorType;
    Member member;

    // Handle top-level names
    if (node.kind == .NAME) {
      var name = node.asString();
      member = cache.globalType.findMember(name);
      if (member == null) {
        semanticErrorUndeclaredSymbol(log, node.range, name);
        return;
      }
    }

    // Handle nested names
    else if (node.kind == .DOT) {
      var target = node.dotTarget();
      resolveGlobalUsingValue(target);
      var targetType = target.type;
      var dotName = node.dotName();
      if (targetType == null || dotName == null) {
        return;
      }
      var name = dotName.asString();
      member = targetType.findMember(name);
      if (member == null) {
        semanticErrorUnknownMemberSymbol(log, dotName.range, name, targetType);
        return;
      }
    }

    // Non-name nodes are not allowed
    else {
      semanticErrorUnexpectedNode(log, node.range, node.kind);
      return;
    }

    // Validate the member type, must not be an instance
    if (!member.symbol.kind.isType()) {
      semanticErrorBadUsingValue(log, node.range);
      return;
    }

    // Create a type node to distinguish the type from an instance of that type
    node.become(Node.createType(member.symbol.type).withRange(node.range).withSymbol(member.symbol));
    assert node.type != null; // All type symbols should have a type by now
  }

  void resolve(Node node, Type expectedType) {
    // Only resolve once
    if (node.type != null) {
      return;
    }
    node.type = cache.errorType;

    // Use the current scope for all child nodes
    assert context.scope != null || node.kind == .PROGRAM;
    var oldScope = context.scope;
    var oldType = typeContext;
    var kind = node.kind;
    if (node.scope != null) context.scope = node.scope;

    // Track the type from the context this node is used in
    typeContext = expectedType;

    // Separating the case bodies into separate functions makes the JavaScript JIT go faster
    switch (kind) {
      case .PROGRAM { resolveProgram(node); }
      case .FILE { resolveFile(node); }
      case .BLOCK { resolveBlock(node); }
      case .NODE_LIST { resolveChildren(node); }
      case .CASE { resolveCase(node); }
      case .USING { resolveUsing(node); }

      case .NAMESPACE { resolveNamespace(node); }
      case .ENUM, .ENUM_FLAGS { resolveEnum(node); }
      case .CLASS, .INTERFACE { resolveObject(node); }

      case .EXTENSION { resolveExtension(node); }
      case .CONSTRUCTOR, .FUNCTION { resolveFunction(node); }
      case .VARIABLE { resolveVariable(node); }
      case .VARIABLE_CLUSTER { resolveVariableCluster(node); }
      case .PARAMETER { resolveParameter(node); }
      case .ALIAS { resolveAlias(node); }

      case .IF { resolveIf(node); }
      case .FOR { resolveFor(node); }
      case .FOR_EACH { resolveForEach(node); }
      case .WHILE { resolveWhile(node); }
      case .DO_WHILE { resolveWhile(node); }
      case .RETURN { resolveReturn(node); }
      case .BREAK { resolveBreak(node); }
      case .CONTINUE { resolveContinue(node); }
      case .ASSERT, .ASSERT_CONST { resolveAssert(node); }
      case .EXPRESSION { resolveExpression(node); }
      case .SWITCH { resolveSwitch(node); }
      case .MODIFIER { resolveModifier(node); }

      case .NAME { resolveName(node); }
      case .NULL { node.type = cache.nullType; }
      case .THIS { resolveThis(node); }
      case .BOOL { node.type = cache.boolType; }
      case .HOOK { resolveHook(node); }
      case .INT { resolveInt(node); }
      case .FLOAT { node.type = cache.floatType; }
      case .DOUBLE { node.type = cache.doubleType; }
      case .STRING { node.type = cache.stringType; }
      case .LIST { resolveList(node); }
      case .DOT, .DOT_ARROW, .DOT_COLON { resolveDot(node); }
      case .CALL { resolveCall(node); }
      case .SUPER_CALL { resolveSuperCall(node); }
      case .ERROR {} // Ignore parse errors
      case .SEQUENCE { resolveSequence(node); }
      case .PARAMETERIZE { resolveParameterize(node); }
      case .CAST { resolveCast(node); }
      case .QUOTED { resolveQuoted(node); }
      case .VAR { resolveVar(node); }
      default {
        if (kind.isUnaryOperator()) resolveUnary(node);
        else if (kind.isBinaryOperator()) resolveBinary(node);
        else if (kind.isTernaryOperator()) resolveTernary(node);
        else assert false;
      }
    }

    context.scope = oldScope;
    typeContext = oldType;
    assert node.type != null;
  }

  void checkIsParameterized(Node node) {
    if (!node.type.isIgnored(cache) && node.type.hasParameters() && !node.type.isParameterized()) {
      semanticErrorUnparameterizedType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsType(Node node) {
    if (node.kind == .QUOTED) {
      var symbol = createSymbol("<quoted>", .QUOTED_TYPE);
      symbol.node = node.quotedValue().remove();
      symbol.type = Type(symbol);
      node.kind = .TYPE;
      node.type = symbol.type;
    }

    else if (!node.type.isIgnored(cache) && !node.kind.isType()) {
      semanticErrorUnexpectedExpression(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsInstance(Node node) {
    if (!node.type.isIgnored(cache) && node.kind.isType()) {
      semanticErrorUnexpectedType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsValidFunctionReturnType(Node node) {
    if (!node.type.isVoid(cache)) {
      checkIsValidVariableType(node);
    }
  }

  void checkIsValidVariableType(Node node) {
    if (node.type.isVoid(cache) || node.type.isNamespace()) {
      semanticErrorBadType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkUnusedExpression(Node node) {
    var kind = node.kind;
    if (kind == .HOOK) {
      checkUnusedExpression(node.hookTrue());
      checkUnusedExpression(node.hookFalse());
    } else if (kind == .SEQUENCE) {
      if (node.hasChildren()) {
        checkUnusedExpression(node.lastChild());
      }
    } else if (!node.range.isEmpty() && !node.type.isIgnored(cache) && !kind.isCall() && !kind.isUnaryStorageOperator() && !kind.isBinaryStorageOperator()) {
      semanticWarningUnusedExpression(log, node.range);
    }
  }

  void checkStorage(Node node) {
    if (node.type.isIgnored(cache)) {
      return;
    }

    // Only certain expressions support storage
    if (!node.kind.isStorage()) {
      semanticErrorBadStorage(log, node.range);
      return;
    }

    // Forbid storage to final symbols
    if (node.symbol.isConst()) {
      semanticErrorStorageToProtectedSymbol(log, node.range, "const");
    } else if (node.symbol.isFinal()) {
      semanticErrorStorageToProtectedSymbol(log, node.range, "final");
    }
  }

  void checkStorageOperator(Node node) {
    var parent = node.parent;
    while (parent.kind == .SEQUENCE) {
      parent = parent.parent;
    }
    if (parent.kind != .EXPRESSION && parent.kind != .FOR) {
      semanticErrorNestedStorageOperator(log, node.range);
    }
  }

  void checkConversion(Type to, Node node, CastKind kind) {
    var from = node.type;
    assert from != null;
    assert to != null;

    // Avoid reporting further errors
    if (from.isIgnored(cache) || to.isIgnored(cache)) {
      return;
    }

    // Converting from "void" to "void" always fails
    if (from.isVoid(cache) && to.isVoid(cache)) {
      semanticErrorUnexpectedExpression(log, node.range, to);
      node.type = cache.errorType;
      return;
    }

    // No implicit conversion needed for identical types
    if (from == to) {
      // Forbid raw function references. All function references must result in
      // a call. The representation for values of function type is likely not
      // the same as a function definition because values of function type may
      // contain lambdas with captured variables which require an environment.
      //
      // In the future, some or all of these cases could be automatically be
      // converted to lambda expressions that call the function. When doing
      // this conversion, make sure to capture the value of "this" for member
      // functions inside the lambda.
      //
      if (node.symbol != null && node.symbol.kind.isFunction() && !node.kind.isCall() && node.parent.kind != .CALL) {
        semanticErrorMustCallFunctionReference(log, node.range);
        node.type = cache.errorType;
      }
      return;
    }

    // Special-case assigning 0 to an enum flags type
    if (to.isEnumFlags() && node.kind == .INT && node.asInt() == 0) {
      from = to;
    }

    // The implicit conversion must be valid
    if (kind == .IMPLICIT_CAST && !cache.canImplicitlyConvert(from, to) ||
        kind == .EXPLICIT_CAST && !cache.canExplicitlyConvert(from, to)) {
      semanticErrorIncompatibleTypes(log, node.range, from, to, cache.canExplicitlyConvert(from, to));
      node.type = cache.errorType;
      return;
    }

    // Make the implicit conversion explicit for convenience later on
    if (kind == .IMPLICIT_CAST) {
      if (node.kind.isType()) return;
      var value = Node(.NULL);
      value.become(node);
      node.become(Node.createImplicitCast(Node.createType(to), value).withType(to).withRange(node.range));
    }
  }

  void unexpectedStatement(Node node) {
    // Don't warn about compiler-generated statements
    if (!node.range.isEmpty()) {
      semanticErrorUnexpectedStatement(log, node.range);
    }
  }

  void checkInsideBlock(Node node) {
    assert node.parent != null;

    // This will detect statements inside modifier "blocks", which aren't real
    // blocks and don't have their own scope:
    //
    //   inline { alias bar = foo; }
    //
    if (node.parent.kind != .BLOCK) {
      unexpectedStatement(node);
    }
  }

  void checkDeclarationLocation(Node node, AllowDeclaration allowDeclaration) {
    assert node.parent != null;

    // Top-level declarations cannot live inside object declarations, function
    // declarations, or conditional statements
    Node parent;
    for (parent = node.parent; parent != null; parent = parent.parent) {
      if (parent.symbol != null && parent.symbol.hasLocationError()) {
        break;
      }
      var kind = parent.kind;
      if (kind != .PROGRAM && kind != .FILE && kind != .MODIFIER && kind != .BLOCK && kind != .NAMESPACE &&
          kind != .EXTENSION && (allowDeclaration != .ALLOW_TOP_OR_OBJECT_LEVEL || !kind.isObject())) {
        unexpectedStatement(node);
        break;
      }
    }
    if (parent != null) {
      node.symbol.flags |= .HAS_LOCATION_ERROR;
    }
  }

  void checkStatementLocation(Node node) {
    assert node.parent != null;

    // Statements must live inside functions
    for (var parent = node.parent; parent != null; parent = parent.parent) {
      var kind = parent.kind;

      // If we reach the file then the statement doesn't belong here
      if (kind == .FILE) {
        unexpectedStatement(node);
        break;
      }

      // Stop if we reach a function because then this statement is allowed.
      // Also stop if we reach a block in another non-declaration statement
      // because the error should already have been reported by whatever owns
      // that block and fewer errors are better.
      if (kind == .BLOCK) {
        var parentKind = parent.parent.kind;
        if (!parentKind.isNamedBlockDeclaration() && parentKind != .FILE) {
          break;
        }
      }
    }
  }

  bool checkAccessToThis(Range range) {
    if (context.functionSymbol != null && context.functionSymbol.kind.isInstance()) {
      return true;
    }

    if (context.symbolForThis != null) semanticErrorStaticThis(log, range, "this");
    else semanticErrorUnexpectedThis(log, range, "this");
    return false;
  }

  bool checkAccessToInstanceSymbol(Node node) {
    var symbol = node.symbol;
    var enclosingSymbol = symbol.enclosingSymbol;
    var functionSymbol = context.functionSymbol;

    // No need to check for static symbols
    if (!symbol.kind.isInstance() && symbol.kind != .OBJECT_PARAMETER) {
      return true;
    }

    // Allow instance access inside instance functions
    if (functionSymbol != null && functionSymbol.kind.isInstance() && (
        functionSymbol.enclosingSymbol == enclosingSymbol ||
        functionSymbol.enclosingSymbol.type.hasBaseType(enclosingSymbol.type))) {
      return true;
    }

    // Use a different error message when outside a function for clarity
    if (context.symbolForThis == null) {
      semanticErrorUnexpectedThis(log, node.range, symbol.name);
      return false;
    }

    // The cases where type parameters may appear are more complicated
    if (symbol.kind == .OBJECT_PARAMETER && context.symbolForThis == enclosingSymbol) {
      for (var parent = node.parent; !parent.kind.isNamedBlockDeclaration(); parent = parent.parent) {
        if (parent.kind == .NODE_LIST && parent.parent.kind.isNamedBlockDeclaration() && parent.parent.symbol == enclosingSymbol &&
            (parent == enclosingSymbol.node.objectParameters() || parent == enclosingSymbol.node.baseTypes())) {
          return true;
        }
        if ((parent.kind == .VARIABLE || parent.kind.isFunction()) && parent.symbol.kind.isInstance()) {
          return true;
        }
      }
    }

    semanticErrorStaticThis(log, node.range, symbol.name);
    return false;
  }

  List<Node> collectAndResolveBaseTypes(Symbol symbol) {
    List<Node> baseTypes = [];
    for (var node = symbol.node; node != null; node = node.sibling) {
      var isObject = node.kind.isObject();
      if (isObject || node.kind == .EXTENSION) {
        var types = node.baseTypes();
        if (types != null && types.hasChildren()) {
          var index = 0;
          for (var i = 0; i < types.children.size(); i++) {
            var baseType = types.children[i];
            resolveAsParameterizedType(baseType);
            if (isObject) {
              baseTypes.insert(index, baseType);
              index++;
            } else if (symbol.type.isClass() && baseType.type.isClass()) {
              semanticErrorBaseClassInExtension(log, baseType.range);
            } else {
              baseTypes.push(baseType);
            }
          }
        }
      }
    }
    return baseTypes;
  }

  void checkNoBaseTypes(Symbol symbol, string what) {
    var baseTypes = collectAndResolveBaseTypes(symbol);
    for (var i = 0; i < baseTypes.size(); i++) {
      semanticErrorUnexpectedBaseType(log, baseTypes[i].range, what);
    }
  }

  Node createDefaultValue(Type type, Range range) {
    if (type.isReference()) return Node.createNull().withType(type);
    if (type.isBool(cache)) return Node.createBool(false).withType(type);
    if (type.isInt(cache)) return Node.createInt(0).withType(type);
    if (type.isFloat(cache)) return Node.createFloat(0.0).withType(type);
    if (type.isDouble(cache)) return Node.createDouble(0.0).withType(type);
    if (type.isString(cache)) return Node.createString("").withType(type);
    if (type.isEnum()) return Node.createInt(0).withType(type);
    if (!type.isIgnored(cache)) semanticErrorNoDefaultValue(log, range, type);
    return Node.createError().withType(cache.errorType);
  }

  bool needsTypeContext(Node node) {
    return
      node.kind == .LIST ||
      node.kind == .DOT && node.dotTarget() == null ||
      node.kind == .COMPLEMENT && needsTypeContext(node.unaryValue()) ||
      node.kind == .HOOK && needsTypeContext(node.hookTrue()) && needsTypeContext(node.hookFalse());
  }

  void addAutoGeneratedMember(Type type, string name) {
    var symbol = createSymbol(name, .AUTOMATIC);
    symbol.enclosingSymbol = type.symbol;
    type.addMember(Member(symbol));
  }

  void forbidBlockDeclarationModifiers(Symbol symbol, string where) {
    unexpectedModifierIfPresent(symbol, .CONST, where);
    unexpectedModifierIfPresent(symbol, .FINAL, where);
    unexpectedModifierIfPresent(symbol, .INLINE, where);
    unexpectedModifierIfPresent(symbol, .STATIC, where);
    unexpectedModifierIfPresent(symbol, .VIRTUAL, where);
    unexpectedModifierIfPresent(symbol, .OVERRIDE, where);
    forbidImportAndExportTogether(symbol);
  }

  void initializeNamespace(Symbol symbol) {
    assert symbol.type.isNamespace();
    forbidBlockDeclarationModifiers(symbol, "on a namespace declaration");
    checkNoBaseTypes(symbol, "A namespace");
  }

  void initializeEnum(Symbol symbol) {
    assert symbol.type.isEnum();
    forbidBlockDeclarationModifiers(symbol, "on an enum declaration");
    checkNoBaseTypes(symbol, "An enum");

    // Automatically generate toString() if missing
    if (symbol.type.findMember("toString") == null && !symbol.isImport()) {
      addAutoGeneratedMember(symbol.type, "toString");
    }
  }

  void resolveBaseTypes(Symbol symbol) {
    var type = symbol.type;
    var baseTypes = collectAndResolveBaseTypes(symbol);
    var unmergedMembers = StringMap<Member>();
    assert type.relevantTypes == null;
    type.relevantTypes = [];

    for (var i = 0; i < baseTypes.size(); i++) {
      var base = baseTypes[i];
      var baseType = base.type;

      // Avoid reporting further errors
      if (baseType.isIgnored(cache)) {
        continue;
      }

      // Ensure there is one base class and everything else is an interface
      if (symbol.kind == .CLASS && baseType.isClass() && !baseType.isPrimitive()) {
        if (baseTypes.indexOf(base) != 0) {
          semanticErrorClassBaseNotFirst(log, base.range, baseType);
          continue;
        }
      } else if (!baseType.isInterface()) {
        semanticErrorBadBaseType(log, base.range, baseType);
        continue;
      }

      // Prevent duplicates, but only within this type (duplicates among base
      // types are fine)
      if (baseType in type.relevantTypes) {
        semanticErrorDuplicateBaseType(log, base.range, baseType);
        continue;
      }

      // Cycles should already be prevented by the general-purpose cycle
      // detection algorithm, since symbol should still be initializing
      assert !baseType.hasBaseType(type);

      type.relevantTypes.push(baseType);

      // Collect all base type members
      var members = baseType.sortedMembers();
      for (var j = 0; j < members.size(); j++) {
        var member = members[j];
        var memberSymbol = member.symbol;
        var unmerged = unmergedMembers.getOrDefault(memberSymbol.name, null);

        // Skip type parameters since base types should not have access:
        //
        //   class Foo<T> { void foo(T foo) {} }
        //   class Bar : Foo<int> { void foo(T foo) {} }
        //
        if (memberSymbol.kind == .OBJECT_PARAMETER) {
          continue;
        }

        if (unmerged == null) {
          unmergedMembers[memberSymbol.name] = member;
        }

        else if (unmerged.symbol.enclosingSymbol != memberSymbol) {
          var combined = createSymbol(memberSymbol.name, .UNMERGED);
          combined.enclosingSymbol = symbol;
          combined.identicalMembers = [unmerged, member];
          unmergedMembers[memberSymbol.name] = Member(combined);
        }

        else {
          assert unmerged.symbol.kind == .UNMERGED;
          unmerged.symbol.identicalMembers.push(member);
        }
      }
    }

    // Insert unmerged symbols into the derived type, but don't replace the
    // member symbols that are already there
    var baseMembers = unmergedMembers.values();
    for (var i = 0; i < baseMembers.size(); i++) {
      var member = baseMembers[i];
      var existing = type.findMember(member.symbol.name);

      // Link existing members with the member they override
      if (existing != null) {
        assert existing.symbol.overriddenMember == null;
        existing.symbol.overriddenMember = member;
      }

      // Note that member.symbol.kind == .CONSTRUCTOR_FUNCTION will miss
      // automatically generated constructors that haven't been initialized yet,
      // but checking the name against "new" will always be correct since "new"
      // is a keyword
      else if (member.symbol.name != "new") {
        type.addMember(member);
      }
    }
  }

  void resolveTypeParameters(Symbol symbol, Node node) {
    if (node != null && node.hasChildren()) {
      symbol.parameters = [];
      resolveNodes(node.children);
      for (var i = 0; i < node.children.size(); i++) {
        symbol.parameters.push(node.children[i].symbol);
      }
      symbol.sortParametersByDependencies();
    }
  }

  void initializeObject(Symbol symbol) {
    assert symbol.type.isObject();
    forbidBlockDeclarationModifiers(symbol, "on an object declaration");

    var node = symbol.node.firstNonExtensionSibling();
    var type = symbol.type;
    resolveTypeParameters(symbol, node.objectParameters());

    // Automatically generate a constructor if missing
    if (!type.isInterface() && type.constructor() == null && !symbol.isImport()) {
      addAutoGeneratedMember(type, "new");
    }

    // Resolve base types and copy all base symbols onto this type
    resolveBaseTypes(symbol);
  }

  void createFunctionType(Symbol symbol, Type resultType, List<Type> argumentTypes) {
    // Generic functions get their own type
    if (symbol.hasParameters()) {
      symbol.type = Type(symbol);
      argumentTypes.unshift(resultType);
      symbol.type.relevantTypes = argumentTypes;
    } else {
      symbol.type = cache.functionType(resultType, argumentTypes);
    }
  }

  void initializeFunction(Symbol symbol) {
    var enclosingSymbol = symbol.enclosingSymbol;

    // Sanity check
    assert enclosingSymbol == null || !enclosingSymbol.kind.isTypeWithInstances() ||
      context.symbolForThis != null && context.symbolForThis == enclosingSymbol;

    unexpectedModifierIfPresent(symbol, .CONST, "on a function declaration");
    unexpectedModifierIfPresent(symbol, .FINAL, "on a function declaration");
    checkMemberSymbol(symbol);

    var node = symbol.node;
    Type resultType;

    // Only functions have return types (constructors don't)
    if (node.kind == .FUNCTION) {
      var result = node.functionResult();
      resolveTypeParameters(symbol, node.functionParameters());
      resolveAsParameterizedType(result);
      checkIsValidFunctionReturnType(result);
      resultType = result.type;
    }

    // Constructors get a return type of the object that they create
    else {
      assert node.kind == .CONSTRUCTOR;
      resultType = cache.ensureTypeIsParameterized(enclosingSymbol.type);

      // Mark the class as abstract if it contains any abstract symbols. This
      // is done here since the constructor must be initialized before being
      // invoked, which ensures that the abstract flag will be set correctly.
      var members = enclosingSymbol.type.sortedMembers();
      for (var i = 0; i < members.size(); i++) {
        var memberSymbol = members[i].symbol;
        var isImport = memberSymbol.isImport() || enclosingSymbol.isImport() && !memberSymbol.isFromExtension();
        if (!isImport && memberSymbol.kind.isFunction() && memberSymbol.node.functionBlock() == null) {
          enclosingSymbol.reasonForAbstract = memberSymbol;
          enclosingSymbol.flags |= .ABSTRACT;
          break;
        }
      }

      // Constructors are special instance methods
      unexpectedModifierIfPresent(symbol, .STATIC, "on a constructor");
      unexpectedModifierIfPresent(symbol, .VIRTUAL, "on a constructor");
      unexpectedModifierIfPresent(symbol, .OVERRIDE, "on a constructor");
    }

    // Resolve argument variables
    var arguments = node.functionArguments();
    resolve(arguments, null);

    // Create the function type
    symbol.type = cache.errorType;
    if (!resultType.isError(cache)) {
      List<Type> argumentTypes = [];
      for (var i = 0; i < arguments.children.size(); i++) {
        var type = arguments.children[i].symbol.type;
        if (type.isError(cache)) return;
        argumentTypes.push(type);
      }
      createFunctionType(symbol, resultType, argumentTypes);
    }

    var overriddenMember = symbol.overriddenMember;

    // Non-imported methods on imported types cannot be virtual
    if (!symbol.isImport() && enclosingSymbol != null && enclosingSymbol.isImport()) {
      unexpectedModifierIfPresent(symbol, .VIRTUAL, "on a non-imported method for an imported type");
      unexpectedModifierIfPresent(symbol, .OVERRIDE, "on a non-imported method for an imported type");
    }

    // Functions must not have a different type than the symbol they override
    else if (overriddenMember != null && symbol.kind != .CONSTRUCTOR_FUNCTION) {
      initializeMember(overriddenMember);
      var base = overriddenMember.type;
      var derived = symbol.type;
      if (!base.isIgnored(cache) && !derived.isIgnored(cache)) {
        var overriddenSymbol = overriddenMember.symbol;

        // Functions can only override other functions
        if (!base.isFunction() || !overriddenSymbol.kind.isInstance() || !symbol.kind.isInstance()) {
          semanticErrorBadOverride(log, node.declarationName().range, symbol.name,
            overriddenSymbol.enclosingSymbol.type, overriddenSymbol.node.declarationName().range);
        }

        // Functions can only override other functions with the same signature
        else if (base != derived) {
          semanticErrorOverrideDifferentTypes(log, node.declarationName().range, symbol.name,
            base, derived, overriddenSymbol.node.declarationName().range);
        }

        // Overriding must be explicit with the "override" modifier
        else if (!symbol.isOverride()) {
          semanticErrorModifierMissingOverride(log, node.declarationName().range, symbol.name,
            overriddenSymbol.node.declarationName().range);
        }

        // Overriding must be explicit with the "override" modifier
        else if (!overriddenSymbol.isVirtual()) {
          semanticErrorCannotOverrideNonVirtual(log, node.declarationName().range, symbol.name,
            overriddenSymbol.node.declarationName().range);
        }

        // The "override" modifier replaces the "virtual" modifier
        else {
          redundantModifierIfPresent(symbol, .VIRTUAL, "on an overriding function");
        }
      }

      // The "virtual" modifier is implied
      symbol.flags |= .VIRTUAL;
    }

    // Ignore overriding-related modifiers outside an object
    else if (!symbol.isObjectMember()) {
      unexpectedModifierIfPresent(symbol, .VIRTUAL, "outside an object declaration");
      unexpectedModifierIfPresent(symbol, .OVERRIDE, "outside an object declaration");
    }

    // Validate modifiers when nothing is being overridden
    else {
      if (!symbol.kind.isInstance()) unexpectedModifierIfPresent(symbol, .VIRTUAL, "on a non-instance function");

      // If "override" is used, imply "virtual" to mask further errors
      if (symbol.isOverride()) symbol.flags |= .VIRTUAL;

      unexpectedModifierIfPresent(symbol, .OVERRIDE, "on a function that doesn't override anything");
    }
  }

  void initializeVariable(Symbol symbol) {
    unexpectedModifierIfPresent(symbol, .INLINE, "on a variable declaration");
    unexpectedModifierIfPresent(symbol, .VIRTUAL, "on a variable declaration");
    unexpectedModifierIfPresent(symbol, .OVERRIDE, "on a variable declaration");
    checkMemberSymbol(symbol);

    if (symbol.isConst()) {
      redundantModifierIfPresent(symbol, .FINAL, "on a const variable declaration");
    }

    var node = symbol.node;
    var variableType = node.variableType();
    if (variableType == null) {

      // Take the variable type from the enclosing variable cluster
      if (node.parent.kind == .VARIABLE_CLUSTER) {
        variableType = node.parent.clusterType().clone();
      }

      // Take the variable type from the surrounding context
      else {
        assert symbol.isEnumValue();
        var enclosingSymbol = symbol.enclosingSymbol;
        var type = enclosingSymbol.type;
        variableType = Node.createType(type).withSymbol(enclosingSymbol);

        // All enum values are final and always transfer the import/export flags
        symbol.flags |= .FINAL | .STATIC | enclosingSymbol.flags & (.IMPORT | .EXPORT);

        // Look at the initializer now
        var variableValue = node.variableValue();
        if (variableValue != null) {
          resolveAsParameterizedExpressionWithTypeContext(variableValue, type);
          checkConversion(cache.intType, variableValue, .IMPLICIT_CAST);
          constantFolder.foldConstants(variableValue);
          if (variableValue.kind == .INT) {
            symbol.constant = variableValue.content;
          } else {
            variableType = Node.createType(cache.errorType);
            if (!variableValue.type.isIgnored(cache)) {
              semanticErrorBadIntegerConstant(log, variableValue.range, variableValue.type);
            }
          }
        }

        // If there is no initializer, create a value based on the previous enum value
        else {
          var index = node.parent.children.indexOf(node);
          if (index > 0) {
            var previous = node.parent.children[index - 1].symbol;
            initializeSymbol(previous);
            if (!previous.type.isIgnored(cache)) {
              var constant = previous.constant.asInt();
              var value = type.isEnumFlags() ? constant * 2.0 : constant + 1.0;
              if (value == (int)value) {
                symbol.constant = IntContent((int)value);
              } else {
                semanticErrorEnumValueOutOfRange(log, node.range, symbol.name);
                variableType = Node.createType(cache.errorType);
              }
            } else {
              variableType = Node.createType(cache.errorType);
            }
          }

          // If there is no previous enum value, use the default value
          else {
            symbol.constant = IntContent(type.isEnumFlags() ? 1 : 0);
          }
        }
      }

      assert variableType != null;
      node.replaceChild(1, variableType);
    }

    // Handle implicitly typed variables by taking the type from the assigned value
    if (variableType.kind == .VAR) {
      var value = node.variableValue();
      if (value == null) {
        semanticErrorVarMissingValue(log, node.declarationName().range);
        symbol.type = cache.errorType;
      } else {
        resolveAsParameterizedExpression(value);
        var type = value.type;
        if (type.isNull(cache) || type.isVoid(cache)) {
          semanticErrorVarBadType(log, node.declarationName().range, type);
          symbol.type = cache.errorType;
        } else {
          symbol.type = type;
        }
      }
    }

    // Resolve the expression for the variable type
    else {
      resolveAsParameterizedType(variableType);
      checkIsValidVariableType(variableType);
      symbol.type = variableType.type;

      // Make sure the variable cluster has a resolved type
      if (node.parent.kind == .VARIABLE_CLUSTER && node.parent.clusterType().type == null) {
        node.parent.replaceChild(0, variableType.clone());
      }
    }

    // Variables must not override other symbols
    var overriddenMember = symbol.overriddenMember;
    if (overriddenMember != null) {
      initializeMember(overriddenMember);
      var base = overriddenMember.type;
      var derived = symbol.type;
      if (!base.isIgnored(cache) && !derived.isIgnored(cache)) {
        semanticErrorBadOverride(log, node.declarationName().range, symbol.name,
          overriddenMember.symbol.enclosingSymbol.type, overriddenMember.symbol.node.declarationName().range);
      }
    }

    // Constants must be resolved during initialization
    if (symbol.isConst()) {
      var value = node.variableValue();
      if (value == null) {
        semanticErrorConstMissingValue(log, node.declarationName().range);
      } else {
        resolveAsParamterizedExpressionWithConversion(value, symbol.type, .IMPLICIT_CAST);
        constantFolder.foldConstants(value);
        if (value.kind.isConstant()) {
          symbol.constant = value.content;
        } else if (!value.type.isIgnored(cache) && !symbol.type.isIgnored(cache)) {
          semanticErrorNonConstantConstValue(log, value.range);
          value.type = cache.errorType;
        }
      }
    }
  }

  void initializeParameter(Symbol symbol) {
    var type = Type(symbol);
    var bound = symbol.node.parameterBound();
    symbol.type = type;

    // Type parameters can optionally have a single interface as an upper bound.
    // This forces all parameterizations to implement that interface and allows
    // use of that interface inside the scope of the parameter:
    //
    //   interface IFoo {
    //     void foo();
    //   }
    //
    //   class Foo<T is IFoo> {
    //     void foo(T value) {
    //       value.foo();
    //     }
    //   }
    //
    if (bound != null) {
      resolveAsParameterizedType(bound);
      var boundType = bound.type;
      if (boundType.isIgnored(cache)) {
        symbol.type = cache.errorType;
      } else if (!boundType.isInterface()) {
        semanticErrorBadTypeParameterBound(log, bound.range, boundType);
      } else {
        assert type.relevantTypes == null;
        type.relevantTypes = [boundType];
        type.copyMembersFrom(boundType);
      }
    }
  }

  void initializeAlias(Symbol symbol) {
    var value = symbol.node.aliasValue();
    resolveAsType(value);
    symbol.type = value.type;
  }

  void initializeDeclaration(Node node) {
    // The symbol should already have been set
    var symbol = node.symbol;
    assert symbol != null;

    // Only initialize once
    if (symbol.isUninitialized()) {
      // Flag the symbol's as initializing for the duration of the declaration's
      // initialization. This way we can detect cycles that try to use the symbol
      // in its own type, such as "foo foo;" or "class Foo : Foo {}". Cyclic
      // symbol references will return the error type in this case.
      symbol.flags |= .INITIALIZING;

      // Resolve using node.symbol.node to start from the first node in the
      // sibling chain to ensure that the entire chain is processed at once
      var oldContext = context;
      var oldTypeContext = typeContext;
      var oldResultType = resultType;
      context = ResolveContext.fromNode(node); // TODO: Cache this?
      typeContext = null;
      resultType = null;
      switch (symbol.kind) {
        case .NAMESPACE { initializeNamespace(symbol); }
        case .ENUM, .ENUM_FLAGS { initializeEnum(symbol); }
        case .CLASS, .INTERFACE { initializeObject(symbol); }
        case .GLOBAL_FUNCTION, .INSTANCE_FUNCTION, .CONSTRUCTOR_FUNCTION { initializeFunction(symbol); }
        case .LOCAL_VARIABLE, .GLOBAL_VARIABLE, .INSTANCE_VARIABLE { initializeVariable(symbol); }
        case .OBJECT_PARAMETER, .FUNCTION_PARAMETER { initializeParameter(symbol); }
        case .ALIAS { initializeAlias(symbol); }
        case .OTHER {}
        default { assert false; }
      }
      context = oldContext;
      typeContext = oldTypeContext;
      resultType = oldResultType;

      // Update the type now that cycle detection is complete
      assert symbol.type != null;
      assert symbol.isInitializing();
      assert !symbol.isInitialized();
      symbol.flags = (symbol.flags & ~.INITIALIZING) | .INITIALIZED;

      // Attach information to the declaration names for the language service
      while (node != null) {
        var name = node.declarationName();
        name.symbol = symbol;
        name.type = symbol.type;
        node = node.sibling;
      }

      // Initialize annotations last
      checkAnnotations(symbol);
    }
  }

  void initializePotentiallyDuplicatedMember(Member member, Range range) {
    // Ambiguous symbols are the result of multiple using namespace statements
    var symbol = member.symbol;
    if (symbol.kind == .AMBIGUOUS) {
      List<string> names = [];
      for (var i = 0; i < symbol.identicalMembers.size(); i++) {
        names.push(symbol.identicalMembers[i].symbol.fullName());
      }
      semanticErrorAmbiguousSymbol(log, range, symbol.name, names);
      member.type = cache.errorType;
      symbol.type = cache.errorType;
      return;
    }

    initializeMember(member);
  }

  void initializeMember(Member member) {
    // Only initialize the member once
    if (member.type != null) {
      return;
    }

    if (trace.GENERICS) {
      trace.log("initializeMember " + member.symbol.fullName() + (member.parameterizedType != null ? " on " + member.parameterizedType : ""));
      trace.indent();
    }

    // The type of a member in a derived type may depend on type substitution
    // on that member's type in a base class:
    //
    //   class Foo<A, B> { A foo(B bar) {} }
    //   class Bar<T> : Foo<int, T> {}
    //   class Baz : Bar<bool> {}
    //   int baz = Baz().foo(false);
    //
    if (member.dependency != null) {
      assert member.dependency.symbol == member.symbol;
      initializeMember(member.dependency);
      member.type = member.dependency.type;
    } else {
      initializeSymbol(member.symbol);
      member.type = member.symbol.type;
    }

    // Perform a lazy type substitution for members on generic types
    var parameterizedType = member.parameterizedType;
    if (parameterizedType != null && parameterizedType.isParameterized()) {
      member.type = cache.substitute(member.type, parameterizedType.symbol.parameters, parameterizedType.substitutions);
    }

    if (trace.GENERICS) {
      trace.dedent();
    }
  }

  void checkAnnotations(Symbol symbol) {
    if (!symbol.hasAnnotations()) {
      // Eagerly initialize member functions with annotations since these
      // members are added to this type on initialization. Otherwise operator
      // overloading wouldn't be order independent:
      //
      //   class Foo { @OperatorGet void get(int i) {} }
      //   export void foo() { Foo()[0]; }
      //
      // vs
      //
      //   export void foo() { Foo()[0]; }
      //   class Foo { @OperatorGet void get(int i) {} }
      //
      if (symbol.kind.isTypeWithInstances()) {
        var members = symbol.type.sortedMembers();
        for (var i = 0; i < members.size(); i++) {
          var member = members[i];
          var symbol = member.symbol;
          if (symbol.kind == .INSTANCE_FUNCTION && symbol.hasAnnotations()) {
            initializeMember(member);
          }
        }
      }
      return;
    }

    // Walk up the parent chain looking for modifiers
    var node = symbol.node.parent;
    if (node.kind == .VARIABLE_CLUSTER) {
      node = node.parent;
    }
    for (; node.kind == .MODIFIER; node = node.parent) {
      var modifierName = node.modifierName();
      var name = modifierName.asString();
      if (name[0] != '@') {
        continue;
      }
      NodeKind operatorKind = .NULL;

      // Other annotations
      if (name == "@EntryPoint") registerEntryPoint(symbol, node);
      else if (name == "@OperatorGet") operatorKind = .INDEX;
      else if (name == "@OperatorSet") operatorKind = .ASSIGN_INDEX;

      // Binary operators
      else if (name == "@OperatorCompare") operatorKind = .COMPARE;
      else if (name == "@OperatorAdd") operatorKind = .ADD;
      else if (name == "@OperatorSubtract") operatorKind = .SUBTRACT;
      else if (name == "@OperatorMultiply") operatorKind = .MULTIPLY;
      else if (name == "@OperatorDivide") operatorKind = .DIVIDE;
      else if (name == "@OperatorRemainder") operatorKind = .REMAINDER;
      else if (name == "@OperatorAnd") operatorKind = .BITWISE_AND;
      else if (name == "@OperatorOr") operatorKind = .BITWISE_OR;
      else if (name == "@OperatorXor") operatorKind = .BITWISE_XOR;
      else if (name == "@OperatorShiftLeft") operatorKind = .SHIFT_LEFT;
      else if (name == "@OperatorShiftRight") operatorKind = .SHIFT_RIGHT;
      else if (name == "@OperatorIn") operatorKind = .IN;

      // Binary storage operators
      else if (name == "@OperatorAddAssign") operatorKind = .ASSIGN_ADD;
      else if (name == "@OperatorSubtractAssign") operatorKind = .ASSIGN_SUBTRACT;
      else if (name == "@OperatorMultiplyAssign") operatorKind = .ASSIGN_MULTIPLY;
      else if (name == "@OperatorDivideAssign") operatorKind = .ASSIGN_DIVIDE;
      else if (name == "@OperatorRemainderAssign") operatorKind = .ASSIGN_REMAINDER;
      else if (name == "@OperatorAndAssign") operatorKind = .ASSIGN_BITWISE_AND;
      else if (name == "@OperatorOrAssign") operatorKind = .ASSIGN_BITWISE_OR;
      else if (name == "@OperatorXorAssign") operatorKind = .ASSIGN_BITWISE_XOR;
      else if (name == "@OperatorShiftLeftAssign") operatorKind = .ASSIGN_SHIFT_LEFT;
      else if (name == "@OperatorShiftRightAssign") operatorKind = .ASSIGN_SHIFT_RIGHT;

      // Unary operators
      else if (name == "@OperatorNegative") operatorKind = .NEGATIVE;
      else if (name == "@OperatorComplement") operatorKind = .COMPLEMENT;

      // No other annotations at the moment
      else semanticErrorUnknownAnnotation(log, modifierName.range, name);

      // Register operator overloads in one place to generate less code
      if (operatorKind != .NULL) registerOperatorOverload(symbol, node, operatorKind);
    }
  }

  void registerEntryPoint(Symbol symbol, Node node) {
    // The entry point must be a global function since it will be the first
    // thing executed after static initializers
    if (symbol.kind != .GLOBAL_FUNCTION) {
      semanticErrorNonGlobalEntryPoint(log, node.modifierName().range);
      return;
    }

    forbidAnnotationArguments(node);
    symbol.flags |= .ENTRY_POINT;
  }

  void forbidAnnotationArguments(Node node) {
    var arguments = node.modifierArguments();
    if (arguments != null) {
      var modifierName = node.modifierName();
      semanticErrorUnexpectedAnnotationArguments(log, arguments.range, modifierName.asString());
    }
  }

  void registerOperatorOverload(Symbol symbol, Node node, NodeKind kind) {
    // In theory we could support operator overloads using arbitrary functions,
    // but keep things simple for now and see if the complexity is needed
    if (symbol.kind != .INSTANCE_FUNCTION) {
      semanticErrorOperatorOnNonInstanceFunction(log, node.modifierName().range);
      return;
    }

    // The required argument count depends on the operator
    var functionArguments = symbol.node.functionArguments();
    var argumentCount = functionArguments.children.size();
    var expectedCount = kind.isUnaryOperator() ? 0 : kind.isBinaryOperator() ? 1 : 2;
    if (argumentCount != expectedCount) {
      semanticErrorOperatorArgumentCount(log, functionArguments.range, expectedCount, argumentCount, node.modifierName().asString());
      return;
    }

    forbidAnnotationArguments(node);

    // Ensure all operator overloads have function type to simplify things
    if (symbol.type.isIgnored(cache)) return;
    assert symbol.type.isFunction();

    symbol.enclosingSymbol.operatorOverloadsForKind(kind).push(symbol);
  }

  Symbol createSymbol(string name, SymbolKind kind) {
    var symbol = Symbol(name, kind);
    allSymbols.push(symbol);
    return symbol;
  }

  Node findModifierName(Symbol symbol, SymbolFlag flag) {
    var node = symbol.node.parent;
    if (node.kind == .VARIABLE_CLUSTER) {
      node = node.parent;
    }
    while (node != null && node.kind == .MODIFIER) {
      var modifierName = node.modifierName();
      if (nameToSymbolFlag[modifierName.asString()] == flag) {
        return modifierName;
      }
      node = node.parent;
    }
    return null;
  }

  void checkMemberSymbol(Symbol symbol) {
    forbidImportAndExportTogether(symbol);

    var enclosingSymbol = symbol.enclosingSymbol;
    if (enclosingSymbol != null) {
      if (!enclosingSymbol.kind.isTypeWithInstances()) {
        unexpectedModifierIfPresent(symbol, .STATIC, "outside an object declaration");
      }

      // The import/export modifiers are automatically implied for declarations
      // inside the type declaration, but not for those inside an extension
      if (!symbol.isFromExtension()) {
        if (enclosingSymbol.isImport()) {
          redundantModifierIfPresent(symbol, .IMPORT, "inside an imported type");
          symbol.flags |= .IMPORT;
        }
        if (enclosingSymbol.isExport()) {
          redundantModifierIfPresent(symbol, .EXPORT, "inside an exported type");
          symbol.flags |= .EXPORT;
        }
      }

      // Refuse to import/export a member of a type without a matching modifier
      if (enclosingSymbol.kind != .GLOBAL_NAMESPACE) {
        if (symbol.isImport() && !enclosingSymbol.isImport()) {
          unexpectedModifierIfPresent(symbol, .IMPORT, "inside a non-imported type");
        }
        if (symbol.isExport() && !enclosingSymbol.isExport()) {
          unexpectedModifierIfPresent(symbol, .EXPORT, "inside a non-exported type");
        }
      }
    }
  }

  void forbidImportAndExportTogether(Symbol symbol) {
    // The import/export modifiers are mutually exclusive
    if (symbol.isImport()) {
      unexpectedModifierIfPresent(symbol, .EXPORT, "on an imported declaration");
    }

    // Also prevent exporting something added in an extension block on an
    // imported type
    else if (symbol.enclosingSymbol != null && symbol.enclosingSymbol.isImport()) {
      unexpectedModifierIfPresent(symbol, .EXPORT, "inside an imported type");
    }
  }

  void redundantModifierIfPresent(Symbol symbol, SymbolFlag flag, string where) {
    if ((symbol.flags & flag) != 0) {
      var modifierName = findModifierName(symbol, flag);
      if (modifierName != null) {
        semanticErrorRedundantModifier(log, modifierName.range, modifierName.asString(), where);
      }
    }
  }

  void unexpectedModifierIfPresent(Symbol symbol, SymbolFlag flag, string where) {
    if ((symbol.flags & flag) != 0) {
      var modifierName = findModifierName(symbol, flag);
      if (modifierName != null) {
        semanticErrorUnexpectedModifier(log, modifierName.range, modifierName.asString(), where);
      }
    }
    symbol.flags &= ~flag;
  }

  void generateDefaultConstructor(Symbol symbol) {
    var enclosingSymbol = symbol.enclosingSymbol;
    var members = enclosingSymbol.type.sortedMembers();
    List<Node> arguments = [];
    List<Node> superArguments = null;
    List<Node> memberInitializers = [];

    // Compute a very conservative definition of pure for now. This is mostly
    // just to allow constructors to work as top-level variable initializers.
    var isPure = true;

    // Add arguments for each base constructor argument
    var baseClass = enclosingSymbol.type.isClass() ? enclosingSymbol.type.baseClass() : null;
    if (baseClass != null) {
      isPure = false;
      var constructor = baseClass.constructor();
      if (constructor != null) {
        initializeMember(constructor);
        if (constructor.type.isFunction()) {
          var argumentTypes = constructor.type.argumentTypes();
          superArguments = [];
          for (var i = 0; i < argumentTypes.size(); i++) {
            var name = "_" + arguments.size();
            var argument = Node.createVariable(Node.createName(name), Node.createType(argumentTypes[i]), null);
            argument.symbol = createSymbol(name, .LOCAL_VARIABLE);
            argument.symbol.node = argument;
            arguments.push(argument);
            superArguments.push(Node.createName(name));
          }
        } else {
          assert constructor.type.isIgnored(cache);
          symbol.flags |= .INITIALIZED;
          symbol.type = cache.errorType;
          return;
        }
      }
    }

    // Add arguments for each uninitialized instance variable
    List<Member> uninitializedMembers = [];
    for (var i = 0; i < members.size(); i++) {
      var member = members[i];
      var memberSymbol = member.symbol;
      if (memberSymbol.kind == .INSTANCE_VARIABLE && memberSymbol.enclosingSymbol == enclosingSymbol) {
        var value = memberSymbol.node.variableValue();

        // Uninitialized variables need an argument to provide the value
        if (value == null) {
          initializeMember(member);
          if (member.type.isError(cache)) {
            symbol.flags |= .INITIALIZED;
            symbol.type = cache.errorType;
            return;
          }
          uninitializedMembers.push(member);
        }

        // Ideally we could call isPureValue() but that requires resolving the
        // initial value for this variable, which could lead to some strange
        // circular reference issues. For example:
        //
        //   export class Foo {
        //     Foo a = Foo(1);
        //     int b = 100;
        //     int c;
        //   }
        //
        // Play it safe and just use statically-known constant values for now.
        else if (!value.kind.isConstant()) {
          isPure = false;
        }
      }
    }

    // Sort the uninitialized members by source location
    uninitializedMembers.sort(comparison);

    // Append each uninitialized member argument now that they are sorted
    for (var i = 0; i < uninitializedMembers.size(); i++) {
      var member = uninitializedMembers[i];
      var name = "_" + arguments.size();
      var argument = Node.createVariable(Node.createName(name), Node.createType(member.type), null);
      argument.symbol = createSymbol(name, .LOCAL_VARIABLE);
      argument.symbol.node = argument;
      arguments.push(argument);
      memberInitializers.push(Node.createMemberInitializer(Node.createName(member.symbol.name), Node.createName(name)));
    }

    // Change the automatic symbol into a constructor symbol
    symbol.kind = .CONSTRUCTOR_FUNCTION;
    symbol.node = Node.createConstructor(
      Node.createName(symbol.name),
      Node.createNodeList(arguments),
      Node.createBlock([]),
      superArguments != null ? Node.createSuperCall(superArguments) : null,
      memberInitializers != null ? Node.createNodeList(memberInitializers) : null);
    enclosingSymbol.node.declarationBlock().appendChild(symbol.node);

    // Initialize the scope ourselves since that pass is already over
    assert enclosingSymbol.node.scope != null;
    var scope = Scope(enclosingSymbol.node.scope);
    symbol.node.symbol = symbol;
    symbol.node.scope = scope;
    for (var i = 0; i < arguments.size(); i++) {
      scope.insert(Member(arguments[i].symbol));
    }

    // Infer the pure modifier if all sanity checks passed
    if (isPure) {
      symbol.flags |= .PURE;
    }
  }

  void generateDefaultToString(Symbol symbol) {
    assert symbol.isEnumMember();
    var enclosingSymbol = symbol.enclosingSymbol;
    var enclosingNode = enclosingSymbol.node;
    var members = enclosingSymbol.type.sortedMembers();
    List<Symbol> fields = [];

    // Gather the fields corresponding to enum values
    int i;
    for (i = 0; i < members.size(); i++) {
      var field = members[i].symbol;
      if (field.kind == .GLOBAL_VARIABLE && !field.isFromExtension()) {
        fields.push(field);
      }
    }

    // Check the fields for duplicates and sequential layout
    for (i = 0; i < fields.size(); i++) {
      var field = fields[i];
      initializeSymbol(field);
      if (field.type.isIgnored(cache)) {
        break;
      }
      var value = field.constant.asInt();
      int j;
      for (j = 0; j < i; j++) {
        Symbol other = fields[j];
        if (value == other.constant.asInt()) {
          semanticErrorBadEnumToString(log, enclosingNode.declarationName().range, enclosingSymbol.name, field.name, other.name, value);
          break;
        }
      }
      if (j < i) {
        break;
      }
    }

    // Generate an extension block next to the enum declaration
    var block = Node.createBlock([]);
    var extension = Node.createExtension(Node.createName(enclosingSymbol.name), null, block).withSymbol(enclosingSymbol);
    enclosingNode.insertSiblingAfter(extension);
    enclosingNode.appendToSiblingChain(extension);

    // Generate an empty function body if an error was emitted
    Node statement;
    if (fields.size() == 0 || i < fields.size()) {
      statement = Node.createReturn(Node.createString(""));
    }

    // Generate a string switch statment
    else {
      List<Node> cases = [];
      for (i = 0; i < fields.size(); i++) {
        var field = fields[i];
        cases.push(Node.createCase(
          [Node.createDot(null, Node.createName(field.name))],
          Node.createBlock([Node.createReturn(Node.createString(field.name))])));
      }
      cases.push(Node.createCase([], Node.createBlock([Node.createReturn(Node.createString(""))])));
      statement = Node.createSwitch(Node.createThis(), cases);
    }

    // Change the automatic symbol into an instance function
    symbol.kind = .INSTANCE_FUNCTION;
    symbol.flags = .FROM_EXTENSION;
    symbol.node = Node.createFunction(
      Node.createName(symbol.name),
      Node.createNodeList([]),
      Node.createBlock([statement]),
      Node.createType(cache.stringType),
      null).withSymbol(symbol);
    block.appendChild(symbol.node);

    // Resolve it now since it otherwise may never be resolved
    prepareNode(extension, enclosingNode.parent.scope);
    resolve(extension, null);
  }

  void initializeSymbol(Symbol symbol) {
    // Handle auto-generated symbols now
    if (symbol.kind == .AUTOMATIC) {
      if (symbol.name == "new") generateDefaultConstructor(symbol);
      else if (symbol.name == "toString") generateDefaultToString(symbol);
      else assert false;

      // Automatically generated symbols need to be explicitly resolved because
      // they aren't reachable from the parse tree, only from the type cache
      if (symbol.node != null) {
        var oldContext = context;
        context = ResolveContext.fromNode(symbol.node);
        resolve(symbol.node, null);
        context = oldContext;
      }
    }

    // Unmerged symbols are the result of multiple base types
    if (symbol.kind == .UNMERGED) {
      if (symbol.type != null) {
        return;
      }
      List<Type> types = [];
      for (var i = 0; i < symbol.identicalMembers.size(); i++) {
        var identical = symbol.identicalMembers[i];
        initializeMember(identical);
        var type = identical.type;
        var index = types.indexOf(type);
        if (index < 0) types.push(type);
      }
      if (types.size() != 1) {
        semanticErrorUnmergedSymbol(log, symbol.enclosingSymbol.node.declarationName().range, symbol.fullName(), types);
        symbol.type = cache.errorType;
      } else {
        symbol.type = types[0];
      }
      return;
    }

    // Only initialize the symbol once
    if (symbol.isUninitialized()) {
      assert symbol.node != null; // Internal symbols have no node but should already have a type
      initializeDeclaration(symbol.node);
      assert !symbol.isInitializing();
      assert symbol.isInitialized();
      assert symbol.type != null;

      if (symbol.isEntryPoint()) {
        validateEntryPoint(symbol);
      }
    }

    // Detect cyclic symbol references such as "foo foo;"
    else if (symbol.isInitializing()) {
      semanticErrorCyclicDeclaration(log, symbol.node.firstNonExtensionSibling().declarationName().range, symbol.name);
      symbol.type = cache.errorType;
    }
  }

  void validateEntryPoint(Symbol symbol) {
    var modifierName = symbol.node.declarationName();

    // Detect duplicate entry points
    if (entryPointSymbol != null) {
      semanticErrorDuplicateEntryPoint(log, modifierName.range, entryPointSymbol.node.declarationName().range);
      return;
    }

    entryPointSymbol = symbol;

    // Entry points must be usable without an instance
    if (symbol.kind != .GLOBAL_FUNCTION) {
      semanticErrorEntryPointOnNonGlobalFunction(log, modifierName.range);
      return;
    }

    // Importing an entry point doesn't make sense
    if (symbol.isImport()) {
      semanticErrorEntryPointOnImportedSymbol(log, modifierName.range);
      return;
    }

    var stringListType = cache.parameterize(cache.listType, [cache.stringType]);
    var validTypes = [
      cache.functionType(cache.voidType, []),
      cache.functionType(cache.intType, []),
      cache.functionType(cache.voidType, [stringListType]),
      cache.functionType(cache.intType, [stringListType]),
    ];

    // Only recognize a few entry point types
    if (!symbol.type.isError(cache) && validTypes.indexOf(symbol.type) < 0) {
      semanticErrorInvalidEntryPointType(log, modifierName.range, symbol.type, validTypes);
    }
  }

  void resolveArguments(List<Node> arguments, List<Type> argumentTypes, Range outer, Range inner) {
    // Validate the argument count
    if (argumentTypes.size() != arguments.size()) {
      var range = Range.equal(outer, inner) ? outer : Range.after(outer, inner);
      semanticErrorArgumentCount(log, range, argumentTypes.size(), arguments.size());
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Validate the arguments and provide type context
    for (var i = 0; i < arguments.size(); i++) {
      resolveAsParamterizedExpressionWithConversion(arguments[i], argumentTypes[i], .IMPLICIT_CAST);
    }
  }

  void resolveAsType(Node node) {
    assert node.kind.isExpression();
    resolve(node, null);
    checkIsType(node);
  }

  void resolveAsParameterizedType(Node node) {
    resolveAsType(node);
    checkIsParameterized(node);
  }

  void resolveAsParameterizedExpression(Node node) {
    assert node.kind.isExpression();
    resolve(node, null);
    checkIsInstance(node);
    checkIsParameterized(node);
  }

  void resolveAsParameterizedExpressionWithTypeContext(Node node, Type type) {
    assert node.kind.isExpression();
    resolve(node, type);
    checkIsInstance(node);
    checkIsParameterized(node);
  }

  void resolveAsParamterizedExpressionWithConversion(Node node, Type type, CastKind kind) {
    assert node.kind.isExpression();
    resolve(node, type);
    checkIsInstance(node);
    checkIsParameterized(node);
    if (type != null) checkConversion(type, node, kind);
  }

  void resolveNodes(List<Node> nodes) {
    for (var i = 0; i < nodes.size(); i++) {
      resolve(nodes[i], null);
    }
  }

  void resolveNodesAsExpressions(List<Node> nodes) {
    for (var i = 0; i < nodes.size(); i++) {
      resolveAsParameterizedExpression(nodes[i]);
    }
  }

  void resolveNodesAsVariableTypes(List<Node> nodes) {
    for (var i = 0; i < nodes.size(); i++) {
      Node node = nodes[i];
      resolveAsParameterizedType(node);
      checkIsValidVariableType(node);
    }
  }

  void resolveChildren(Node node) {
    if (node.hasChildren()) {
      resolveNodes(node.children);
    }
  }

  void resolveProgram(Node node) {
    assert node.parent == null;
    resolveChildren(node);
  }

  void resolveFile(Node node) {
    assert node.parent != null;
    assert node.parent.kind == .PROGRAM;
    resolve(node.fileBlock(), null);
  }

  void resolveBlock(Node node) {
    resolveChildren(node);

    // Remove asserts here since they will all be in blocks. Each assert should
    // still be resolved to check for compile errors, however.
    var statements = node.blockStatements();
    for (var i = 0; i < statements.size(); i++) {
      var child = statements[i];
      var kind = child.kind;
      if (kind == .ASSERT_CONST || kind == .ASSERT && options.removeAsserts) {
        node.removeChildAtIndex(i);
        i--;
      }
    }
  }

  void resolveCase(Node node) {
    assert node.parent != null;
    assert node.parent.kind == .SWITCH;
    assert context.switchValue != null;
    assert context.switchValue.type != null;
    var values = node.caseValues();
    var block = node.caseBlock();
    for (var i = 0; i < values.size(); i++) {
      var value = values[i];
      resolveAsParamterizedExpressionWithConversion(value, context.switchValue.type, .IMPLICIT_CAST);
      constantFolder.foldConstants(value);

      // All case values must be constants but can include enum values
      if (!value.type.isIgnored(cache) && !value.kind.isConstant()) {
        semanticErrorNonConstantCaseValue(log, value.range);
        value.type = cache.errorType;
      }
    }
    resolve(block, null);
  }

  void resolveUsing(Node node) {
    checkInsideBlock(node);
  }

  void resolveNamespace(Node node) {
    checkDeclarationLocation(node, .ALLOW_TOP_LEVEL);
    if (node.symbol != null) {
      initializeSymbol(node.symbol);
    }
    resolve(node.declarationBlock(), null);
  }

  void resolveEnum(Node node) {
    checkDeclarationLocation(node, .ALLOW_TOP_LEVEL);
    initializeSymbol(node.symbol);
    resolve(node.declarationBlock(), null);
  }

  void resolveObject(Node node) {
    checkDeclarationLocation(node, .ALLOW_TOP_LEVEL);
    initializeSymbol(node.symbol);

    // Force the resolution of all base type members in case some of them are
    // still unmerged. If this is not done for each object type, then some
    // conflicts will remain undetected until used:
    //
    //   interface Foo { bool foo(); }
    //   interface Bar { int foo(); }
    //   interface Baz : Foo, Bar {}
    //
    var members = node.symbol.type.sortedMembers();
    for (var i = 0; i < members.size(); i++) {
      var member = members[i];
      if (member.symbol.kind == .UNMERGED) {
        initializeMember(member);
      }
    }

    var oldSymbolForThis = context.symbolForThis;
    context.symbolForThis = node.symbol;

    // Ensure the default constructor is generated if needed
    var constructor = node.symbol.type.constructor();
    if (constructor != null) {
      initializeMember(constructor);
    }

    resolve(node.declarationBlock(), null);
    context.symbolForThis = oldSymbolForThis;
  }

  void resolveExtension(Node node) {
    checkDeclarationLocation(node, .ALLOW_TOP_LEVEL);
    initializeSymbol(node.symbol);

    var oldSymbolForThis = context.symbolForThis;
    if (node.symbol.kind.isTypeWithInstances()) {
      context.symbolForThis = node.symbol;
    }
    resolve(node.declarationBlock(), null);
    context.symbolForThis = oldSymbolForThis;
  }

  void resolveFunction(Node node) {
    var symbol = node.symbol;

    // Sanity check
    assert symbol.enclosingSymbol == null || !symbol.enclosingSymbol.kind.isTypeWithInstances() ||
      context.symbolForThis != null && context.symbolForThis == symbol.enclosingSymbol;

    checkDeclarationLocation(node, .ALLOW_TOP_OR_OBJECT_LEVEL);
    initializeSymbol(symbol);

    var oldFunctionSymbol = context.functionSymbol;
    context.functionSymbol = symbol;

    // Resolve the function block
    var block = node.functionBlock();
    if (block != null) {
      var oldResultType = resultType;

      // Imported functions cannot have an implementation
      if (symbol.isImport()) {
        semanticErrorCannotImplementImportedFunction(log, block.range);
      }

      // Special-case the return type of constructors to void for the purpose
      // of type conversions in return statements inside the constructor
      if (symbol.type.isIgnored(cache)) resultType = cache.errorType;
      else if (symbol.kind == .CONSTRUCTOR_FUNCTION) resultType = cache.voidType;
      else resultType = symbol.type.resultType();
      resolve(block, null);

      // Missing a return statement is an error
      if (!resultType.isIgnored(cache) && !resultType.isVoid(cache) && !block.blockAlwaysEndsWithReturn()) {
        semanticErrorMissingReturn(log, node.declarationName().range, symbol.name, resultType);
      }

      resultType = oldResultType;
    }

    // All abstract functions must be virtual
    else if (!symbol.isImport() && !symbol.isVirtual()) {
      if (symbol.kind == .INSTANCE_FUNCTION) {
        semanticErrorFunctionMustBeAbstract(log, node.declarationName().range);
      } else if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
        semanticErrorUnimplementedConstructor(log, node.declarationName().range);
      } else {
        semanticErrorUnimplementedFunction(log, node.declarationName().range);
      }
    }

    // Resolve the initializer list
    if (node.kind == .CONSTRUCTOR) {
      // Get the base constructor type
      var overriddenMember = symbol.overriddenMember;
      var overriddenType = cache.errorType;
      if (overriddenMember != null) {
        initializeMember(overriddenMember);
        overriddenType = overriddenMember.type;
      }

      // Resolve the super initializer
      var superInitializer = node.superInitializer();
      if (superInitializer != null) {
        if (overriddenMember != null) {
          superInitializer.symbol = overriddenMember.symbol;
        } else {
          semanticErrorBadSuperInitializer(log, superInitializer.range);
        }

        // Resolve the arguments
        var arguments = superInitializer.superCallArguments();
        if (overriddenType.isIgnored(cache)) {
          resolveNodesAsExpressions(arguments);
        } else {
          assert overriddenType.isFunction();
          resolveArguments(arguments, overriddenType.argumentTypes(), superInitializer.range, superInitializer.range);
        }
      }

      // Automatically insert a call to the base constructor if possible
      else if (overriddenType.isFunction()) {
        if (overriddenType.argumentTypes().size() > 0) {
          semanticErrorMissingSuperInitializer(log, node.declarationName().range);
        } else {
          node.replaceChild(3, Node.createSuperCall([]).withSymbol(overriddenMember.symbol));
        }
      }

      // Ensure the member initializer list exists
      var memberInitializers = node.memberInitializers();
      if (memberInitializers == null) {
        memberInitializers = Node.createNodeList([]);
        node.replaceChild(4, memberInitializers);
      }

      // Abstract constructors cannot have initializer lists
      if ((superInitializer != null || memberInitializers.children.size() > 0) && block == null) {
        semanticErrorAbstractConstructorInitializer(log, Range.span(
          (superInitializer != null ? superInitializer : memberInitializers.children[0]).range,
          (memberInitializers.children.size() < 1 ? superInitializer : memberInitializers.lastChild()).range));
      }

      // Move the initial values for all member variables to initializers. The
      // order isn't guaranteed here because extension blocks can add member
      // variables as long as they are initialized, but those are unordered.
      var enclosingSymbol = symbol.enclosingSymbol;
      if (!enclosingSymbol.isImport()) {
        var members = enclosingSymbol.type.sortedMembers();
        var index = 0;
        for (var i = 0; i < members.size(); i++) {
          var member = members[i];
          var memberSymbol = member.symbol;
          if (memberSymbol.kind == .INSTANCE_VARIABLE && memberSymbol.enclosingSymbol == enclosingSymbol) {
            var value = memberSymbol.node.variableValue();
            if (value != null) {
              initializeMember(member);

              // Resolve the value in the context of the object
              var oldScope = context.scope;
              context.scope = node.scope.lexicalParent;
              context.functionSymbol = null;
              resolve(memberSymbol.node, null);
              context.functionSymbol = symbol;
              context.scope = oldScope;

              // Move the value from the variable to a member initializer
              memberInitializers.insertChild(index, Node.createMemberInitializer(
                Node.createName(memberSymbol.name).withSymbol(memberSymbol).withType(member.type), value.replaceWith(null)));
              index++;
            }

            // Automatically add an initializer if one is missing
            else {
              int j;
              for (j = 0; j < memberInitializers.children.size(); j++) {
                if (memberInitializers.children[j].memberInitializerName().asString() == memberSymbol.name) {
                  break;
                }
              }
              if (j == memberInitializers.children.size()) {
                initializeMember(member);
                memberInitializers.insertChild(index, Node.createMemberInitializer(
                  Node.createName(memberSymbol.name).withSymbol(memberSymbol).withType(member.type),
                  createDefaultValue(member.type, memberSymbol.node.declarationName().range)));
                index++;
              }
            }
          }
        }
      }

      // Resolve the member initializers
      for (var i = 0; i < memberInitializers.children.size(); i++) {
        var memberInitializer = memberInitializers.children[i];
        var name = memberInitializer.memberInitializerName();
        var value = memberInitializer.memberInitializerValue();

        // Avoid the function arguments when looking up member initializer
        // names. This allows function arguments to have the same name as a
        // member initializer without a conflict:
        //
        //   class Foo {
        //     int foo;
        //     new(int foo) : foo = foo {}
        //   }
        //
        var oldScope = context.scope;
        context.scope = node.scope.lexicalParent;
        resolve(name, null);
        context.scope = oldScope;
        memberInitializer.symbol = name.symbol;

        // Resolve the value and check for duplicate initializations
        if (name.symbol != null) {
          resolveAsParamterizedExpressionWithConversion(value, name.symbol.type, .IMPLICIT_CAST);
          for (var j = 0; j < i; j++) {
            var other = memberInitializers.children[j];
            if (other.memberInitializerName().symbol == name.symbol) {
              semanticErrorAlreadyInitialized(log, value.range, name.symbol.name, other.memberInitializerValue().range);
              break;
            }
          }
        } else {
          resolveAsParameterizedExpression(value);
        }
      }
    }

    context.functionSymbol = oldFunctionSymbol;
  }

  // A pure value is one guaranteed to have no side effects
  bool isPureValue(Node node) {
    var kind = node.kind;

    // Treat errors as pure to avoid further errors
    if (node.type.isIgnored(cache)) {
      return true;
    }

    // List literals are only pure if their elements are pure
    if (kind == .LIST) {
      if (node.hasChildren()) {
        for (var i = 0; i < node.children.size(); i++) {
          if (!isPureValue(node.children[i])) {
            return false;
          }
        }
      }
      return true;
    }

    // Calls are pure if the function and all arguments are pure
    if (kind == .CALL) {
      var value = node.callValue();
      var arguments = node.callArguments();
      if (value.kind != .TYPE || !node.symbol.isPure()) {
        return false;
      }
      for (var i = 0; i < arguments.size(); i++) {
        if (!isPureValue(arguments[i])) {
          return false;
        }
      }
      return true;
    }

    // Casts are pure if the casted value is pure
    if (kind.isCast()) {
      return isPureValue(node.castValue());
    }

    // Literals are always pure
    return kind.isConstant();
  }

  void resolveVariable(Node node) {
    var symbol = node.symbol;
    initializeSymbol(symbol);
    var value = node.variableValue();

    // Prevent instance variables inside interfaces. Also prevent instance
    // variables without initial values in extension blocks because default
    // constructors need to order their arguments.
    var enclosingSymbol = symbol.enclosingSymbol;
    if (!symbol.isStatic() && enclosingSymbol != null) {
      var enclosingSymbolType = enclosingSymbol.type;
      if (enclosingSymbolType.isInterface() || symbol.isFromExtension() && enclosingSymbolType.isEnum()) {
        unexpectedStatement(node);
      } else if (symbol.isFromExtension() && enclosingSymbol.kind.isTypeWithInstances() && value == null) {
        semanticErrorUninitializedExtensionVariable(log, node.declarationName().range);
      }
    }

    // Enum values are resolved as ints instead of as the enum type because ints
    // don't implicitly convert to enums.
    if (value != null) {
      resolveAsParamterizedExpressionWithConversion(value, symbol.isEnumValue() ? cache.intType : symbol.type, .IMPLICIT_CAST);

      // Global variables must be initialized to a value without side effects
      // since that ensures there aren't any initialization ordering issues
      if (symbol.kind == .GLOBAL_VARIABLE) {
        constantFolder.foldConstants(value);
        if (!isPureValue(value) && !symbol.type.isIgnored(cache)) {
          semanticErrorNonPureGlobalVariable(log, value.range);
          value.type = cache.errorType;
        }
      }
    }

    // Automatically initialize uninitialized variables to their default value
    else if (!symbol.type.isIgnored(cache) && node.parent.kind == .VARIABLE_CLUSTER && symbol.kind != .INSTANCE_VARIABLE) {
      node.replaceChild(2, createDefaultValue(symbol.type, node.declarationName().range).withType(symbol.type));
    }
  }

  void resolveVariableCluster(Node node) {
    var variables = node.clusterVariables();

    // This must not initialize node.clusterType() here for circular declaration
    // detection to work correctly ("foo foo;" is a circular declaration)
    resolveNodes(variables);

    // Some code emission targets require identical types for loop variables
    if (node.parent.kind == .FOR) {
      var first = variables[0].symbol;
      for (var i = 1; i < variables.size(); i++) {
        var current = variables[i].symbol;
        if (!first.type.isIgnored(cache) && !current.type.isIgnored(cache) && first.type != current.type) {
          semanticErrorForVariablesMustBeSameType(log, node.range, first.name, first.type, current.name, current.type);
          break;
        }
      }
    }
  }

  void resolveParameter(Node node) {
    initializeSymbol(node.symbol);
  }

  void resolveAlias(Node node) {
    checkInsideBlock(node);
    if (node.symbol != null) {
      initializeSymbol(node.symbol);
    }
  }

  void resolveIf(Node node) {
    checkStatementLocation(node);
    resolveAsParamterizedExpressionWithConversion(node.ifTest(), cache.boolType, .IMPLICIT_CAST);
    resolve(node.ifTrue(), null);
    if (node.ifFalse() != null) resolve(node.ifFalse(), null);
  }

  void resolveFor(Node node) {
    checkStatementLocation(node);
    var setup = node.forSetup();
    var test = node.forTest();
    var update = node.forUpdate();
    if (setup != null) {
      if (setup.kind == .VARIABLE_CLUSTER) {
        resolve(setup, null);
      } else {
        resolveAsParameterizedExpression(setup);
        checkUnusedExpression(setup);
      }
    }
    if (test != null) {
      resolveAsParamterizedExpressionWithConversion(test, cache.boolType, .IMPLICIT_CAST);
    }
    if (update != null) {
      resolveAsParameterizedExpression(update);
      checkUnusedExpression(update);
    }

    var oldLoop = context.loop;
    context.loop = node;
    resolve(node.forBlock(), null);
    context.loop = oldLoop;
  }

  void resolveForEach(Node node) {
    var value = node.forEachValue();
    checkStatementLocation(node);
    resolve(node.forEachVariable(), null);
    resolve(value, null);

    if (!value.type.isIgnored(cache)) {
      log.error(node.range, "TODO: implement for-each statement");
    }

    var oldLoop = context.loop;
    context.loop = node;
    resolve(node.forEachBlock(), null);
    context.loop = oldLoop;
  }

  void resolveWhile(Node node) {
    checkStatementLocation(node);
    var test = node.whileTest();
    if (test != null) resolveAsParamterizedExpressionWithConversion(test, cache.boolType, .IMPLICIT_CAST);

    var oldLoop = context.loop;
    context.loop = node;
    resolve(node.whileBlock(), null);
    context.loop = oldLoop;
  }

  void resolveReturn(Node node) {
    var value = node.returnValue();

    // Return statements must live inside functions
    if (resultType == null) {
      unexpectedStatement(node);
      if (value != null) resolveAsParameterizedExpression(value);
      return;
    }

    // Check the return value
    if (value != null) {
      resolveAsParamterizedExpressionWithConversion(value, resultType, .IMPLICIT_CAST);
    }

    // The return value may be missing only when the return type is void
    else if (!resultType.isIgnored(cache) && !resultType.isVoid(cache)) {
      semanticErrorExpectedReturnValue(log, node.range, resultType);
    }
  }

  void resolveBreak(Node node) {
    if (context.loop == null) {
      unexpectedStatement(node);
    }
  }

  void resolveContinue(Node node) {
    if (context.loop == null) {
      unexpectedStatement(node);
    }
  }

  void resolveAssert(Node node) {
    if (node.kind == .ASSERT) {
      checkStatementLocation(node);
    }
    var value = node.assertValue();
    resolveAsParamterizedExpressionWithConversion(value, cache.boolType, .IMPLICIT_CAST);

    // Constant asserts are evaluated at compile time
    if (node.kind == .ASSERT_CONST) {
      constantFolder.foldConstants(value);
      if (!value.type.isIgnored(cache)) {
        if (!value.kind.isConstant()) {
          semanticErrorNonConstantAssert(log, value.range);
        } else if (!value.isTrue()) {
          semanticErrorFalseAssert(log, value.range);
        }
      }
    }
  }

  void resolveExpression(Node node) {
    var value = node.expressionValue();
    if (value.kind != .ERROR) {
      checkStatementLocation(node);
    }
    resolveAsParameterizedExpression(value);
    checkUnusedExpression(value);
  }

  void resolveSwitch(Node node) {
    checkStatementLocation(node);
    var value = node.switchValue();
    var cases = node.switchCases();
    resolveAsParameterizedExpression(value);

    // Can only switch on integer types for now
    if (!value.type.isIgnored(cache) && !value.type.isInteger(cache)) {
      semanticErrorNonIntegerSwitch(log, value.range, value.type);
      value.type = cache.errorType;
    }

    var oldSwitchValue = context.switchValue;
    context.switchValue = value;
    resolveNodes(cases);
    context.switchValue = oldSwitchValue;

    List<Node> uniqueValues = [];
    for (var i = 0; i < cases.size(); i++) {
      var child = cases[i];

      // Require only one default case and make sure it's last. That way this
      // switch statement can be converted to an if-else chain without moving
      // the user's code around.
      if (child.children.size() == 1 && i < cases.size() - 1) {
        semanticErrorBadDefaultCase(log, child.range);
      }

      // Check previous values for duplicates
      var caseValues = child.caseValues();
      for (var j = 0; j < caseValues.size(); j++) {
        var caseValue = caseValues[j];
        if (caseValue.type.isIgnored(cache)) continue;
        assert caseValue.kind.isConstant();

        int k;
        for (k = 0; k < uniqueValues.size(); k++) {
          var original = uniqueValues[k];
          if (original.kind == caseValue.kind && Content.equal(original.content, caseValue.content)) {
            semanticErrorDuplicateCase(log, caseValue.range, original.range);
            break;
          }
        }

        if (k == uniqueValues.size()) {
          uniqueValues.push(caseValue);
        }
      }
    }
  }

  void resolveModifier(Node node) {
    resolveNodes(node.modifierStatements());
  }

  void resolveName(Node node) {
    var name = node.asString();
    var member = context.scope.find(name);
    if (member == null) {
      semanticErrorUndeclaredSymbol(log, node.range, name);
      return;
    }
    initializePotentiallyDuplicatedMember(member, node.range);
    node.symbol = member.symbol;

    // Instance members inside an object must have access to "this"
    if (!checkAccessToInstanceSymbol(node)) {
      node.type = cache.errorType;
      return;
    }

    // Wrap type symbols in a type node to distinguish them from instances
    if (member.symbol.kind.isType()) {
      node.become(Node.createType(member.type).withRange(node.range).withSymbol(member.symbol));
      return;
    }

    node.type = member.type;
  }

  void resolveThis(Node node) {
    if (checkAccessToThis(node.range)) {
      assert context.symbolForThis != null;
      var symbol = context.symbolForThis;
      initializeSymbol(symbol);
      node.symbol = symbol;
      node.type = cache.ensureTypeIsParameterized(symbol.type);
    }
  }

  void resolveHook(Node node) {
    var trueNode = node.hookTrue();
    var falseNode = node.hookFalse();
    resolveAsParamterizedExpressionWithConversion(node.hookTest(), cache.boolType, .IMPLICIT_CAST);

    // Resolve both branches with type context but don't warn about type
    // conversion problems yet (warning later gives better error messages)
    resolveAsParameterizedExpressionWithTypeContext(trueNode, typeContext);
    resolveAsParameterizedExpressionWithTypeContext(falseNode, typeContext);

    // Avoid reporting further errors
    var trueType = trueNode.type;
    var falseType = falseNode.type;
    if (trueType.isIgnored(cache) || falseType.isIgnored(cache)) {
      return;
    }

    // Ensure both branches can implicitly convert to a common type
    var commonType = cache.commonImplicitType(trueType, falseType);
    if (commonType == null) {

      // As a fallback, try to disambiguate by how the result will be used
      commonType = typeContext;
      if (commonType == null || !cache.canImplicitlyConvert(trueType, commonType) || !cache.canImplicitlyConvert(falseType, commonType)) {
        semanticErrorNoCommonType(log, Range.span(trueNode.range, falseNode.range), trueType, falseType);
        return;
      }
    }

    // Make sure "a ? .FOO : 0" works for an enum flags type
    else if (commonType == cache.intType && typeContext != null && typeContext.isEnumFlags()) {
      commonType = typeContext;
    }

    // Finally, check that the conversion works. This check must be done
    // even when using the common type because it inserts implicit casts.
    checkConversion(commonType, trueNode, .IMPLICIT_CAST);
    checkConversion(commonType, falseNode, .IMPLICIT_CAST);
    node.type = commonType;
  }

  void resolveInt(Node node) {
    node.type = cache.intType;
  }

  void resolveList(Node node) {
    var values = node.listValues();

    // Avoid reporting further errors
    if (typeContext != null && typeContext.isIgnored(cache)) {
      resolveNodesAsExpressions(values);
      return;
    }

    // The type of the literal comes from how it's used
    if (typeContext != null && typeContext.isList(cache)) {
      var itemType = typeContext.substitutions[0];
      for (var i = 0; i < values.size(); i++) {
        resolveAsParamterizedExpressionWithConversion(values[i], itemType, .IMPLICIT_CAST);
      }
      node.type = typeContext;
      return;
    }

    // Try to infer the type
    Type commonType;
    for (var i = 0; i < values.size(); i++) {
      var value = values[i];
      resolveAsParameterizedExpression(value);
      if (commonType == null || value.type.isIgnored(cache)) {
        commonType = value.type;
      } else if (!commonType.isIgnored(cache)) {
        commonType = cache.commonImplicitType(commonType, value.type);
        if (commonType == null) {
          semanticErrorListTypeInferenceFailed(log, node.range);
          commonType = cache.errorType;
        }
      }
    }

    // Avoid reporting further errors
    if (commonType != null && commonType.isIgnored(cache)) {
      return;
    }

    // Make sure an empty list literal without type context is an error
    if (commonType == null) {
      semanticErrorListTypeInferenceFailed(log, node.range);
      return;
    }

    // Finally, set the type of the list
    node.type = cache.parameterize(cache.listType, [commonType]);
  }

  void resolveDot(Node node) {
    var target = node.dotTarget();
    var dotName = node.dotName();

    // The target may be null, which means to use the type context instead
    if (target != null) {
      resolve(target, null);
    }

    // Avoid reporting further errors
    var type = target != null ? target.type : typeContext;
    if (type == null) {
      semanticErrorMissingTypeContext(log, node.range);
      return;
    }
    if (type.isIgnored(cache)) {
      return;
    }

    // The "->" and "::" tokens should only be used inside a quoted expression
    if (node.kind == .DOT_ARROW || node.kind == .DOT_COLON) {
      semanticErrorBadDotToken(log, target != null ? dotName != null
        ? Range.inner(target.range, dotName.range)
        : Range.after(node.range, target.range) : dotName != null
        ? Range.before(node.range, dotName.range)
        : node.range);
      node.kind = .DOT;
    }

    // The name allowed to be null for autocomplete
    if (dotName == null) {
      return;
    }

    // The name is allowed to be quoted
    if (dotName.kind == .QUOTED) {
      return;
    }

    var name = dotName.asString();

    // Search for the member symbol
    var member = type.findMember(name);
    if (member == null) {
      semanticErrorUnknownMemberSymbol(log, dotName.range, name, type);
      return;
    }
    node.symbol = member.symbol;
    dotName.symbol = member.symbol;
    initializePotentiallyDuplicatedMember(member, dotName.range);

    // Check the instance/static status of the member
    var symbolIsType = member.symbol.kind.isType();
    var targetIsType = target == null || target.kind.isType();
    if (!type.isNamespace()) {
      var isStatic = symbolIsType || member.symbol.isStatic();

      // Static members can only be accessed from a type
      if (isStatic && !targetIsType) {
        semanticErrorMemberUnexpectedStatic(log, dotName.range, name);
      }

      // Instance members can only be accessed from an instance
      else if (!isStatic && targetIsType) {
        semanticErrorMemberUnexpectedInstance(log, dotName.range, name);
      }
    }

    // Update this node using the member member
    if (symbolIsType) {
      node.become(Node.createType(member.type).withRange(node.range).withSymbol(member.symbol));
    } else if (targetIsType) {
      node.become(Node.createName(member.symbol.name).withRange(node.range).withSymbol(member.symbol).withType(member.type));
    } else {
      node.type = member.type;
      dotName.type = member.type;
    }
  }

  void resolveCall(Node node) {
    var value = node.callValue();
    var arguments = node.callArguments();

    assert value.kind.isExpression();
    resolve(value, null);
    checkIsParameterized(value);
    var valueType = value.type;

    // Avoid reporting further errors
    if (valueType.isIgnored(cache)) {
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Types are constructed by calling the type, which forwards to the constructor
    if (value.kind.isType()) {
      var member = valueType.constructor();
      if (member == null) {
        semanticErrorUnconstructableType(log, value.range, valueType);
        resolveNodesAsExpressions(arguments);
        return;
      }
      initializeMember(member);

      // Cannot instantiate abstract types
      if (valueType.symbol.isAbstract()) {
        var reason = valueType.symbol.reasonForAbstract;
        semanticErrorAbstractNew(log, value.range, valueType, reason.node.declarationName().range, reason.fullName());
        resolveNodesAsExpressions(arguments);
        return;
      }

      node.symbol = member.symbol;
      valueType = member.type;

      // Avoid reporting further errors
      if (valueType.isIgnored(cache)) {
        resolveNodesAsExpressions(arguments);
        return;
      }
    }

    // Can only call an instance of a function type
    if (!valueType.isFunction()) {
      semanticErrorInvalidCall(log, value.range, valueType);
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Set the result type now even if the arguments are incorrect
    node.type = valueType.resultType();
    resolveArguments(arguments, valueType.argumentTypes(), node.range, value.range);
  }

  void resolveSuperCall(Node node) {
    var arguments = node.superCallArguments();

    // Make sure a super call even makes sense here
    if (context.functionSymbol == null ||
        !context.functionSymbol.isObjectMember() ||
        context.functionSymbol.overriddenMember == null ||
        context.functionSymbol.kind == .CONSTRUCTOR_FUNCTION) {
      semanticErrorBadSuperCall(log, node.range);
      resolveNodesAsExpressions(arguments);
    }

    else {
      var member = context.functionSymbol.overriddenMember;
      initializeMember(member);

      // Avoid reporting further errors
      var type = member.type;
      if (type.isIgnored(cache) || !type.isFunction()) {
        resolveNodesAsExpressions(arguments);
        return;
      }

      // Super calls are statically resolved, so the symbol must not be abstract
      if (member.symbol.node.functionBlock() == null) {
        semanticErrorAbstractSuperCall(log, node.range, member.symbol.node.declarationName().range);
        resolveNodesAsExpressions(arguments);
        return;
      }

      // Store the overridden symbol for reference during emission
      resolveArguments(arguments, type.argumentTypes(), node.range, node.range);
      node.symbol = member.symbol;
      node.type = type.resultType();
    }
  }

  void resolveSequence(Node node) {
    var values = node.sequenceValues();
    for (var i = 0, n = values.size(); i < n; i++) {
      var child = values[i];
      if (i < n - 1) {
        resolveAsParameterizedExpression(child);
        checkUnusedExpression(child);
      } else {
        resolveAsParamterizedExpressionWithConversion(child, typeContext, node.parent.kind == .CAST ? .EXPLICIT_CAST : .IMPLICIT_CAST);
      }
    }
  }

  void resolveParameterize(Node node) {
    var value = node.parameterizeValue();
    var substitutions = node.parameterizeTypes();
    resolve(value, null);
    resolveNodesAsVariableTypes(substitutions);

    // Avoid reporting further errors
    var unparameterized = value.type;
    if (unparameterized.isIgnored(cache)) {
      return;
    }

    // Check that the type is parameterizable
    if (!unparameterized.hasParameters() || unparameterized.isParameterized()) {
      semanticErrorCannotParameterize(log, value.range, unparameterized);
      return;
    }

    // Validate the type parameter count
    var parameters = unparameterized.symbol.parameters;
    var sortedParameters = unparameterized.symbol.sortedParameters;
    if (parameters.size() != substitutions.size()) {
      semanticErrorParameterCount(log, Range.after(node.range, value.range), parameters.size(), substitutions.size());
      return;
    }
    assert parameters.size() == sortedParameters.size();

    // Fill in the type parameters, which must be done in order of dependencies
    // to dependents. Type parameters aren't allowed to form cycles but they
    // can still form a DAG of dependencies.
    List<Type> sortedTypes = [];
    for (var i = 0; i < sortedParameters.size(); i++) {
      var parameter = sortedParameters[i];
      var index = parameters.indexOf(parameter);
      var substitution = substitutions[index];
      if (parameter.type.isIgnored(cache)) return;
      var bound = parameter.type.bound();
      if (bound != null) {
        if (i > 0) bound = cache.substitute(bound, sortedParameters.slice(0, i), sortedTypes.slice(0, i));
        checkConversion(bound, substitution, .IMPLICIT_CAST);
      }
      if (substitution.type.isIgnored(cache)) return;
      sortedTypes.push(substitution.type);
    }

    // Only parameterize the type if no errors were found in the type parameters
    List<Type> types = [];
    for (var i = 0; i < substitutions.size(); i++) {
      types.push(substitutions[i].type);
    }
    var parameterized = cache.parameterize(unparameterized, types);
    node.become(value.kind.isType()
      ? Node.createType(parameterized).withRange(node.range).withSymbol(value.symbol)
      : value.replaceWith(null).withRange(node.range).withType(parameterized));
  }

  void resolveCast(Node node) {
    var type = node.castType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    resolveAsParamterizedExpressionWithConversion(node.castValue(), type.type, .EXPLICIT_CAST);
    node.type = type.type;
  }

  static void collectReturnStatements(Node node, List<Node> returnStatements) {
    if (node.kind == .RETURN) {
      returnStatements.push(node);
    }

    else if (node.hasChildren()) {
      for (var i = 0; i < node.children.size(); i++) {
        var child = node.children[i];
        if (child != null) {
          collectReturnStatements(child, returnStatements);
        }
      }
    }
  }

  void traverseQuotedContent(Node node) {
    // Nested quotes can be used to get typing back
    if (node.kind == .QUOTED) {
      var value = node.quotedValue();
      resolve(value, null);
      node.become(value);
      return;
    }

    // Recursively mark everything with the error type
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.size(); i++) {
        var child = node.children[i];
        if (child != null) {
          traverseQuotedContent(child);
        }
      }
    }

    node.type = cache.errorType;
  }

  void resolveQuoted(Node node) {
    traverseQuotedContent(node.quotedValue());
  }

  void resolveVar(Node node) {
    semanticErrorUnexpectedNode(log, node.range, node.kind);
  }

  void resolveUnary(Node node) {
    var kind = node.kind;
    var value = node.unaryValue();

    // Make sure enum flags type context transfers into the value
    if (kind == .COMPLEMENT && typeContext != null && typeContext.isEnumFlags()) {
      resolveAsParameterizedExpressionWithTypeContext(value, typeContext);
    } else {
      resolveAsParameterizedExpression(value);
    }

    // Avoid reporting further errors
    var type = value.type;
    if (type.isIgnored(cache)) {
      return;
    }

    if (kind == .POSITIVE || kind == .NEGATIVE) {
      if (type.isEnum()) {
        node.type = cache.intType;
      } else if (type.isNumeric(cache)) {
        node.type = type;
      }
    }

    else if (kind.isUnaryStorageOperator()) {
      checkStorageOperator(node);
      if (!type.isEnum() && type.isNumeric(cache)) {
        checkStorage(value);
        node.type = type;
      }
    }

    else if (kind == .NOT) {
      if (type.isBool(cache)) {
        node.type = type;
      }
    }

    else if (kind == .COMPLEMENT) {
      if (type.isEnumFlags()) {
        node.type = type;
      } else if (type.isInteger(cache)) {
        node.type = cache.intType;
      }
    }

    // Fall back to user operators if nothing matched
    if (node.type.isIgnored(cache)) {
      checkForOperatorOverload(node);
    }

    // Insert an implicit cast if necessary
    else {
      checkConversion(node.type, value, .IMPLICIT_CAST);
    }
  }

  bool wrapWithToStringCall(Node node) {
    if (node.type.isIgnored(cache)) {
      return false;
    }
    var toString = node.type.findMember("toString");
    if (toString == null) {
      semanticErrorMissingToString(log, node.range, node.type);
      return false;
    }

    initializeMember(toString);
    if (toString.type.isIgnored(cache)) {
      return false;
    }

    if (toString.type != cache.toStringType) {
      semanticErrorToStringWrongType(log, node.range, cache.toStringType, toString.type, toString.symbol.node.declarationName().range);
      return false;
    }

    var children = node.removeChildren();
    var name = Node.createName("toString");
    var target = Node.createDot(node.clone().withChildren(children), name);
    var call = Node.createCall(target, []);
    name.symbol = toString.symbol;
    target.symbol = toString.symbol;
    target.type = cache.toStringType;
    call.type = cache.stringType;
    node.become(call);
    return true;
  }

  void resolveWithTypeContextTransfer(Node left, Node right) {
    if (!needsTypeContext(left)) {
      resolveAsParameterizedExpression(left);
      resolveAsParameterizedExpressionWithTypeContext(right, left.type);
    } else if (!needsTypeContext(right)) {
      resolveAsParameterizedExpression(right);
      resolveAsParameterizedExpressionWithTypeContext(left, right.type);
    }
  }

  void resolveBinary(Node node) {
    var kind = node.kind;
    var left = node.binaryLeft();
    var right = node.binaryRight();

    // Special-case assignment logic
    if (kind.isBinaryStorageOperator()) {
      resolveAsParameterizedExpression(left);
      if (!left.type.isIgnored(cache)) {
        checkStorageOperator(node);
      }

      if (kind == .ASSIGN || left.type.isInteger(cache) || left.type.isNumeric(cache) && !kind.isBinaryBitwiseStorageOperator()) {
        resolveAsParamterizedExpressionWithConversion(right, left.type, .IMPLICIT_CAST);
        checkStorage(left);
        node.type = left.type;
        return;
      }

      else if (kind == .ASSIGN_ADD && left.type.isString(cache)) {
        resolveAsParameterizedExpression(right);
        if (!right.type.isString(cache)) {
          wrapWithToStringCall(right);
        }
        checkStorage(left);
        node.type = left.type;
        return;
      }
    }

    // Special-case equality comparisons and relational operators on enum types
    // to transfer type context from left to right or right to left
    else if (kind == .EQUAL || kind == .NOT_EQUAL ||
        kind == .LESS_THAN || kind == .GREATER_THAN ||
        kind == .LESS_THAN_OR_EQUAL || kind == .GREATER_THAN_OR_EQUAL) {
      resolveWithTypeContextTransfer(left, right);
    }

    // Special-case bitwise operators on enum flags types
    else if (kind == .BITWISE_AND || kind == .BITWISE_OR || kind == .BITWISE_XOR) {
      if (typeContext != null && typeContext.isEnumFlags()) {
        resolveAsParameterizedExpressionWithTypeContext(left, typeContext);
        resolveAsParameterizedExpressionWithTypeContext(right, typeContext);
      } else {
        resolveWithTypeContextTransfer(left, right);
      }
    }

    // This won't resolve twice if the nodes were already resolved above
    resolveAsParameterizedExpression(left);
    resolveAsParameterizedExpression(right);

    // Avoid reporting further errors
    var leftType = left.type;
    var rightType = right.type;
    Type commonType = null;
    if (leftType.isIgnored(cache) || rightType.isIgnored(cache)) {
      return;
    }

    if (kind == .EQUAL || kind == .NOT_EQUAL) {
      commonType = cache.commonImplicitType(leftType, rightType);
      if (commonType != null) {
        node.type = cache.boolType;
      }
    }

    else if (kind == .ADD || kind == .SUBTRACT || kind == .MULTIPLY || kind == .DIVIDE) {
      if (leftType.isNumeric(cache) && rightType.isNumeric(cache)) {
        commonType = cache.commonImplicitType(leftType, rightType);
        if (commonType.isEnum()) {
          commonType = cache.intType;
        }
        node.type = commonType;
      }

      else if (kind == .ADD) {
        if (leftType.isString(cache) && rightType.isString(cache)) {
          commonType = cache.stringType;
          node.type = commonType;
        }

        else if (leftType.isString(cache)) {
          if (wrapWithToStringCall(right)) {
            commonType = cache.stringType;
            node.type = commonType;
          } else {
            return;
          }
        }

        else if (rightType.isString(cache)) {
          if (wrapWithToStringCall(left)) {
            commonType = cache.stringType;
            node.type = commonType;
          } else {
            return;
          }
        }
      }
    }

    else if (kind == .REMAINDER || kind == .SHIFT_LEFT || kind == .SHIFT_RIGHT) {
      if (leftType.isInteger(cache) && rightType.isInteger(cache)) {
        commonType = cache.intType;
        node.type = commonType;
      }
    }

    else if (kind == .BITWISE_AND || kind == .BITWISE_OR || kind == .BITWISE_XOR) {
      if (leftType == rightType && leftType.isEnumFlags()) {
        commonType = leftType;
        node.type = commonType;
      } else if (leftType.isInteger(cache) && rightType.isInteger(cache)) {
        commonType = cache.intType;
        node.type = commonType;
      }
    }

    else if (kind == .LOGICAL_AND || kind == .LOGICAL_OR) {
      if (leftType.isBool(cache) && rightType.isBool(cache)) {
        commonType = cache.boolType;
        node.type = commonType;
      }
    }

    else if (kind == .LESS_THAN || kind == .GREATER_THAN || kind == .LESS_THAN_OR_EQUAL || kind == .GREATER_THAN_OR_EQUAL) {
      if (leftType.isNumeric(cache) && rightType.isNumeric(cache) ||
          leftType.isString(cache) && rightType.isString(cache)) {
        commonType = cache.commonImplicitType(leftType, rightType);
        node.type = cache.boolType;
      }
    }

    // Fall back to user operators if nothing matched
    if (node.type.isIgnored(cache)) {
      checkForOperatorOverload(node);
    }

    // Insert implicit casts if necessary
    else if (commonType != null) {
      checkConversion(commonType, left, .IMPLICIT_CAST);
      checkConversion(commonType, right, .IMPLICIT_CAST);
    }
  }

  void resolveTernary(Node node) {
    var left = node.ternaryLeft();
    var middle = node.ternaryMiddle();
    var right = node.ternaryRight();

    resolveAsParameterizedExpression(left);
    resolveAsParameterizedExpression(middle);
    resolveAsParameterizedExpression(right);
    checkForOperatorOverload(node);
  }

  MatchKind assessOperatorOverloadMatch(List<Type> nodeTypes, List<Type> argumentTypes) {
    assert nodeTypes.size() == 1 + argumentTypes.size();
    var foundImplicitConversion = false;

    for (var i = 0; i < argumentTypes.size(); i++) {
      var a = nodeTypes[i + 1];
      var b = argumentTypes[i];
      if (a != b) {
        if (cache.canImplicitlyConvert(a, b)) {
          foundImplicitConversion = true;
        } else {
          return .NONE;
        }
      }
    }

    return foundImplicitConversion ? .INEXACT : .EXACT;
  }

  void applyOperatorOverload(Node node, Member member) {
    var symbol = member.symbol;
    var argumentTypes = member.type.argumentTypes();
    var children = node.removeChildren();

    // Reverse operand order for the "in" operator
    if (node.kind == .IN) {
      children.reverse();
    }

    var dotTarget = children[0];
    var dotName = Node.createName(symbol.name).withSymbol(symbol).withType(member.type);
    var value = Node.createDot(dotTarget, dotName).withSymbol(symbol).withType(member.type);
    List<Node> arguments = [];

    for (var i = 0; i < argumentTypes.size(); i++) {
      var argument = children[i + 1];
      checkConversion(argumentTypes[i], argument, .IMPLICIT_CAST);
      arguments.push(argument);
    }

    node.become(Node.createCall(value, arguments).withRange(node.range).withType(member.type.resultType()));
  }

  void checkForOperatorOverload(Node node) {
    var children = node.children;
    List<Type> types = [];

    // Check argument types and only proceed if all types are present
    for (var i = 0; i < children.size(); i++) {
      var type = children[i].type;
      if (type.isIgnored(cache)) {
        return;
      }
      types.push(type);
    }

    // Use the compare operator for relational operators
    var kind = node.kind;
    if (kind == .LESS_THAN || kind == .LESS_THAN_OR_EQUAL ||
        kind == .GREATER_THAN || kind == .GREATER_THAN_OR_EQUAL) {
      kind = .COMPARE;
    }

    // Reverse operand order for the "in" operator
    var typeForMatching = types;
    if (kind == .IN) {
      typeForMatching = types.clone();
      typeForMatching.reverse();
    }

    // The value for "this" determines the operator overload set to search
    var targetType = typeForMatching[0];
    if (targetType.symbol == null) {
      semanticErrorNoMatchingOperator(log, node.range, node.kind, types);
      return;
    }
    var overloads = targetType.symbol.operatorOverloadsForKind(kind);
    MatchKind bestMatch = .INEXACT;
    List<Member> matches = [];
    Member first = null;

    // Pick the best overload
    for (var i = 0; i < overloads.size(); i++) {
      var overload = overloads[i];
      assert overload.type.isFunction();
      assert overload.type.argumentTypes().size() + 1 == children.size();
      var member = targetType.findOperatorOverload(overload);
      initializeMember(member);
      assert member.type.isFunction();
      var match = assessOperatorOverloadMatch(typeForMatching, member.type.argumentTypes());
      if (match > bestMatch) {
        bestMatch = match;
        matches = [member];
      } else if (match == bestMatch) {
        matches.push(member);
      }
      if (i == 0) {
        first = member;
      }
    }

    // If there are no matches but one overload, then use that overload anyway
    // to prefer type mismatch errors instead of operator overload errors
    if (matches.size() == 0 && overloads.size() == 1) {
      matches.push(first);
    }

    // Fail if no matches
    if (matches.size() == 0) {
      semanticErrorNoMatchingOperator(log, node.range, node.kind, types);
    }

    // Fail if multiple matches
    else if (matches.size() > 1) {
      List<string> names = [];
      for (var i = 0; i < matches.size(); i++) {
        names.push(matches[i].symbol.fullName());
      }
      semanticErrorAmbiguousOperator(log, node.range, node.kind, names);
    }

    // Apply the match
    else {
      var originalKind = node.kind;
      applyOperatorOverload(node, matches[0]);

      // Wrap comparisons with a relational operator
      if (kind == .COMPARE) {
        var children = node.removeChildren();
        var clone = node.clone().withChildren(children);
        node.become(Node.createBinary(originalKind, clone, Node.createInt(0).withType(cache.intType)).withType(cache.boolType));
      }
    }
  }
}

void createNameToSymbolFlag() {
  if (nameToSymbolFlag != null) return;
  nameToSymbolFlag = StringMap<SymbolFlag>();
  nameToSymbolFlag["const"] = SymbolFlag.CONST;
  nameToSymbolFlag["export"] = SymbolFlag.EXPORT;
  nameToSymbolFlag["final"] = SymbolFlag.FINAL;
  nameToSymbolFlag["import"] = SymbolFlag.IMPORT;
  nameToSymbolFlag["inline"] = SymbolFlag.INLINE;
  nameToSymbolFlag["override"] = SymbolFlag.OVERRIDE;
  nameToSymbolFlag["private"] = SymbolFlag.PRIVATE;
  nameToSymbolFlag["protected"] = SymbolFlag.PROTECTED;
  nameToSymbolFlag["public"] = SymbolFlag.PUBLIC;
  nameToSymbolFlag["static"] = SymbolFlag.STATIC;
  nameToSymbolFlag["virtual"] = SymbolFlag.VIRTUAL;
}

void createSymbolFlagToName() {
  if (symbolFlagToName != null) return;
  symbolFlagToName = IntMap<string>();
  symbolFlagToName[SymbolFlag.CONST] = "const";
  symbolFlagToName[SymbolFlag.EXPORT] = "export";
  symbolFlagToName[SymbolFlag.FINAL] = "final";
  symbolFlagToName[SymbolFlag.IMPORT] = "import";
  symbolFlagToName[SymbolFlag.INLINE] = "inline";
  symbolFlagToName[SymbolFlag.OVERRIDE] = "override";
  symbolFlagToName[SymbolFlag.PRIVATE] = "private";
  symbolFlagToName[SymbolFlag.PROTECTED] = "protected";
  symbolFlagToName[SymbolFlag.PUBLIC] = "public";
  symbolFlagToName[SymbolFlag.STATIC] = "static";
  symbolFlagToName[SymbolFlag.VIRTUAL] = "virtual";
}

StringMap<SymbolFlag> nameToSymbolFlag;
IntMap<string> symbolFlagToName;
