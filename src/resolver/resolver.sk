enum CastKind {
  IMPLICIT,
  EXPLICIT,
}

class ResolveContext {
  Scope scope = null;

  // Keep track of the nearest enclosing node for certain node types
  Node loop = null;
  Node object = null;
  Node function = null;

  ResolveContext clone() {
    ResolveContext context = new ResolveContext();
    context.scope = scope;
    context.loop = loop;
    context.object = object;
    context.function = function;
    return context;
  }

  static ResolveContext fromNode(Node node) {
    ResolveContext context = new ResolveContext();
    Node parent;
    for (parent = node; node != null; node = node.parent) {
      if (context.scope == null) context.scope = node.scope;
      if (context.loop == null && node.kind.isLoop()) context.loop = node;
      if (context.object == null && node.kind.isObject()) context.object = node;
      if (context.function == null && node.kind.isFunction()) context.function = node;
    }
    return context;
  }
}

class Resolver {
  TypeCache cache = new TypeCache();
  ResolveContext context = new ResolveContext();
  List<Node> parsedDeclarations = {};
  List<Node> parsedBlocks = {};
  Type typeContext = null;
  Log log;

  static void run(Log log, Node program) {
    assert program.kind == NodeKind.PROGRAM;
    Resolver resolver = new Resolver(log);
    Scope globalScope = new Scope(null);
    globalScope.insertGlobals(resolver.cache);
    resolver.setupScopesAndMergeSymbols(program, globalScope);
    resolver.accumulateSymbolFlags();
    resolver.setSymbolKindsAndMergeSiblings();
    resolver.processUsingStatements();
    resolver.resolve(program, null);
  }

  void setupScopesAndMergeSymbols(Node node, Scope scope) {
    // The root program introduces the global scope
    if (node.kind == NodeKind.PROGRAM) {
      node.scope = scope;
    }

    // Remember each scope on the node that introduced that scope
    else if (node.kind == NodeKind.BLOCK) {
      // Object declaration blocks just use the scope from their parent node so
      // that symbols inside the block will be marked duplicates of parameters
      //
      //   class Foo<T> {
      //     int T;
      //   }
      //
      if (!node.parent.kind.isNamedBlockDeclaration()) {
        scope = new Scope(scope);
      }

      node.scope = scope;
      parsedBlocks.push(node);

      // Declarations at the file level go in the global scope
      if (node.parent.kind == NodeKind.FILE) {
        scope.type = cache.globalType;
      }

      // Declarations in a block declaration go in that block's type
      else {
        Symbol parentSymbol = node.parent.symbol;
        if (parentSymbol != null && parentSymbol.type != null) {
          scope.type = parentSymbol.type;
        }
      }
    }

    // Declare this node if needed
    if (node.kind.isNamedDeclaration() && node.kind != NodeKind.USING_ALIAS) {
      Node declarationName = node.declarationName();
      if (declarationName != null) {
        string name = declarationName.asString();
        Symbol symbol = scope.findLocal(name);

        // Append this symbol the linked list of sibling nodes
        if (symbol != null) {
          Node last = symbol.node;
          while (last.sibling != null) {
            last = last.sibling;
          }
          last.sibling = node;
        }

        // Make a new symbol
        else {
          symbol = new Symbol(name, SymbolKind.OTHER);
          symbol.node = node;
          scope.insert(symbol);
        }

        // Link the node with its symbol
        parsedDeclarations.push(node);
        declarationName.symbol = symbol;
        node.symbol = symbol;

        // Create a type for block declarations so that declarations inside the
        // block can be linked as siblings with declarations inside other adjacent
        // block declarations:
        //
        //   // Both "Bar" declarations are siblings linked through the type "Foo"
        //   namespace Foo { in Bar {} }
        //   namespace Foo { class Bar {} }
        //
        if (symbol.type == null && node.kind.isNamedBlockDeclaration()) {
          symbol.type = new Type(symbol);
        }
      }
    }

    // Also introduce a scope on object declarations for the type parameters
    // and on function declarations and lambda expressions for the arguments
    if (node.kind.isNamedBlockDeclaration() || node.kind.isFunction()) {
      node.scope = scope = new Scope(scope);
    }

    // Automatically traverse the children of all nodes, even though this pass
    // only initializing scopes. There will be scopes with statements inside
    // some expressions due to lambda expressions.
    if (node.hasChildren()) {
      int i;
      for (i = 0; i < node.children.length; i++) {
        Node child = node.children.get(i);
        if (child != null) setupScopesAndMergeSymbols(child, scope);
      }
    }
  }

  SymbolFlag symbolFlagsForNode(Node node) {
    SymbolFlag flags = 0;
    Node parent = node.parent;

    // Make sure modifiers are detected for variables inside a variable cluster
    if (parent.kind == NodeKind.VARIABLE_CLUSTER) {
      parent = parent.parent;
    }

    // Keep accumulating modifiers that are immediately nested inside each other
    while (parent != null && parent.kind == NodeKind.MODIFIER) {
      Node modifierName = parent.modifierName();
      string name = modifierName.asString();
      SymbolFlag flag = nameToSymbolFlag.get(name);
      if ((flags & flag) != 0) semanticWarningDuplicateModifier(log, modifierName.range, name);
      flags = flags | flag;
      parent = parent.parent;
    }

    return flags;
  }

  void accumulateSymbolFlags() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);

      // Skip all node in a sibling chain other than the first node
      if (node.symbol.node != node) {
        continue;
      }

      Node declarationName = node.declarationName();
      SymbolFlag flags = symbolFlagsForNode(node);
      Node sibling;

      // Make sure all siblings have the same modifiers
      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        SymbolFlag siblingFlags = symbolFlagsForNode(sibling);
        if (flags != siblingFlags) semanticErrorDifferentModifiers(log, sibling.declarationName().range, declarationName.asString(), declarationName.range);
        flags = flags | siblingFlags;
      }

      node.symbol.flags = flags;
    }
  }

  static bool checkParentsForFunction(Node node) {
    for (node = node.parent; node != null; node = node.parent) {
      if (node.kind.isFunction()) {
        return true;
      }
    }
    return false;
  }

  void setSymbolKindsAndMergeSiblings() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;

      // Skip all node in a sibling chain other than the first node
      if (symbol.node != node) {
        continue;
      }

      // The declaration name isn't null here because symbol != null
      Node declarationName = node.declarationName();
      NodeKind kind = node.kind;
      Node sibling;

      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        // Extensions off of block declarations are fine
        if (sibling.kind == NodeKind.EXTENSION && kind.isNamedBlockDeclaration()) {
          continue;
        }

        // Merge block declarations with extension blocks
        if (sibling.kind != NodeKind.EXTENSION && sibling.kind.isNamedBlockDeclaration()) {
          if (kind == NodeKind.EXTENSION || kind == NodeKind.NAMESPACE && sibling.kind == NodeKind.NAMESPACE) {
            kind = sibling.kind;
            continue;
          }
        }

        // Disallow all other merges
        Node siblingName = sibling.declarationName();
        semanticErrorDuplicateSymbol(log, siblingName.range, siblingName.asString(), declarationName.range);
      }

      // Set the symbol kind
      switch (kind) {
        case NodeKind.NAMESPACE { symbol.kind = SymbolKind.NAMESPACE; }
        case NodeKind.ENUM { symbol.kind = SymbolKind.ENUM; }
        case NodeKind.ENUM_FLAGS { symbol.kind = SymbolKind.ENUM_FLAGS; }
        case NodeKind.CLASS { symbol.kind = SymbolKind.CLASS; }
        case NodeKind.STRUCT { symbol.kind = SymbolKind.STRUCT; }
        case NodeKind.INTERFACE { symbol.kind = SymbolKind.INTERFACE; }
        case NodeKind.FUNCTION { symbol.kind = SymbolKind.GLOBAL_FUNCTION; }
        case NodeKind.CONSTRUCTOR { symbol.kind = SymbolKind.CONSTRUCTOR_FUNCTION; }
        case NodeKind.VARIABLE { symbol.kind = SymbolKind.GLOBAL_VARIABLE; }
        case NodeKind.PARAMETER { symbol.kind = SymbolKind.PARAMETER; }
        case NodeKind.EXTENSION { semanticErrorExtensionMissingTarget(log, declarationName.range, declarationName.asString()); }
        default { assert false; }
      }
    }

    // Distinguish between global and instance functions and variables now that
    // all symbols have a kind associated with them
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;
      Symbol enclosingSymbol = symbol.enclosingSymbol;

      // Change non-static global functions/variables to instance
      if (enclosingSymbol != null && enclosingSymbol.kind.isObject() && !symbol.isStatic()) {
        if (symbol.kind == SymbolKind.GLOBAL_FUNCTION) symbol.kind = SymbolKind.INSTANCE_FUNCTION;
        else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE) symbol.kind = SymbolKind.INSTANCE_VARIABLE;
      }

      // Change global variables to local
      else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE && checkParentsForFunction(node)) {
        symbol.kind = SymbolKind.LOCAL_VARIABLE;
      }
    }
  }

  void processUsingStatements() {
    int i;
    for (i = 0; i < parsedBlocks.length; i++) {
      Node block = parsedBlocks.get(i);
      int j;

      // Empty blocks will have a children array of null
      if (!block.hasChildren()) {
        continue;
      }

      // Add using aliases. These aren't added in setupScopesAndMergeSymbols()
      // because using aliases are limited to the scope in which they appear
      // and cannot be accessed by or merged symbols in other scopes:
      //
      //   namespace Foo { using Bar = bool; }
      //   namespace Foo { Bar bar; } // This is an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_ALIAS) {
          continue;
        }
        Node declarationName = statement.declarationName();
        string name = declarationName.asString();

        // Detect duplicate symbol declarations
        Symbol symbol = block.scope.findLocal(name);
        if (symbol != null) {
          Node otherName = symbol.node.declarationName();
          if (otherName != null) semanticErrorDuplicateSymbol(log, declarationName.range, name, otherName.range);
          continue;
        }

        // Insert a new unresolved symbol as a local symbol only on this scope.
        // It will not be added on the type associated with this scope.
        symbol = new Symbol(name, SymbolKind.OTHER);
        symbol.node = statement;
        statement.symbol = symbol;
        block.scope.insertLocal(symbol);

        // Resolve the value now because it should only depend on symbols that
        // already have a type (namespaces, enums, and objects)
        resolveGlobalUsingValue(statement.usingAliasValue());
      }

      // Add symbols from using statements. These must be added after using
      // aliases because using statements only import symbols from their
      // namespace if there isn't already an existing symbol:
      //
      //   namespace Foo { class Bar {} }
      //   using Foo;
      //   class Bar {} // This is not an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_NAMESPACE) {
          continue;
        }

        // Resolve the namespace as an absolute name
        Node value = statement.usingNamespaceValue();
        resolveGlobalUsingValue(value);
        if (value.symbol == null) {
          continue;
        }

        // Unlike a using alias, using statements must be a namespace. While
        // this could in theory support arbitrary types, it's more readable and
        // gives clearer errors to limit this to namespaces.
        if (!value.symbol.kind.isNamespace()) {
          semanticErrorBadUsingNamespace(log, value.range);
          continue;
        }

        // TODO: Insert each non-namespace symbol in the namespace
        // TODO: Importing multiple different symbols with the same name should
        // be replaced with an ambiguous marker that disables the name with an error
      }
    }
  }

  void resolveGlobalUsingValue(Node node) {
    node.type = cache.errorType;

    if (node.kind == NodeKind.NAME) {
      string name = node.asString();
      node.symbol = cache.globalType.findMember(name);
      if (node.symbol == null) {
        semanticErrorUndeclaredSymbol(log, node.range, name);
        return;
      }
    } else if (node.kind == NodeKind.DOT) {
      Node target = node.dotTarget();
      resolveGlobalUsingValue(target);
      Symbol targetSymbol = target.symbol;
      Node dotName = node.dotName();
      if (targetSymbol == null || targetSymbol.type == null || dotName == null) {
        return;
      }
      string name = dotName.asString();
      node.symbol = targetSymbol.type.findMember(name);
      if (node.symbol == null) {
        semanticErrorUnknownMemberSymbol(log, dotName.range, name, targetSymbol.type);
        return;
      }
    } else {
      semanticErrorUnexpectedNode(log, node.range, node.kind);
      return;
    }

    // Validate the symbol type, must not be an instance
    if (!node.symbol.kind.isType()) {
      semanticErrorBadUsingValue(log, node.range);
      node.symbol = null;
      node.type = cache.errorType;
    } else {
      node.type = node.symbol.type;
      assert node.type != null; // All type symbols should have a type by now
    }
  }

  void resolve(Node node, Type expectedType) {
    // Only resolve once
    if (node.type != null) {
      return;
    }
    node.type = cache.errorType;

    // Use the current scope for all child nodes
    Scope oldScope = context.scope;
    if (node.scope != null) context.scope = node.scope;

    // Track the type from the context this node is used in
    Type oldType = typeContext;
    typeContext = expectedType;

    switch (node.kind) {
      case NodeKind.PROGRAM { resolveProgram(node); }
      case NodeKind.FILE { resolveFile(node); }
      case NodeKind.BLOCK { resolveBlock(node); }
      case NodeKind.NODE_LIST { resolveChildren(node); }
      case NodeKind.CASE { resolveCase(node); }
      case NodeKind.USING_NAMESPACE { resolveUsingNamespace(node); }

      case NodeKind.NAMESPACE { resolveNamespace(node); }
      case NodeKind.ENUM, NodeKind.ENUM_FLAGS { resolveEnum(node); }
      case NodeKind.CLASS, NodeKind.STRUCT, NodeKind.INTERFACE { resolveObject(node); }

      case NodeKind.EXTENSION { resolveExtension(node); }
      case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION { resolveFunction(node); }
      case NodeKind.VARIABLE { resolveVariable(node); }
      case NodeKind.VARIABLE_CLUSTER { resolveVariableCluster(node); }
      case NodeKind.PARAMETER { resolveParameter(node); }
      case NodeKind.USING_ALIAS { resolveUsingAlias(node); }

      case NodeKind.IF { resolveIf(node); }
      case NodeKind.FOR { resolveFor(node); }
      case NodeKind.FOREACH { resolveForeach(node); }
      case NodeKind.WHILE { resolveWhile(node); }
      case NodeKind.DO_WHILE { resolveWhile(node); }
      case NodeKind.RETURN { resolveReturn(node); }
      case NodeKind.BREAK { resolveBreak(node); }
      case NodeKind.CONTINUE { resolveContinue(node); }
      case NodeKind.ASSERT { resolveAssert(node); }
      case NodeKind.EXPRESSION { resolveExpression(node); }
      case NodeKind.SWITCH { resolveSwitch(node); }
      case NodeKind.MODIFIER { resolveModifier(node); }

      case NodeKind.NAME { resolveName(node); }
      case NodeKind.TYPE { resolveType(node); }
      case NodeKind.NULL { node.type = cache.nullType; }
      case NodeKind.THIS { resolveThis(node); }
      case NodeKind.TRUE { node.type = cache.boolType; }
      case NodeKind.FALSE { node.type = cache.boolType; }
      case NodeKind.HOOK { resolveHook(node); }
      case NodeKind.INT { node.type = cache.intType; }
      case NodeKind.FLOAT { node.type = cache.floatType; }
      case NodeKind.DOUBLE { node.type = cache.doubleType; }
      case NodeKind.STRING { node.type = cache.stringType; }
      case NodeKind.INITIALIZER { resolveInitializer(node); }
      case NodeKind.DOT { resolveDot(node); }
      case NodeKind.DOT_CALL { resolveDotCall(node); }
      case NodeKind.CALL { resolveCall(node); }
      case NodeKind.SUPER_CALL { resolveSuperCall(node); }
      case NodeKind.NEW { resolveNew(node); }
      case NodeKind.ERROR { resolveError(node); }
      case NodeKind.SEQUENCE { resolveSequence(node); }
      case NodeKind.PARAMETERIZE { resolveParameterize(node); }
      case NodeKind.CAST { resolveCast(node); }
      case NodeKind.IMPLICIT_CAST { resolveCast(node); }
      case NodeKind.LAMBDA { resolveLambda(node); }
      case NodeKind.DEFAULT { resolveDefault(node); }

      case
        NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
        NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
        NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {
      }

      case
        NodeKind.ADD, NodeKind.BITWISE_AND, NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR,
        NodeKind.DIVIDE, NodeKind.EQUAL, NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL,
        NodeKind.IN, NodeKind.INDEX, NodeKind.LESS_THAN, NodeKind.LESS_THAN_OR_EQUAL,
        NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY, NodeKind.NOT_EQUAL,
        NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT, NodeKind.SUBTRACT {
      }

      case
        NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND, NodeKind.ASSIGN_BITWISE_OR,
        NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE, NodeKind.ASSIGN_MULTIPLY,
        NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT, NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT {
      }

      case NodeKind.ASSIGN_INDEX {}

      default {
        assert false;
      }
    }

    context.scope = oldScope;
    typeContext = oldType;
    assert node.type != null;
  }

  void checkIsType(Node node) {
    if (node.type != cache.errorType && !node.kind.isType()) {
      semanticErrorUnexpectedExpression(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsInstance(Node node) {
    if (node.type != cache.errorType && node.kind.isType()) {
      semanticErrorUnexpectedType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsValidVariableType(Node node) {
    if (node.type.isVoid(cache) || node.type.isNamespace()) {
      semanticErrorBadVariableType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkConversion(Type to, Node node, CastKind kind) {
    Type from = node.type;
    assert from != null;
    assert to != null;

    // Avoid reporting further errors
    if (from == cache.errorType || to == cache.errorType) {
      return;
    }

    // No implicit conversion needed for identical types
    if (from == to) {
      return;
    }

    // Special-case assigning 0 to an enum flags type
    if (to.symbol.kind == SymbolKind.ENUM_FLAGS && node.kind == NodeKind.INT && node.asInt() == 0) {
      from = to;
    }

    // The implicit conversion must be valid
    if (kind == CastKind.IMPLICIT && !cache.canImplicitlyConvert(from, to) ||
        kind == CastKind.EXPLICIT && !cache.canExplicitlyConvert(from, to)) {
      semanticErrorIncompatibleTypes(log, node.range, from, to, cache.canExplicitlyConvert(from, to));
      node.type = cache.errorType;
      return;
    }

    // Make the implicit conversion explicit for convenience later on
    if (kind == CastKind.IMPLICIT) {
      if (node.kind.isType()) return;
      Node value = new Node(NodeKind.NULL);
      value.become(node);
      node.become(Node.createImplicitCast(Node.createType(to), value).withType(to).withRange(node.range));
    }
  }

  void checkInsideBlock(Node node) {
    assert node.parent != null;

    // This will detect statements inside modifier "blocks", which aren't real
    // blocks and don't have their own scope:
    //
    //   inline { using bar = foo; }
    //
    if (node.parent.kind != NodeKind.BLOCK) {
      semanticErrorUnexpectedStatement(log, node.range, node.kind.toString());
    }
  }

  void checkTopLevelDeclaration(Node node) {
    assert node.parent != null;

    // Top-level declarations cannot live inside object declarations, function
    // declarations, or conditional statements
    Node parent;
    for (parent = node.parent; parent != null; parent = parent.parent) {
      NodeKind kind = parent.kind;
      if (kind != NodeKind.PROGRAM && kind != NodeKind.FILE &&
          kind != NodeKind.MODIFIER && kind != NodeKind.BLOCK &&
          kind != NodeKind.NAMESPACE && kind != NodeKind.EXTENSION) {
        semanticErrorUnexpectedStatement(log, node.range, node.kind.toString());
        break;
      }
    }
  }

  bool checkAccessToThis(Range range) {
    if (context.function != null && context.function.symbol.kind.isInstance()) {
      return true;
    }

    semanticErrorStaticThis(log, range);
    return false;
  }

  Type initializeNamespace(Node node) {
    return cache.errorType;
  }

  Type initializeEnum(Node node) {
    return cache.errorType;
  }

  Type initializeObject(Node node) {
    return cache.errorType;
  }

  Type initializeExtension(Node node) {
    return cache.errorType;
  }

  Type initializeFunction(Node node) {
    return cache.errorType;
  }

  Type initializeVariable(Node node) {
    return cache.errorType;
  }

  Type initializeParameter(Node node) {
    return cache.errorType;
  }

  Type initializeUsingAlias(Node node) {
    return cache.errorType;
  }

  void initializeDeclaration(Node node) {
    // Only initialize once (symbol should already have been set)
    assert node.symbol != null;
    if (node.symbol.type == null) {
      // Set the symbol's type to the circular type sentinel for the duration
      // of the declaration's initialization. This way we can detect cycles
      // that try to use the symbol in its own type, such as "foo foo;". The
      // declaration initializer should return the error type in this case.
      node.symbol.type = cache.cyclicType;

      // Resolve using node.symbol.node to start from the first node in the
      // sibling chain to ensure that the entire chain is processed at once
      ResolveContext oldContext = context;
      context = ResolveContext.fromNode(node);
      Type type = cache.errorType;
      Node first = node.symbol.node;
      switch (first.kind) {
        case NodeKind.NAMESPACE { type = initializeNamespace(first); }
        case NodeKind.ENUM, NodeKind.ENUM_FLAGS { type = initializeEnum(first); }
        case NodeKind.CLASS, NodeKind.STRUCT, NodeKind.INTERFACE { type = initializeObject(first); }
        case NodeKind.EXTENSION { type = initializeExtension(first); }
        case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION { type = initializeFunction(first); }
        case NodeKind.VARIABLE { type = initializeVariable(first); }
        case NodeKind.PARAMETER { type = initializeParameter(first); }
        case NodeKind.USING_ALIAS { type = initializeUsingAlias(first); }
        default { assert false; }
      }
      context = oldContext;

      // Update the type now that cycle detection is complete
      assert type != null;
      assert type != cache.cyclicType;
      node.symbol.type = type;
    }
  }

  void initializeSymbol(Symbol symbol) {
    // Only initialize the symbol once
    if (symbol.type == null) {
      assert symbol.node != null; // Internal symbols have no node but should already have a type
      initializeDeclaration(symbol.node);
      assert symbol.type != null;
    }

    // Detect cyclic symbol references such as "foo foo;"
    else if (symbol.type == cache.cyclicType) {
      semanticErrorCyclicDeclaration(log, symbol.node.range, symbol.name);
      symbol.type = cache.errorType;
    }
  }

  void unsupportedNodeKind(Node node) {
    log.error(node.range, "TODO: Support nodes of kind ".append(node.kind.toString()));
  }

  void resolveAsType(Node node) {
    resolve(node, null);
    checkIsType(node);
  }

  void resolveAsParameterizedType(Node node) {
    resolveAsType(node);
  }

  void resolveAsExpression(Node node) {
    resolve(node, null);
    checkIsInstance(node);
  }

  void resolveAsExpressionWithConversion(Node node, Type type, CastKind kind) {
    resolve(node, type);
    checkIsInstance(node);
    if (type != null) checkConversion(type, node, kind);
  }

  void resolveNodes(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      resolve(nodes.get(i), null);
    }
  }

  void resolveChildren(Node node) {
    if (node.hasChildren()) {
      resolveNodes(node.children);
    }
  }

  void resolveProgram(Node node) {
    assert node.parent == null;
    resolveChildren(node);
  }

  void resolveFile(Node node) {
    assert node.parent != null;
    assert node.parent.kind == NodeKind.PROGRAM;
    resolve(node.fileBlock(), null);
  }

  void resolveBlock(Node node) {
    assert node.kind == NodeKind.BLOCK;
    resolveChildren(node);
  }

  void resolveCase(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveUsingNamespace(Node node) {
    checkInsideBlock(node);
  }

  void resolveNamespace(Node node) {
    checkTopLevelDeclaration(node);
    resolveBlock(node.declarationBlock());
  }

  void resolveEnum(Node node) {
    checkTopLevelDeclaration(node);
    unsupportedNodeKind(node);
  }

  void resolveObject(Node node) {
    Node oldObject = context.object;
    context.object = node;

    checkTopLevelDeclaration(node);
    unsupportedNodeKind(node);

    context.object = oldObject;
  }

  void resolveExtension(Node node) {
    checkTopLevelDeclaration(node);
    unsupportedNodeKind(node);
  }

  void resolveFunction(Node node) {
    Node oldFunction = context.function;
    context.function = node;

    checkTopLevelDeclaration(node);
    unsupportedNodeKind(node);

    context.function = oldFunction;
  }

  void resolveVariable(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveVariableCluster(Node node) {
    resolveAsParameterizedType(node.clusterType());
    resolveNodes(node.clusterVariables());
    unsupportedNodeKind(node);
  }

  void resolveParameter(Node node) {
    assert node.parent != null;
    assert node.parent.kind.isObject();
    unsupportedNodeKind(node);
  }

  void resolveUsingAlias(Node node) {
    checkInsideBlock(node);
  }

  void resolveIf(Node node) {
    resolveAsExpressionWithConversion(node.ifTest(), cache.boolType, CastKind.IMPLICIT);
    resolveBlock(node.ifTrue());
    if (node.ifFalse() != null) resolveBlock(node.ifFalse());
  }

  void resolveFor(Node node) {
    if (node.forSetup() != null) resolveAsExpression(node.forSetup());
    if (node.forTest() != null) resolveAsExpressionWithConversion(node.forTest(), cache.boolType, CastKind.IMPLICIT);
    if (node.forUpdate() != null) resolveAsExpression(node.forUpdate());

    Node oldLoop = context.loop;
    context.loop = node;

    resolveBlock(node.forBlock());

    context.loop = oldLoop;
  }

  void resolveForeach(Node node) {
    Node oldLoop = context.loop;
    context.loop = node;

    unsupportedNodeKind(node);

    context.loop = oldLoop;
  }

  void resolveWhile(Node node) {
    Node oldLoop = context.loop;
    context.loop = node;

    resolveAsExpressionWithConversion(node.whileTest(), cache.boolType, CastKind.IMPLICIT);
    resolveBlock(node.whileBlock());

    context.loop = oldLoop;
  }

  void resolveReturn(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveBreak(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveContinue(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveAssert(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveExpression(Node node) {
    resolveAsExpression(node.expressionValue());
  }

  void resolveSwitch(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveModifier(Node node) {
    resolveNodes(node.modifierStatements());
  }

  void resolveName(Node node) {
    ResolveContext context = ResolveContext.fromNode(node); // TODO: Cache this
    string name = node.asString();
    Symbol symbol = context.scope.find(name);
    if (symbol == null) {
      semanticErrorUndeclaredSymbol(log, node.range, name);
      return;
    }
    initializeSymbol(symbol);

    // Wrap type symbols in a type node to distinguish them from instances
    if (symbol.kind.isType()) {
      node.become(Node.createType(symbol.type).withRange(node.range));
    } else {
      if (symbol.kind.isInstance()) {
        checkAccessToThis(node.range);
      }
      node.symbol = symbol;
      node.type = symbol.type;
    }
  }

  void resolveType(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveThis(Node node) {
    if (checkAccessToThis(node.range)) {
      assert context.object != null;
      Symbol symbol = context.object.symbol;
      initializeSymbol(symbol);
      node.type = symbol.type;
    }
  }

  void resolveHook(Node node) {
    Node trueNode = node.hookTrue();
    Node falseNode = node.hookFalse();
    resolveAsExpressionWithConversion(node.hookTest(), cache.boolType, CastKind.IMPLICIT);
    resolveAsExpression(trueNode);
    resolveAsExpression(falseNode);

    // Avoid reporting further errors
    Type trueType = trueNode.type;
    Type falseType = falseNode.type;
    if (trueType.isError(cache) || falseType.isError(cache)) {
      return;
    }

    // Ensure both branches can implicitly convert to a common type
    Type commonType = cache.commonImplicitType(trueType, falseType);
    if (commonType == null) {

      // As a fallback, try to disambiguate by how the result will be used
      commonType = typeContext;
      if (commonType == null || !cache.canImplicitlyConvert(trueType, commonType) || !cache.canImplicitlyConvert(falseType, commonType)) {
        semanticErrorNoCommonType(log, Range.span(trueNode.range, falseNode.range), trueType, falseType);
        return;
      }
    }

    // Finally, check that the conversion works. This check must be done
    // even when using the common type because it inserts implicit casts.
    checkConversion(commonType, trueNode, CastKind.IMPLICIT);
    checkConversion(commonType, falseNode, CastKind.IMPLICIT);
    node.type = commonType;
  }

  void resolveInitializer(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveDot(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveDotCall(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveCall(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveSuperCall(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveNew(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveError(Node node) {
    // Error nodes represent parse errors. They exist to allow a valid AST to
    // be produced from an invalid parse after parser recovery, which is most
    // useful when the compiler is being run as part of an IDE.
  }

  void resolveSequence(Node node) {
    assert node.hasChildren();
    int i;
    int n;
    for (i = 0, n = node.children.length; i < n; i++) {
      Node child = node.children.get(i);
      if (i + 1 < n) resolveAsExpression(child);
      else resolveAsExpressionWithConversion(child, typeContext, node.parent.kind == NodeKind.CAST ? CastKind.EXPLICIT : CastKind.IMPLICIT);
    }
  }

  void resolveParameterize(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveCast(Node node) {
    Node type = node.castType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    resolveAsExpressionWithConversion(node.castValue(), type.type, CastKind.EXPLICIT);
    node.type = type.type;
  }

  void resolveLambda(Node node) {
    Node oldFunction = context.function;
    context.function = node;

    unsupportedNodeKind(node);

    context.function = oldFunction;
  }

  void resolveDefault(Node node) {
    Node type = node.defaultType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    node.type = type.type;
  }
}

StringMap<SymbolFlag> createNameToSymbolFlag() {
  StringMap<SymbolFlag> result = new StringMap<SymbolFlag>();
  result.set("export", SymbolFlag.EXPORT);
  result.set("final", SymbolFlag.FINAL);
  result.set("import", SymbolFlag.IMPORT);
  result.set("inline", SymbolFlag.INLINE);
  result.set("override", SymbolFlag.OVERRIDE);
  result.set("private", SymbolFlag.PRIVATE);
  result.set("protected", SymbolFlag.PROTECTED);
  result.set("public", SymbolFlag.PUBLIC);
  result.set("static", SymbolFlag.STATIC);
  result.set("virtual", SymbolFlag.VIRTUAL);
  return result;
}

StringMap<SymbolFlag> nameToSymbolFlag = createNameToSymbolFlag();
