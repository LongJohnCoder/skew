enum CastKind {
  IMPLICIT,
  EXPLICIT,
}

enum AllowDeclaration {
  TOP_LEVEL,
  TOP_OR_OBJECT_LEVEL,
}

class ResolveContext {
  Scope scope = null;

  // Keep track of the nearest enclosing node for certain node types
  Node loop = null;
  Node object = null;
  Node function = null;
  Node switchValue = null;

  ResolveContext clone() {
    ResolveContext context = new ResolveContext();
    context.scope = scope;
    context.loop = loop;
    context.object = object;
    context.function = function;
    context.switchValue = switchValue;
    return context;
  }

  static ResolveContext fromNode(Node node) {
    ResolveContext context = new ResolveContext();
    Node parent;
    for (parent = node; node != null; node = node.parent) {
      if (context.scope == null) context.scope = node.scope;
      if (context.loop == null && node.kind.isLoop()) context.loop = node;
      if (context.object == null && node.kind.isObject()) context.object = node;
      if (context.function == null && node.kind.isFunction()) context.function = node;
      if (context.switchValue == null && node.kind == NodeKind.SWITCH) context.switchValue = node.switchValue();
    }
    return context;
  }
}

class Resolver {
  TypeCache cache = new TypeCache();
  ConstantFolder constantFolder = null;
  ResolveContext context = new ResolveContext();
  List<Node> parsedDeclarations = {};
  List<Node> parsedBlocks = {};
  Type typeContext = null;
  Type resultType = null;
  Log log;

  void run(Node program) {
    assert program.kind == NodeKind.PROGRAM;
    Scope globalScope = new Scope(null);
    globalScope.insertGlobals(cache);
    constantFolder = new ConstantFolder(cache);
    setupScopesAndUseNamespaces(program, globalScope);
    accumulateSymbolFlags();
    setSymbolKindsAndMergeSiblings();
    processUsingStatements();
    globalScope.linkGlobals(cache);
    resolve(program, null);
  }

  void setupScopesAndUseNamespaces(Node node, Scope scope) {
    // The root program introduces the global scope
    if (node.kind == NodeKind.PROGRAM) {
      node.scope = scope;
    }

    // Remember each scope on the node that introduced that scope
    else if (node.kind == NodeKind.BLOCK) {
      // Just use the existing scope from named block declarations
      if (!node.parent.kind.isNamedBlockDeclaration() && !node.parent.kind.isLoop()) {
        scope = new Scope(scope);
      }
      node.scope = scope;
      parsedBlocks.push(node);

      // Declarations at the file level go in the global scope
      if (node.parent.kind == NodeKind.FILE) {
        scope.type = cache.globalType;
      }

      // Declarations in a block declaration go in that block's type
      else {
        Symbol parentSymbol = node.parent.symbol;
        if (parentSymbol != null && parentSymbol.type != null) {
          scope.type = parentSymbol.type;
        }
      }
    }

    // Declare this node if needed
    if (node.kind.isNamedDeclaration() && node.kind != NodeKind.USING_ALIAS) {
      Node declarationName = node.declarationName();
      if (declarationName != null) {
        string name = declarationName.asString();
        Member member = scope.findLocal(name);
        Symbol symbol;

        // Append this symbol the linked list of sibling nodes
        if (member != null) {
          symbol = member.symbol;
          Node last = symbol.node;
          while (last.sibling != null) {
            last = last.sibling;
          }
          last.sibling = node;
        }

        // Make a new symbol
        else {
          symbol = new Symbol(name, SymbolKind.OTHER);
          symbol.node = node;
          if (scope.type != null) {
            symbol.enclosingSymbol = scope.type.symbol;
          }

          // Type parameters should not be accessable as members of their type
          if (node.kind == NodeKind.PARAMETER) {
            scope.insertLocal(symbol);
          } else {
            scope.insert(symbol);
          }
        }

        // Link the node with its symbol
        parsedDeclarations.push(node);
        declarationName.symbol = symbol;
        node.symbol = symbol;

        // Create a type for block declarations so that declarations inside the
        // block can be linked as siblings with declarations inside other adjacent
        // block declarations:
        //
        //   // Both "Bar" declarations are siblings linked through the type "Foo"
        //   namespace Foo { in Bar {} }
        //   namespace Foo { class Bar {} }
        //
        if (symbol.type == null && node.kind.isNamedBlockDeclaration()) {
          symbol.type = new Type(symbol);
        }
      }
    }

    // Also introduce a scope on object declarations for the type parameters
    // and on function declarations and lambda expressions for the arguments
    if (node.kind.isNamedBlockDeclaration() || node.kind.isFunction() || node.kind == NodeKind.LAMBDA || node.kind.isLoop()) {
      node.scope = scope = new Scope(scope);
    }

    // Automatically traverse the children of all nodes, even though this pass
    // only initializing scopes. There will be scopes with statements inside
    // some expressions due to lambda expressions.
    if (node.hasChildren()) {
      int i;
      for (i = 0; i < node.children.length; i++) {
        Node child = node.children.get(i);
        if (child != null) setupScopesAndUseNamespaces(child, scope);
      }
    }
  }

  SymbolFlag symbolFlagsForNode(Node node) {
    SymbolFlag flags = 0;
    Node parent = node.parent;

    // Make sure modifiers are detected for variables inside a variable cluster
    if (parent.kind == NodeKind.VARIABLE_CLUSTER) {
      parent = parent.parent;
    }

    // Keep accumulating modifiers that are immediately nested inside each other
    while (parent != null && parent.kind == NodeKind.MODIFIER) {
      Node modifierName = parent.modifierName();
      string name = modifierName.asString();
      SymbolFlag flag = nameToSymbolFlag.get(name);
      if ((flags & flag) != 0) semanticWarningDuplicateModifier(log, modifierName.range, name);
      flags = flags | flag;
      parent = parent.parent;
    }

    // Mark nodes directly inside extension blocks for easy checking later
    if (parent != null && parent.kind == NodeKind.BLOCK && parent.parent.kind == NodeKind.EXTENSION) {
      flags = flags | SymbolFlag.FROM_EXTENSION;
    }

    return flags;
  }

  void accumulateSymbolFlags() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);

      // Skip all nodes in a sibling chain other than the first node
      if (node.symbol.node != node) {
        continue;
      }

      Node declarationName = node.declarationName();
      SymbolFlag flags = symbolFlagsForNode(node);
      Node sibling;

      // Make sure all siblings have the same modifiers
      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        SymbolFlag siblingFlags = symbolFlagsForNode(sibling);

        // Don't count non-keyword modifiers
        if ((flags & SymbolFlag.KEYWORD_MASK) != (siblingFlags & SymbolFlag.KEYWORD_MASK)) {
          semanticErrorDifferentModifiers(log, sibling.declarationName().range, declarationName.asString(), declarationName.range);
          siblingFlags = siblingFlags | SymbolFlag.HAS_MODIFIER_ERRORS;
        }

        flags = flags | siblingFlags;
      }

      node.symbol.flags = flags;
    }
  }

  static bool checkParentsForLocalVariable(Node node) {
    for (node = node.parent; node != null; node = node.parent) {
      if (node.kind != NodeKind.PROGRAM && node.kind != NodeKind.FILE &&
          node.kind != NodeKind.BLOCK && node.kind != NodeKind.NAMESPACE &&
          node.kind != NodeKind.MODIFIER && node.kind != NodeKind.EXTENSION &&
          !node.kind.isEnum()) {
        return true;
      }
    }
    return false;
  }

  void setSymbolKindsAndMergeSiblings() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;

      // Skip all node in a sibling chain other than the first node
      if (symbol.node != node) {
        continue;
      }

      // The declaration name isn't null here because symbol != null
      Node declarationName = node.declarationName();
      NodeKind kind = node.kind;
      Node sibling;

      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        // Extensions off of block declarations are fine
        if (sibling.kind == NodeKind.EXTENSION && kind.isNamedBlockDeclaration()) {
          continue;
        }

        // Merge block declarations with extension blocks
        if (sibling.kind != NodeKind.EXTENSION && sibling.kind.isNamedBlockDeclaration()) {
          if (kind == NodeKind.EXTENSION || kind == NodeKind.NAMESPACE && sibling.kind == NodeKind.NAMESPACE) {
            kind = sibling.kind;
            continue;
          }
        }

        // Disallow all other merges
        Node siblingName = sibling.declarationName();
        semanticErrorDuplicateSymbol(log, siblingName.range, siblingName.asString(), declarationName.range);
      }

      // Disconnect all sibling variable and function declarations. All errors
      // about duplicate symbols should have already been logged by now. New
      // symbols are created for each node but are not inserted into the scope
      // so that the contents of the duplicate nodes can still be type-checked.
      Node previous = node;
      sibling = node.sibling;
      while (sibling != null) {
        if (sibling.kind == NodeKind.VARIABLE || sibling.kind.isFunction()) {
          Symbol disconnected = sibling.symbol = new Symbol(symbol.name, SymbolKind.OTHER);
          disconnected.enclosingSymbol = symbol.enclosingSymbol;
          disconnected.node = sibling;
          sibling = previous.sibling = sibling.sibling;
        } else {
          previous = sibling;
          sibling = sibling.sibling;
        }
      }

      // Set the symbol kind
      switch (kind) {
        case NodeKind.NAMESPACE { symbol.kind = SymbolKind.NAMESPACE; }
        case NodeKind.ENUM { symbol.kind = SymbolKind.ENUM; }
        case NodeKind.ENUM_FLAGS { symbol.kind = SymbolKind.ENUM_FLAGS; }
        case NodeKind.CLASS { symbol.kind = SymbolKind.CLASS; }
        case NodeKind.STRUCT { symbol.kind = SymbolKind.STRUCT; }
        case NodeKind.INTERFACE { symbol.kind = SymbolKind.INTERFACE; }
        case NodeKind.FUNCTION { symbol.kind = SymbolKind.GLOBAL_FUNCTION; }
        case NodeKind.CONSTRUCTOR { symbol.kind = SymbolKind.CONSTRUCTOR_FUNCTION; }
        case NodeKind.VARIABLE { symbol.kind = SymbolKind.GLOBAL_VARIABLE; }
        case NodeKind.PARAMETER { symbol.kind = SymbolKind.PARAMETER; }
        case NodeKind.EXTENSION { semanticErrorExtensionMissingTarget(log, declarationName.range, declarationName.asString()); }
        default { assert false; }
      }
    }

    // Distinguish between global and instance functions and variables now that
    // all symbols have a kind associated with them
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;

      // Change non-static global functions/variables to instance
      if (symbol.isObjectMember() && !symbol.isStatic()) {
        if (symbol.kind == SymbolKind.GLOBAL_FUNCTION) symbol.kind = SymbolKind.INSTANCE_FUNCTION;
        else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE) symbol.kind = SymbolKind.INSTANCE_VARIABLE;
      }

      // Change global variables to local
      else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE && checkParentsForLocalVariable(node)) {
        symbol.kind = SymbolKind.LOCAL_VARIABLE;
      }
    }
  }

  void processUsingStatements() {
    int i;
    for (i = 0; i < parsedBlocks.length; i++) {
      Node block = parsedBlocks.get(i);
      int j;

      // Empty blocks will have a children array of null
      if (!block.hasChildren()) {
        continue;
      }

      // Add using aliases. These aren't added in setupScopesAndUseNamespaces()
      // because using aliases are limited to the scope in which they appear
      // and cannot be accessed by or merged symbols in other scopes:
      //
      //   namespace Foo { using Bar = bool; }
      //   namespace Foo { Bar bar; } // This is an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_ALIAS) {
          continue;
        }
        Node declarationName = statement.declarationName();
        string name = declarationName.asString();

        // Detect duplicate symbol declarations
        Member member = block.scope.findLocal(name);
        if (member != null) {
          Node otherName = member.symbol.node.declarationName();
          if (otherName != null) semanticErrorDuplicateSymbol(log, declarationName.range, name, otherName.range);
          continue;
        }

        // Insert a new unresolved symbol as a local symbol only on this scope.
        // It will not be added on the type associated with this scope.
        Symbol symbol = new Symbol(name, SymbolKind.USING_ALIAS);
        symbol.node = statement;
        statement.symbol = symbol;
        block.scope.insertLocal(symbol);
      }

      // Add symbols from using statements. These must be added after using
      // aliases because using statements only import symbols from their
      // namespace if there isn't already an existing symbol:
      //
      //   namespace Foo { class Bar {} }
      //   using Foo;
      //   class Bar {} // This is not an error
      //
      List<Symbol> insertedSymbols = null;
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_NAMESPACE) {
          continue;
        }

        // Resolve the namespace as an absolute name
        Node value = statement.usingNamespaceValue();
        resolveGlobalUsingNamespaceValue(value);
        if (value.type.isError(cache)) {
          continue;
        }
        Symbol symbol = value.type.symbol;
        if (symbol == null) {
          continue;
        }

        // Unlike a using alias, using statements must be a namespace. While
        // this could in theory support arbitrary types, it's more readable and
        // gives clearer errors to limit this to namespaces.
        if (!symbol.kind.isNamespace()) {
          semanticErrorBadUsingNamespace(log, value.range);
          continue;
        }

        // Lazily allocate this list to reduce allocations
        if (insertedSymbols == null) {
          insertedSymbols = {};
        }

        // Copy each non-namespace symbol into this namespace if not already
        // present. If a symbol is already present but was due to another
        // using namespace statement, then mark the symbol as ambiguous.
        List<Member> members = symbol.type.members.values();
        int k;
        for (k = 0; k < members.length; k++) {
          Member member = members.get(k);
          Symbol memberSymbol = member.symbol;
          if (memberSymbol.kind == SymbolKind.NAMESPACE) {
            continue;
          }
          Member current = block.scope.findLocal(memberSymbol.name);
          if (current == null) {
            insertedSymbols.push(memberSymbol);
            block.scope.insertLocal(memberSymbol);
          } else {
            Symbol currentSymbol = current.symbol;
            if (insertedSymbols.indexOf(currentSymbol) >= 0) {
              if (currentSymbol.kind != SymbolKind.AMBIGUOUS) {
                Symbol collision = new Symbol(memberSymbol.name, SymbolKind.AMBIGUOUS);
                collision.identicalMembers = { current, member };
                block.scope.locals.set(memberSymbol.name, new Member(collision));
                insertedSymbols.push(collision);
              } else {
                currentSymbol.identicalMembers.push(member);
              }
            }
          }
        }
      }
    }
  }

  void resolveGlobalUsingNamespaceValue(Node node) {
    node.type = cache.errorType;
    Member member;

    // Handle top-level names
    if (node.kind == NodeKind.NAME) {
      string name = node.asString();
      member = cache.globalType.findMember(name);
      if (member == null) {
        semanticErrorUndeclaredSymbol(log, node.range, name);
        return;
      }
    }

    // Handle nested names
    else if (node.kind == NodeKind.DOT) {
      Node target = node.dotTarget();
      resolveGlobalUsingNamespaceValue(target);
      Type targetType = target.type;
      Node dotName = node.dotName();
      if (targetType == null || dotName == null) {
        return;
      }
      string name = dotName.asString();
      member = targetType.findMember(name);
      if (member == null) {
        semanticErrorUnknownMemberSymbol(log, dotName.range, name, targetType);
        return;
      }
    }

    // Non-name nodes are not allowed
    else {
      semanticErrorUnexpectedNode(log, node.range, node.kind);
      return;
    }

    // Validate the member type, must not be an instance
    if (!member.symbol.kind.isType()) {
      semanticErrorBadUsingValue(log, node.range);
      return;
    }

    // Create a type node to distinguish the type from an instance of that type
    node.become(Node.createType(member.symbol.type).withRange(node.range));
    assert node.type != null; // All type symbols should have a type by now
  }

  void resolve(Node node, Type expectedType) {
    // Only resolve once
    if (node.type != null) {
      return;
    }
    node.type = cache.errorType;

    // Use the current scope for all child nodes
    Scope oldScope = context.scope;
    if (node.scope != null) context.scope = node.scope;

    // Track the type from the context this node is used in
    Type oldType = typeContext;
    typeContext = expectedType;

    switch (node.kind) {
      case NodeKind.PROGRAM { resolveProgram(node); }
      case NodeKind.FILE { resolveFile(node); }
      case NodeKind.BLOCK { resolveBlock(node); }
      case NodeKind.NODE_LIST { resolveChildren(node); }
      case NodeKind.CASE { resolveCase(node); }
      case NodeKind.USING_NAMESPACE { resolveUsingNamespace(node); }

      case NodeKind.NAMESPACE { resolveNamespace(node); }
      case NodeKind.ENUM, NodeKind.ENUM_FLAGS { resolveEnum(node); }
      case NodeKind.CLASS, NodeKind.STRUCT, NodeKind.INTERFACE { resolveObject(node); }

      case NodeKind.EXTENSION { resolveExtension(node); }
      case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION { resolveFunction(node); }
      case NodeKind.VARIABLE { resolveVariable(node); }
      case NodeKind.VARIABLE_CLUSTER { resolveVariableCluster(node); }
      case NodeKind.PARAMETER { resolveParameter(node); }
      case NodeKind.USING_ALIAS { resolveUsingAlias(node); }

      case NodeKind.IF { resolveIf(node); }
      case NodeKind.FOR { resolveFor(node); }
      case NodeKind.FOR_EACH { resolveForEach(node); }
      case NodeKind.WHILE { resolveWhile(node); }
      case NodeKind.DO_WHILE { resolveWhile(node); }
      case NodeKind.RETURN { resolveReturn(node); }
      case NodeKind.BREAK { resolveBreak(node); }
      case NodeKind.CONTINUE { resolveContinue(node); }
      case NodeKind.ASSERT { resolveAssert(node); }
      case NodeKind.EXPRESSION { resolveExpression(node); }
      case NodeKind.SWITCH { resolveSwitch(node); }
      case NodeKind.MODIFIER { resolveModifier(node); }

      case NodeKind.NAME { resolveName(node); }
      case NodeKind.NULL { node.type = cache.nullType; }
      case NodeKind.THIS { resolveThis(node); }
      case NodeKind.TRUE { node.type = cache.boolType; }
      case NodeKind.FALSE { node.type = cache.boolType; }
      case NodeKind.HOOK { resolveHook(node); }
      case NodeKind.INT { node.type = cache.intType; }
      case NodeKind.FLOAT { node.type = cache.floatType; }
      case NodeKind.DOUBLE { node.type = cache.doubleType; }
      case NodeKind.STRING { node.type = cache.stringType; }
      case NodeKind.INITIALIZER { resolveInitializer(node); }
      case NodeKind.DOT { resolveDot(node); }
      case NodeKind.CALL { resolveCall(node); }
      case NodeKind.SUPER_CALL { resolveSuperCall(node); }
      case NodeKind.ERROR {} // Ignore parse errors
      case NodeKind.SEQUENCE { resolveSequence(node); }
      case NodeKind.PARAMETERIZE { resolveParameterize(node); }
      case NodeKind.CAST { resolveCast(node); }
      case NodeKind.IMPLICIT_CAST { resolveCast(node); }
      case NodeKind.LAMBDA { resolveLambda(node); }
      case NodeKind.DEFAULT { resolveDefault(node); }
      case NodeKind.VAR { resolveVar(node); }
      case NodeKind.FUNCTION_TYPE { resolveFunctionType(node); }

      case
        NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
        NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
        NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {
        resolveUnaryOperator(node);
      }

      case
        NodeKind.ADD, NodeKind.BITWISE_AND, NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR,
        NodeKind.DIVIDE, NodeKind.EQUAL, NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL,
        NodeKind.IN, NodeKind.INDEX, NodeKind.LESS_THAN, NodeKind.LESS_THAN_OR_EQUAL,
        NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY, NodeKind.NOT_EQUAL,
        NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT, NodeKind.SUBTRACT,
        NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND, NodeKind.ASSIGN_BITWISE_OR,
        NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE, NodeKind.ASSIGN_MULTIPLY,
        NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT, NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT {
        resolveBinaryOperator(node);
      }

      case NodeKind.ASSIGN_INDEX {
        resolveTertiaryOperator(node);
      }

      default {
        assert false;
      }
    }

    context.scope = oldScope;
    typeContext = oldType;
    assert node.type != null;
  }

  void checkIsParameterized(Node node) {
    if (!node.type.isError(cache) && node.type.hasParameters() && !node.type.isParameterized()) {
      semanticErrorUnparameterizedType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsType(Node node) {
    if (!node.type.isError(cache) && !node.kind.isType()) {
      semanticErrorUnexpectedExpression(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsInstance(Node node) {
    if (!node.type.isError(cache) && node.kind.isType()) {
      semanticErrorUnexpectedType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsValidFunctionReturnType(Node node) {
    if (!node.type.isVoid(cache)) {
      checkIsValidVariableType(node);
    }
  }

  void checkIsValidVariableType(Node node) {
    if (node.type.isVoid(cache) || node.type.isNamespace()) {
      semanticErrorBadType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkUnusedExpression(Node node) {
    NodeKind kind = node.kind;
    if (kind == NodeKind.HOOK) {
      checkUnusedExpression(node.hookTrue());
      checkUnusedExpression(node.hookFalse());
    } else if (kind == NodeKind.SEQUENCE) {
      if (node.hasChildren()) {
        checkUnusedExpression(node.children.get(node.children.length - 1));
      }
    } else if (!node.type.isError(cache) && !kind.isCall() && !node.kind.isUnaryStorageOperator() && !node.kind.isBinaryStorageOperator()) {
      semanticWarningUnusedExpression(log, node.range);
    }
  }

  void checkStorage(Node node) {
    if (node.type.isError(cache)) {
      return;
    }

    // Only certain expressions support storage
    if (!node.kind.isStorage()) {
      semanticErrorBadStorage(log, node.range);
      return;
    }

    // Forbid storage to final symbols
    if (node.symbol.isFinal()) {
      semanticErrorStorageToFinal(log, node.range);
      return;
    }
  }

  void checkConversion(Type to, Node node, CastKind kind) {
    Type from = node.type;
    assert from != null;
    assert to != null;

    // Avoid reporting further errors
    if (from.isError(cache) || to.isError(cache)) {
      return;
    }

    // Converting from "void" to "void" always fails
    if (from.isVoid(cache) && to.isVoid(cache)) {
      semanticErrorUnexpectedExpression(log, node.range, to);
      return;
    }

    // No implicit conversion needed for identical types
    if (from == to) {
      return;
    }

    // Special-case assigning 0 to an enum flags type
    if (to.isEnumFlags() && node.kind == NodeKind.INT && node.asInt() == 0) {
      from = to;
    }

    // The implicit conversion must be valid
    if (kind == CastKind.IMPLICIT && !cache.canImplicitlyConvert(from, to) ||
        kind == CastKind.EXPLICIT && !cache.canExplicitlyConvert(from, to)) {
      semanticErrorIncompatibleTypes(log, node.range, from, to, cache.canExplicitlyConvert(from, to));
      node.type = cache.errorType;
      return;
    }

    // Make the implicit conversion explicit for convenience later on
    if (kind == CastKind.IMPLICIT) {
      if (node.kind.isType()) return;
      Node value = new Node(NodeKind.NULL);
      value.become(node);
      node.become(Node.createImplicitCast(Node.createType(to), value).withType(to).withRange(node.range));
    }
  }

  void unexpectedStatement(Node node) {
    semanticErrorUnexpectedStatement(log, node.range);
  }

  void checkInsideBlock(Node node) {
    assert node.parent != null;

    // This will detect statements inside modifier "blocks", which aren't real
    // blocks and don't have their own scope:
    //
    //   inline { using bar = foo; }
    //
    if (node.parent.kind != NodeKind.BLOCK) {
      unexpectedStatement(node);
    }
  }

  void checkDeclarationLocation(Node node, AllowDeclaration allowDeclaration) {
    // Top-level declarations cannot live inside object declarations, function
    // declarations, or conditional statements
    Node parent;
    for (parent = node.parent; parent != null; parent = parent.parent) {
      NodeKind kind = parent.kind;
      if (kind != NodeKind.PROGRAM && kind != NodeKind.FILE &&
          kind != NodeKind.MODIFIER && kind != NodeKind.BLOCK &&
          kind != NodeKind.NAMESPACE && kind != NodeKind.EXTENSION &&
          (allowDeclaration != AllowDeclaration.TOP_OR_OBJECT_LEVEL || !kind.isObject())) {
        unexpectedStatement(node);
        break;
      }
    }
  }

  void checkStatementLocation(Node node) {
    assert node.parent != null;

    // Statements cannot live inside non-namespace type declarations
    // Top-level declarations cannot live inside object declarations, function
    // declarations, or conditional statements
    if (node.parent.kind != NodeKind.BLOCK || node.parent.parent.kind.isNamedBlockDeclaration() && node.parent.parent.kind != NodeKind.NAMESPACE) {
      unexpectedStatement(node);
    }
  }

  bool checkAccessToThis(Range range) {
    if (context.function != null && context.function.symbol.kind.isInstance()) {
      return true;
    }

    if (context.object != null) semanticErrorStaticThis(log, range, "this");
    else semanticErrorUnexpectedThis(log, range, "this");
    return false;
  }

  bool checkAccessToInstanceSymbol(Node node) {
    Symbol symbol = node.symbol;

    // No need to check for static symbols
    if (!symbol.kind.isInstance() && symbol.kind != SymbolKind.PARAMETER) {
      return true;
    }

    // Allow instance access inside instance functions
    if (context.function != null && context.function.symbol.kind.isInstance() &&
        context.function.symbol.enclosingSymbol == symbol.enclosingSymbol) {
      return true;
    }

    // Use a different error message when outside a function for clarity
    if (context.object == null) {
      semanticErrorUnexpectedThis(log, node.range, symbol.name);
      return false;
    }

    // The cases where type parameters may appear are more complicated
    if (symbol.kind == SymbolKind.PARAMETER && context.object.symbol == symbol.enclosingSymbol) {
      Node parent;
      for (parent = node.parent; parent != context.object; parent = parent.parent) {
        if (parent.kind == NodeKind.NODE_LIST && parent.parent == context.object &&
            (parent == parent.parent.objectParameters() || parent == parent.parent.baseTypes())) {
          return true;
        }
        if ((parent.kind == NodeKind.VARIABLE || parent.kind.isFunction()) && parent.symbol.kind.isInstance()) {
          return true;
        }
      }
    }

    semanticErrorStaticThis(log, node.range, symbol.name);
    return false;
  }

  static List<Node> collectBaseTypes(Symbol symbol) {
    List<Node> baseTypes = {};
    Node node;
    for (node = symbol.node; node != null; node = node.sibling) {
      if (node.kind.isObject() || node.kind == NodeKind.EXTENSION) {
        Node types = node.baseTypes();
        if (types != null && types.hasChildren()) {
          int i;
          for (i = 0; i < types.children.length; i++) {
            baseTypes.push(types.children.get(i));
          }
        }
      }
    }
    return baseTypes;
  }

  void checkNoBaseTypes(Symbol symbol, string what) {
    List<Node> baseTypes = collectBaseTypes(symbol);
    int i;
    for (i = 0; i < baseTypes.length; i++) {
      Node baseType = baseTypes.get(i);
      resolveAsParameterizedType(baseType);
      semanticErrorUnexpectedBaseType(log, baseType.range, what);
    }
  }

  bool needsTypeContext(Node node) {
    return
      node.kind == NodeKind.INITIALIZER ||
      node.kind == NodeKind.DOT && node.dotTarget() == null ||
      node.kind == NodeKind.HOOK && needsTypeContext(node.hookTrue()) && needsTypeContext(node.hookFalse());
  }

  void addAutoGeneratedMember(Type type, string name) {
    Symbol symbol = new Symbol(name, SymbolKind.AUTOMATIC);
    symbol.enclosingSymbol = type.symbol;
    type.addMember(new Member(symbol));
  }

  void initializeNamespace(Symbol symbol) {
    assert symbol.type.isNamespace();
    unexpectedModifierIfPresent(symbol, SymbolFlag.FINAL, "on a namespace declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.STATIC, "on a namespace declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.VIRTUAL, "on a namespace declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.OVERRIDE, "on a namespace declaration");
    checkNoBaseTypes(symbol, "A namespace");
  }

  void initializeEnum(Symbol symbol) {
    assert symbol.type.isEnum();
    unexpectedModifierIfPresent(symbol, SymbolFlag.FINAL, "on an enum declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.STATIC, "on an enum declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.VIRTUAL, "on an enum declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.OVERRIDE, "on an enum declaration");
    checkNoBaseTypes(symbol, "An enum");
  }

  void resolveBaseTypes(Symbol symbol) {
    Node node = symbol.node;
    Type type = symbol.type;
    List<Node> baseTypes = collectBaseTypes(symbol);
    StringMap<Member> unmergedMembers = new StringMap<Member>();
    assert type.relevantTypes == null;
    type.relevantTypes = {};

    // A struct has no base type because it's meant to be a named tuple type
    if (symbol.kind == SymbolKind.STRUCT) {
      checkNoBaseTypes(symbol, "A struct");
      resolveNodesAsVariableTypes(baseTypes);
      return;
    }

    int i;
    for (i = 0; i < baseTypes.length; i++) {
      Node base = baseTypes.get(i);
      resolveAsParameterizedType(base);
      Type baseType = base.type;

      // Avoid reporting further errors
      if (baseType.isError(cache)) {
        continue;
      }

      // Ensure there is one base class and everything else is an interface
      if (symbol.kind == SymbolKind.CLASS && baseType.isClass()) {
        if (base.parent.parent != node || node.baseTypes().children.indexOf(base) != 0) {
          semanticErrorClassBaseNotFirst(log, base.range, baseType);
          continue;
        }
      } else if (!baseType.isInterface()) {
        semanticErrorBaseTypeNotInterface(log, base.range, baseType);
        continue;
      }

      // Prevent duplicates, but only within this type (duplicates among base
      // types are fine)
      if (type.relevantTypes.indexOf(baseType) >= 0) {
        semanticErrorDuplicateBaseType(log, base.range, baseType);
        continue;
      }

      // Cycles should already be prevented by the general-purpose cycle
      // detection algorithm, since symbol should still be initializing
      assert !baseType.hasBaseType(type);

      type.relevantTypes.push(baseType);

      // Collect all base type members
      List<Member> members = baseType.members.values();
      int j;
      for (j = 0; j < members.length; j++) {
        Member member = members.get(j);
        Symbol memberSymbol = member.symbol;
        Member unmerged = unmergedMembers.getOrDefault(memberSymbol.name, null);
        if (unmerged == null) {
          unmergedMembers.set(memberSymbol.name, member);
        } else if (unmerged.symbol.enclosingSymbol != memberSymbol) {
          Symbol combined = new Symbol(memberSymbol.name, SymbolKind.UNMERGED);
          combined.enclosingSymbol = symbol;
          combined.identicalMembers = { unmerged, member };
          unmergedMembers.set(memberSymbol.name, new Member(combined));
        } else {
          assert unmerged.symbol.kind == SymbolKind.UNMERGED;
          unmerged.symbol.identicalMembers.push(member);
        }
      }
    }

    // Insert unmerged symbols into the derived type, but don't replace the
    // member symbols that are already there
    List<Member> baseMembers = unmergedMembers.values();
    for (i = 0; i < baseMembers.length; i++) {
      Member member = baseMembers.get(i);
      Member existing = type.findMember(member.symbol.name);

      // Link existing members with the member they override
      if (existing != null) {
        assert existing.symbol.overriddenMember == null;
        existing.symbol.overriddenMember = member;
      }

      // Note that member.symbol.kind.isConstructor() will miss automatically
      // generated constructors that haven't been initialized yet, but checking
      // the name against "new" will always be correct since "new" is a keyword
      else if (member.symbol.name != "new") {
        type.addMember(member);
      }
    }
  }

  void initializeObject(Symbol symbol) {
    unexpectedModifierIfPresent(symbol, SymbolFlag.FINAL, "on an object declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.STATIC, "on an object declaration");

    Node node = symbol.node.firstNonExtensionSibling();
    Node parameters = node.objectParameters();
    Type type = symbol.type;
    assert type.isObject();

    string where;
    switch (symbol.kind) {
      case SymbolKind.CLASS { where = "on a class declaration"; }
      case SymbolKind.STRUCT { where = "on a struct declaration"; }
      case SymbolKind.INTERFACE { where = "on an interface declaration"; }
    }
    unexpectedModifierIfPresent(symbol, SymbolFlag.VIRTUAL, where);
    unexpectedModifierIfPresent(symbol, SymbolFlag.OVERRIDE, where);

    // Resolve type parameters
    List<Symbol> parameterSymbols = null;
    if (parameters != null && parameters.hasChildren()) {
      symbol.parameters = {};
      resolveNodes(parameters.children);
      int i;
      for (i = 0; i < parameters.children.length; i++) {
        symbol.parameters.push(parameters.children.get(i).symbol);
      }
      symbol.sortParametersByDependencies();
    }

    // Add auto-generated symbols
    if (!type.isInterface() && type.constructor() == null && !symbol.isImport()) {
      addAutoGeneratedMember(type, "new");
    }

    // Resolve base types and copy all base symbols onto this type
    resolveBaseTypes(symbol);
  }

  void initializeFunction(Symbol symbol) {
    unexpectedModifierIfPresent(symbol, SymbolFlag.FINAL, "on a function declaration");
    if (symbol.enclosingSymbol == null || !symbol.enclosingSymbol.kind.isTypeWithInstances()) {
      unexpectedModifierIfPresent(symbol, SymbolFlag.STATIC, "outside an object declaration");
    }

    Node node = symbol.node;
    Type resultType;
    Node result;

    // Only functions have return types (constructors don't)
    if (node.kind == NodeKind.FUNCTION) {
      result = node.functionResult();
      resolveAsParameterizedType(result);
      checkIsValidFunctionReturnType(result);
      resultType = result.type;
    }

    // Constructors get a return type of the object that they create
    else {
      assert node.kind == NodeKind.CONSTRUCTOR;
      resultType = symbol.enclosingSymbol.type;
    }

    // Resolve argument variables
    Node arguments = node.functionArguments();
    resolve(arguments, null);

    // Create the function type
    symbol.type = cache.errorType;
    if (!resultType.isError(cache)) {
      List<Type> argumentTypes = {};
      int i;
      for (i = 0; i < arguments.children.length; i++) {
        Type type = arguments.children.get(i).symbol.type;
        if (type.isError(cache)) return;
        argumentTypes.push(type);
      }
      symbol.type = cache.functionType(resultType, argumentTypes);
    }

    // Functions must not have a different type than the symbol they override
    Member overriddenMember = symbol.overriddenMember;
    if (overriddenMember != null && !symbol.kind.isConstructor()) {
      initializeMember(overriddenMember);
      Type base = overriddenMember.type;
      Type derived = symbol.type;
      if (!base.isError(cache) && !derived.isError(cache)) {
        Symbol overriddenSymbol = overriddenMember.symbol;

        // Functions can only override other functions
        if (!base.isFunction() || !overriddenSymbol.kind.isInstance() || !symbol.kind.isInstance()) {
          semanticErrorBadOverride(log, node.declarationName().range, symbol.name,
            overriddenSymbol.enclosingSymbol.type, overriddenSymbol.node.declarationName().range);
        }

        // Functions can only override other functions with the same signature
        else if (base != derived) {
          semanticErrorOverrideDifferentTypes(log, node.declarationName().range, symbol.name,
            base, derived, overriddenSymbol.node.declarationName().range);
        }

        // Overriding must be explicit with the "override" modifier
        else if (!symbol.isOverride()) {
          semanticErrorModifierMissingOverride(log, node.declarationName().range, symbol.name,
            overriddenSymbol.node.declarationName().range);
        }

        // Overriding must be explicit with the "override" modifier
        else if (!overriddenSymbol.isVirtual()) {
          semanticErrorCannotOverrideNonVirtual(log, node.declarationName().range, symbol.name,
            overriddenSymbol.node.declarationName().range);
        }

        // The "override" modifier replaces the "virtual" modifier
        else {
          redundantModifierIfPresent(symbol, SymbolFlag.VIRTUAL, "on an overriding function");
        }
      }

      // The "virtual" modifier is implied
      symbol.flags = symbol.flags | SymbolFlag.VIRTUAL;
    }

    // Ignore overriding-related modifiers outside an object
    else if (!symbol.isObjectMember()) {
      unexpectedModifierIfPresent(symbol, SymbolFlag.VIRTUAL, "outside an object declaration");
      unexpectedModifierIfPresent(symbol, SymbolFlag.OVERRIDE, "outside an object declaration");
    }

    // Validate modifiers when nothing is being overridden
    else {
      if (!symbol.kind.isInstance()) unexpectedModifierIfPresent(symbol, SymbolFlag.VIRTUAL, "on a non-instance function");
      unexpectedModifierIfPresent(symbol, SymbolFlag.OVERRIDE, "on a function that doesn't override anything");

      // If "override" is used, imply "virtual" to mask further errors
      if (symbol.isOverride()) symbol.flags = symbol.flags | SymbolFlag.VIRTUAL;
    }
  }

  static Node findModifierName(Symbol symbol, SymbolFlag flag) {
    Node node = symbol.node;
    while (node != null) {
      if (node.kind == NodeKind.MODIFIER) {
        Node modifierName = node.modifierName();
        if (nameToSymbolFlag.get(modifierName.asString()) == flag) {
          return modifierName;
        }
      }
      node = node.parent;
    }
    return null;
  }

  void redundantModifierIfPresent(Symbol symbol, SymbolFlag flag, string where) {
    if ((symbol.flags & flag) != 0 && !symbol.hasModifierErrors()) {
      Node modifierName = findModifierName(symbol, flag);
      if (modifierName != null) {
        semanticErrorRedundantModifier(log, modifierName.range, modifierName.asString(), where);
      }
    }
  }

  void unexpectedModifierIfPresent(Symbol symbol, SymbolFlag flag, string where) {
    if ((symbol.flags & flag) != 0 && !symbol.hasModifierErrors()) {
      Node modifierName = findModifierName(symbol, flag);
      if (modifierName != null) {
        semanticErrorUnexpectedModifier(log, modifierName.range, modifierName.asString(), where);
      }
    }
  }

  void expectedModifierIfAbsent(Symbol symbol, SymbolFlag flag, string where) {
    if ((symbol.flags & flag) == 0 && !symbol.hasModifierErrors() && findModifierName(symbol, flag) == null) {
      semanticErrorExpectedModifier(log, symbol.node.declarationName().range, symbolFlagToName.get(flag), where);
    }
  }

  void initializeVariable(Symbol symbol) {
    unexpectedModifierIfPresent(symbol, SymbolFlag.VIRTUAL, "on a variable declaration");
    unexpectedModifierIfPresent(symbol, SymbolFlag.OVERRIDE, "on a variable declaration");
    if (symbol.enclosingSymbol == null || !symbol.enclosingSymbol.kind.isTypeWithInstances()) {
      unexpectedModifierIfPresent(symbol, SymbolFlag.STATIC, "outside an object declaration");
    }
    if (symbol.enclosingSymbol != null && symbol.enclosingSymbol.kind == SymbolKind.STRUCT && !symbol.isStatic()) {
      expectedModifierIfAbsent(symbol, SymbolFlag.FINAL, "on a variable declaration inside a struct");
    }

    Node node = symbol.node;
    Node variableType = node.variableType();
    if (variableType == null) {

      // Take the variable type from the enclosing variable cluster
      if (node.parent.kind == NodeKind.VARIABLE_CLUSTER) {
        variableType = node.parent.clusterType().clone();
      }

      // Take the variable type from the enclosing enum declaration
      else if (symbol.enclosingSymbol != null) {
        assert symbol.isEnumValue();
        Type type = symbol.enclosingSymbol.type;
        variableType = Node.createType(type);

        // All enum values are final
        symbol.flags = symbol.flags | SymbolFlag.FINAL;

        // Look at the initializer now
        Node variableValue = node.variableValue();
        if (variableValue != null) {
          resolveAsExpressionWithConversion(variableValue, cache.intType, CastKind.IMPLICIT);
          constantFolder.foldConstants(variableValue);
          if (variableValue.kind == NodeKind.INT) {
            symbol.enumValue = variableValue.asInt();
          } else {
            variableType = Node.createType(cache.errorType);
            if (!variableValue.type.isError(cache)) {
              semanticErrorBadIntegerConstant(log, variableValue.range, variableValue.type);
            }
          }
        }

        // If there is no initializer, create a value based on the previous enum value
        else {
          int index = node.parent.children.indexOf(node);
          if (index > 0) {
            Symbol previous = node.parent.children.get(index - 1).symbol;
            initializeSymbol(previous);
            if (!previous.type.isError(cache)) {
              symbol.enumValue = type.isEnumFlags() ? previous.enumValue * 2 : previous.enumValue + 1;
            } else {
              variableType = Node.createType(cache.errorType);
            }
          }

          // If there is no previous enum value, use the default value
          else {
            symbol.enumValue = type.isEnumFlags() ? 1 : 0;
          }
        }
      }

      // If there is still no variable type, assume an error has been logged
      // already and just use the error type. This is the case when a lambda
      // expression lacks type context.
      else {
        assert node.parent.kind == NodeKind.LAMBDA;
        variableType = Node.createType(cache.errorType);
      }

      assert variableType != null;
      node.replaceChild(1, variableType);
    }

    // Handle implicitly typed variables by taking the type from the assigned value
    if (variableType.kind == NodeKind.VAR) {
      Node value = node.variableValue();
      if (value == null) {
        semanticErrorVarMissingValue(log, node.declarationName().range);
        symbol.type = cache.errorType;
      } else {
        resolveAsExpression(value);
        Type type = value.type;
        if (type.isNull(cache) || type.isVoid(cache)) {
          semanticErrorVarBadType(log, node.declarationName().range, type);
          symbol.type = cache.errorType;
        } else {
          symbol.type = type;
        }
      }
    }

    // Resolve the expression for the variable type
    else {
      resolveAsParameterizedType(variableType);
      checkIsValidVariableType(variableType);
      symbol.type = variableType.type;
    }

    // Variables must not override other symbols
    Member overriddenMember = symbol.overriddenMember;
    if (overriddenMember != null) {
      initializeMember(overriddenMember);
      Type base = overriddenMember.type;
      Type derived = symbol.type;
      if (!base.isError(cache) && !derived.isError(cache)) {
        semanticErrorBadOverride(log, node.declarationName().range, symbol.name,
          overriddenMember.symbol.enclosingSymbol.type, overriddenMember.symbol.node.declarationName().range);
      }
    }
  }

  void initializeParameter(Symbol symbol) {
    Type type = symbol.type = new Type(symbol);
    Node bound = symbol.node.parameterBound();

    // Type parameters can optionally have a single interface as an upper bound.
    // This forces all parameterizations to implement that interface and allows
    // use of that interface inside the scope of the parameter:
    //
    //   interface IFoo {
    //     void foo();
    //   }
    //
    //   class Foo<T is IFoo> {
    //     void foo(T value) {
    //       value.foo();
    //     }
    //   }
    //
    if (bound != null) {
      resolveAsParameterizedType(bound);
      Type boundType = bound.type;
      if (boundType.isError(cache)) {
        symbol.type = cache.errorType;
      } else if (!boundType.isInterface()) {
        semanticErrorBadTypeParameterBound(log, bound.range, boundType);
      } else {
        assert type.relevantTypes == null;
        type.relevantTypes = { boundType };
        type.copyMembersFrom(boundType);
      }
    }
  }

  void initializeUsingAlias(Symbol symbol) {
    Node value = symbol.node.usingAliasValue();
    resolveAsParameterizedType(value);
    symbol.type = value.type;
  }

  void initializeDeclaration(Node node) {
    // The symbol should already have been set
    Symbol symbol = node.symbol;
    assert symbol != null;

    // Only initialize once
    if (symbol.isUninitialized()) {
      // Flag the symbol's as initializing for the duration of the declaration's
      // initialization. This way we can detect cycles that try to use the symbol
      // in its own type, such as "foo foo;" or "class Foo : Foo {}". Cyclic
      // symbol references will return the error type in this case.
      symbol.flags = symbol.flags | SymbolFlag.INITIALIZING;

      // Resolve using node.symbol.node to start from the first node in the
      // sibling chain to ensure that the entire chain is processed at once
      ResolveContext oldContext = context;
      Type oldTypeContext = typeContext;
      Type oldResultType = resultType;
      context = ResolveContext.fromNode(node); // TODO: Cache this?
      typeContext = null;
      resultType = null;
      switch (symbol.kind) {
        case SymbolKind.NAMESPACE { initializeNamespace(symbol); }
        case SymbolKind.ENUM, SymbolKind.ENUM_FLAGS { initializeEnum(symbol); }
        case SymbolKind.CLASS, SymbolKind.STRUCT, SymbolKind.INTERFACE { initializeObject(symbol); }
        case SymbolKind.GLOBAL_FUNCTION, SymbolKind.INSTANCE_FUNCTION, SymbolKind.CONSTRUCTOR_FUNCTION { initializeFunction(symbol); }
        case SymbolKind.LOCAL_VARIABLE, SymbolKind.GLOBAL_VARIABLE, SymbolKind.INSTANCE_VARIABLE { initializeVariable(symbol); }
        case SymbolKind.PARAMETER { initializeParameter(symbol); }
        case SymbolKind.USING_ALIAS { initializeUsingAlias(symbol); }
        case SymbolKind.OTHER {}
        default { assert false; }
      }
      context = oldContext;
      typeContext = oldTypeContext;
      resultType = oldResultType;

      // Update the type now that cycle detection is complete
      assert symbol.type != null;
      assert symbol.isInitializing();
      assert !symbol.isInitialized();
      symbol.flags = (symbol.flags & ~SymbolFlag.INITIALIZING) | SymbolFlag.INITIALIZED;
    }
  }

  void initializePotentiallyDuplicatedMember(Member member, Range range) {
    // Ambiguous symbols are the result of multiple using namespace statements
    Symbol symbol = member.symbol;
    if (symbol.kind == SymbolKind.AMBIGUOUS) {
      List<string> names = {};
      int i;
      for (i = 0; i < symbol.identicalMembers.length; i++) {
        names.push(symbol.identicalMembers.get(i).symbol.fullName());
      }
      semanticErrorAmbiguousSymbol(log, range, symbol.name, names);
      member.type = symbol.type = cache.errorType;
      return;
    }

    initializeMember(member);
  }

  void initializeMember(Member member) {
    // Only initialize the member once
    if (member.type != null) {
      return;
    }

    // The type of a member in a derived type may depend on type substitution
    // on that member's type in a base class:
    //
    //   class Foo<A, B> { A foo(B bar) {} }
    //   class Bar<T> : Foo<int, T> {}
    //   class Baz : Bar<bool> {}
    //   int baz = new Baz().foo(false);
    //
    if (member.dependency != null) {
      initializeMember(member.dependency);
      member.type = member.dependency.type;
      if (member.symbol.kind.isConstructor() && member.type.isFunction()) {
        member.type.relevantTypes.set(0, member.enclosingType);
      }
    } else {
      initializeSymbol(member.symbol);
      member.type = member.symbol.type;
    }

    // Perform a lazy type substitution for members on generic types
    Type parameterizedType = member.parameterizedType;
    if (parameterizedType != null && parameterizedType.isParameterized()) {
      member.type = cache.substitute(member.type, parameterizedType.symbol.parameters, parameterizedType.substitutions);
    }
  }

  void generateDefaultConstructor(Symbol symbol) {
    Symbol enclosingSymbol = symbol.enclosingSymbol;
    List<Member> members = enclosingSymbol.type.members.values();
    List<Node> arguments = {};
    List<Node> superArguments = null;
    List<Node> memberInitializers = {};

    // Add arguments for each base constructor argument
    Type baseClass = enclosingSymbol.type.isClass() ? enclosingSymbol.type.baseClass() : null;
    if (baseClass != null) {
      Member constructor = baseClass.constructor();
      if (constructor != null) {
        initializeMember(constructor);
        if (constructor.type.isFunction()) {
          List<Type> argumentTypes = constructor.type.argumentTypes();
          int j;
          superArguments = {};
          for (j = 0; j < argumentTypes.length; j++) {
            string name = "_".append(arguments.length.toString());
            Node argument = Node.createVariable(Node.createName(name), Node.createType(argumentTypes.get(j)), null);
            argument.symbol = new Symbol(name, SymbolKind.LOCAL_VARIABLE);
            argument.symbol.node = argument;
            arguments.push(argument);
            superArguments.push(Node.createName(name));
          }
        } else {
          assert constructor.type.isError(cache);
          symbol.flags = symbol.flags | SymbolFlag.INITIALIZED;
          symbol.type = cache.errorType;
          return;
        }
      }
    }

    // Add arguments for each uninitialized instance variable
    int i;
    List<Member> uninitializedMembers = {};
    for (i = 0; i < members.length; i++) {
      Member member = members.get(i);
      Symbol memberSymbol = member.symbol;
      if (memberSymbol.kind == SymbolKind.INSTANCE_VARIABLE && memberSymbol.enclosingSymbol == enclosingSymbol && memberSymbol.node.variableValue() == null) {
        initializeMember(member);
        if (member.type.isError(cache)) {
          symbol.flags = symbol.flags | SymbolFlag.INITIALIZED;
          symbol.type = cache.errorType;
          return;
        }
        uninitializedMembers.push(member);
      }
    }

    // Sort the uninitialized members by source location
    for (i = 1; i < uninitializedMembers.length; i++) {
      Member member = uninitializedMembers.get(i);
      int j;
      for (j = i; j > 0 && uninitializedMembers.get(j - 1).symbol.node.range.start > member.symbol.node.range.start; j--) {
        assert uninitializedMembers.get(j - 1).symbol.node.range.source == member.symbol.node.range.source;
        uninitializedMembers.set(j, uninitializedMembers.get(j - 1));
      }
      uninitializedMembers.set(j, member);
    }

    // Append each uninitialized member argument now that they are sorted
    for (i = 0; i < uninitializedMembers.length; i++) {
      Member member = uninitializedMembers.get(i);
      string name = "_".append(arguments.length.toString());
      Node argument = Node.createVariable(Node.createName(name), Node.createType(member.type), null);
      argument.symbol = new Symbol(name, SymbolKind.LOCAL_VARIABLE);
      argument.symbol.node = argument;
      arguments.push(argument);
      memberInitializers.push(Node.createMemberInitializer(Node.createName(member.symbol.name), Node.createName(name)));
    }

    // Change the automatic symbol into a constructor symbol
    symbol.kind = SymbolKind.CONSTRUCTOR_FUNCTION;
    symbol.node = Node.createConstructor(
      Node.createName(symbol.name),
      Node.createNodeList(arguments),
      Node.createBlock({}),
      superArguments != null ? Node.createSuperCall(superArguments) : null,
      memberInitializers != null ? Node.createNodeList(memberInitializers) : null);

    // Initialize the scope ourselves since that pass is already over
    assert enclosingSymbol.node.scope != null;
    Scope scope = new Scope(enclosingSymbol.node.scope);
    symbol.node.symbol = symbol;
    symbol.node.scope = scope;
    for (i = 0; i < arguments.length; i++) {
      scope.insert(arguments.get(i).symbol);
    }
  }

  void initializeSymbol(Symbol symbol) {
    // Handle auto-generated symbols now
    if (symbol.kind == SymbolKind.AUTOMATIC) {
      if (symbol.name == "new") {
        generateDefaultConstructor(symbol);
      }

      // Automatically generated symbols need to be explicitly resolved because
      // they aren't reachable from the parse tree, only from the type cache
      if (symbol.node != null) {
        resolve(symbol.node, null);
      }
    }

    // Unmerged symbols are the result of multiple base types
    if (symbol.kind == SymbolKind.UNMERGED) {
      if (symbol.type != null) {
        return;
      }
      List<Type> types = {};
      int i;
      for (i = 0; i < symbol.identicalMembers.length; i++) {
        Member identical = symbol.identicalMembers.get(i);
        initializeMember(identical);
        Type type = identical.type;
        int index = types.indexOf(type);
        if (index < 0) types.push(type);
      }
      if (types.length != 1) {
        semanticErrorUnmergedSymbol(log, symbol.enclosingSymbol.node.declarationName().range, symbol.fullName(), types);
        symbol.type = cache.errorType;
      } else {
        symbol.type = types.get(0);
      }
      return;
    }

    // Only initialize the symbol once
    if (symbol.isUninitialized()) {
      assert symbol.node != null; // Internal symbols have no node but should already have a type
      initializeDeclaration(symbol.node);
      assert !symbol.isInitializing();
      assert symbol.isInitialized();
      assert symbol.type != null;
    }

    // Detect cyclic symbol references such as "foo foo;"
    else if (symbol.isInitializing()) {
      semanticErrorCyclicDeclaration(log, symbol.node.firstNonExtensionSibling().declarationName().range, symbol.name);
      symbol.type = cache.errorType;
    }
  }

  void unsupportedNodeKind(Node node) {
    // log.error(node.range, "TODO: Support nodes of kind ".append(node.kind.toString()));
  }

  void resolveArguments(List<Node> arguments, List<Type> argumentTypes, Range outer, Range inner) {
    // Validate the argument count
    if (argumentTypes.length != arguments.length) {
      Range range = Range.equal(outer, inner) ? outer : Range.after(outer, inner);
      semanticErrorArgumentCount(log, range, argumentTypes.length, arguments.length);
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Validate the arguments and provide type context
    int i;
    for (i = 0; i < arguments.length; i++) {
      resolveAsExpressionWithConversion(arguments.get(i), argumentTypes.get(i), CastKind.IMPLICIT);
    }
  }

  void resolveAsType(Node node) {
    assert node.kind.isExpression();
    resolve(node, null);
    checkIsType(node);
  }

  void resolveAsParameterizedType(Node node) {
    resolveAsType(node);
    checkIsParameterized(node);
  }

  void resolveAsExpression(Node node) {
    assert node.kind.isExpression();
    resolve(node, null);
    checkIsInstance(node);
  }

  void resolveAsExpressionWithTypeContext(Node node, Type type) {
    assert node.kind.isExpression();
    resolve(node, type);
    checkIsInstance(node);
  }

  void resolveAsExpressionWithConversion(Node node, Type type, CastKind kind) {
    assert node.kind.isExpression();
    resolve(node, type);
    checkIsInstance(node);
    if (type != null) checkConversion(type, node, kind);
  }

  void resolveNodes(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      resolve(nodes.get(i), null);
    }
  }

  void resolveNodesAsExpressions(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      resolveAsExpression(nodes.get(i));
    }
  }

  void resolveNodesAsVariableTypes(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      Node node = nodes.get(i);
      resolveAsParameterizedType(node);
      checkIsValidVariableType(node);
    }
  }

  void resolveChildren(Node node) {
    if (node.hasChildren()) {
      resolveNodes(node.children);
    }
  }

  void resolveProgram(Node node) {
    assert node.parent == null;
    resolveChildren(node);
  }

  void resolveFile(Node node) {
    assert node.parent != null;
    assert node.parent.kind == NodeKind.PROGRAM;
    resolve(node.fileBlock(), null);
  }

  void resolveBlock(Node node) {
    resolveChildren(node);
  }

  void resolveCase(Node node) {
    assert node.parent != null;
    assert node.parent.kind == NodeKind.SWITCH;
    assert context.switchValue != null;
    assert context.switchValue.type != null;
    List<Node> values = node.caseValues();
    Node block = node.caseBlock();
    int i;
    for (i = 0; i < values.length; i++) {
      Node value = values.get(i);
      resolveAsExpressionWithConversion(value, context.switchValue.type, CastKind.IMPLICIT);
      constantFolder.foldConstants(value);

      // All case values must be constants but can include enum values
      if (!value.type.isError(cache) && !value.kind.isConstant()) {
        semanticErrorNonConstantCaseValue(log, value.range);
        value.type = cache.errorType;
      }
    }
    resolve(block, null);
  }

  void resolveUsingNamespace(Node node) {
    checkInsideBlock(node);
  }

  void resolveNamespace(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    initializeSymbol(node.symbol);
    resolve(node.declarationBlock(), null);
  }

  void resolveEnum(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    initializeSymbol(node.symbol);
    resolve(node.declarationBlock(), null);
  }

  void resolveObject(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    initializeSymbol(node.symbol);

    // Force the resolution of all base type members in case some of them are
    // still unmerged. If this is not done for each object type, then some
    // conflicts will remain undetected until used:
    //
    //   interface Foo { bool foo(); }
    //   interface Bar { int foo(); }
    //   interface Baz : Foo, Bar {}
    //
    List<Member> members = node.symbol.type.members.values();
    int i;
    for (i = 0; i < members.length; i++) {
      Member member = members.get(i);
      if (member.symbol.kind == SymbolKind.UNMERGED) {
        initializeMember(member);
      }
    }

    Node oldObject = context.object;
    context.object = node;

    // Ensure the default constructor is generated if needed
    Member constructor = node.symbol.type.constructor();
    if (constructor != null) {
      initializeMember(constructor);
    }

    resolve(node.declarationBlock(), null);
    context.object = oldObject;
  }

  void resolveExtension(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    initializeSymbol(node.symbol);

    Node oldObject = context.object;
    if (node.symbol.kind.isObject()) {
      context.object = node.symbol.node.firstNonExtensionSibling();
      assert context.object.kind.isObject();
    }
    resolve(node.declarationBlock(), null);
    context.object = oldObject;
  }

  void resolveFunction(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_OR_OBJECT_LEVEL);
    initializeSymbol(node.symbol);

    Node oldFunction = context.function;
    context.function = node;

    // Resolve the function block
    Node block = node.functionBlock();
    if (block != null) {
      Type oldResultType = resultType;

      // Special-case the return type of constructors to void for the purpose
      // of type conversions in return statements inside the constructor
      Symbol symbol = node.symbol;
      if (symbol.type.isError(cache)) resultType = cache.errorType;
      else if (symbol.kind.isConstructor()) resultType = cache.voidType;
      else resultType = symbol.type.resultType();
      resolve(block, null);

      resultType = oldResultType;
    }

    // Resolve the initializer list
    if (node.kind == NodeKind.CONSTRUCTOR) {
      // Get the base constructor type
      Member overriddenMember = node.symbol.overriddenMember;
      Type overriddenType = cache.errorType;
      if (overriddenMember != null) {
        initializeMember(overriddenMember);
        overriddenType = overriddenMember.type;
      }

      // Resolve the super initializer
      Node superInitializer = node.superInitializer();
      if (superInitializer != null) {
        if (overriddenMember != null) {
          superInitializer.symbol = overriddenMember.symbol;
        } else {
          semanticErrorBadSuperInitializer(log, superInitializer.range);
        }

        // Resolve the arguments
        List<Node> arguments = superInitializer.superCallArguments();
        if (overriddenType.isError(cache)) {
          resolveNodesAsExpressions(arguments);
        } else {
          assert overriddenType.isFunction();
          resolveArguments(arguments, overriddenType.argumentTypes(), superInitializer.range, superInitializer.range);
        }
      }

      // Automatically insert a call to the base constructor if possible
      else if (overriddenType.isFunction()) {
        if (overriddenType.argumentTypes().length > 0) {
          semanticErrorMissingSuperInitializer(log, node.declarationName().range);
        } else {
          node.children.set(3, Node.createSuperCall({}).withSymbol(overriddenMember.symbol));
        }
      }

      // Resolve the member initializers
      Node memberInitializers = node.memberInitializers();
      if (memberInitializers != null) {
        int i;
        for (i = 0; i < memberInitializers.children.length; i++) {
          Node memberInitializer = memberInitializers.children.get(i);
          Scope oldScope = context.scope;
          context.scope = node.scope.lexicalParent;
          resolve(memberInitializer.memberInitializerName(), null);
          context.scope = oldScope;
          resolveAsExpression(memberInitializer.memberInitializerValue());
        }
      }
    }

    context.function = oldFunction;
  }

  void resolveVariable(Node node) {
    Symbol symbol = node.symbol;
    initializeSymbol(symbol);
    Node value = node.variableValue();

    // Prevent instance variables inside interfaces. Also prevent instance
    // variables without initial values in extension blocks because default
    // constructors need to order their arguments.
    Symbol enclosingSymbol = symbol.enclosingSymbol;
    if (!symbol.isStatic() && enclosingSymbol != null) {
      Type enclosingSymbolType = enclosingSymbol.type;
      if (enclosingSymbolType.isInterface() || symbol.isFromExtension() && enclosingSymbolType.isEnum()) {
        unexpectedStatement(node);
      } else if (symbol.isFromExtension() && enclosingSymbol.kind.isTypeWithInstances() && value == null) {
        semanticErrorUninitializedExtensionVariable(log, node.declarationName().range);
      }
    }

    // Enum values are resolved as ints instead of as the enum type because ints
    // don't implicitly convert to enums.
    if (value != null) {
      resolveAsExpressionWithConversion(value, symbol.isEnumValue() ? cache.intType : symbol.type, CastKind.IMPLICIT);
    }
  }

  void resolveVariableCluster(Node node) {
    // This must not initialize node.clusterType() here for circular declaration
    // detection to work correctly ("foo foo;" is a circular declaration)
    resolveNodes(node.clusterVariables());
  }

  void resolveParameter(Node node) {
    initializeSymbol(node.symbol);
  }

  void resolveUsingAlias(Node node) {
    checkInsideBlock(node);
    if (node.symbol != null) {
      initializeSymbol(node.symbol);
    }
  }

  void resolveIf(Node node) {
    checkStatementLocation(node);
    resolveAsExpressionWithConversion(node.ifTest(), cache.boolType, CastKind.IMPLICIT);
    resolve(node.ifTrue(), null);
    if (node.ifFalse() != null) resolve(node.ifFalse(), null);
  }

  void resolveFor(Node node) {
    checkStatementLocation(node);
    Node setup = node.forSetup();
    Node test = node.forTest();
    Node update = node.forUpdate();
    if (setup != null) {
      if (setup.kind == NodeKind.VARIABLE_CLUSTER) resolve(setup, null);
      else resolveAsExpression(setup);
    }
    if (test != null) resolveAsExpressionWithConversion(test, cache.boolType, CastKind.IMPLICIT);
    if (update != null) resolveAsExpression(update);

    Node oldLoop = context.loop;
    context.loop = node;
    resolve(node.forBlock(), null);
    context.loop = oldLoop;
  }

  void resolveForEach(Node node) {
    unsupportedNodeKind(node);
    checkStatementLocation(node);
    resolve(node.forEachVariable(), null);

    resolve(node.forEachValue(), null);
    Node oldLoop = context.loop;
    context.loop = node;
    resolve(node.forEachBlock(), null);
    context.loop = oldLoop;
  }

  void resolveWhile(Node node) {
    checkStatementLocation(node);
    Node test = node.whileTest();
    if (test != null) resolveAsExpressionWithConversion(test, cache.boolType, CastKind.IMPLICIT);

    Node oldLoop = context.loop;
    context.loop = node;
    resolve(node.whileBlock(), null);
    context.loop = oldLoop;
  }

  void resolveReturn(Node node) {
    Node value = node.returnValue();

    // Return statements must live inside functions
    if (resultType == null) {
      unexpectedStatement(node);
      if (value != null) resolveAsExpression(value);
      return;
    }

    // Check the return value
    if (value != null) {
      resolveAsExpressionWithConversion(value, resultType, CastKind.IMPLICIT);
    }

    // The return value may be missing only when the return type is void
    else if (!resultType.isError(cache) && !resultType.isVoid(cache)) {
      semanticErrorExpectedReturnValue(log, node.range, resultType);
    }
  }

  void resolveBreak(Node node) {
    if (context.loop == null) {
      unexpectedStatement(node);
    }
  }

  void resolveContinue(Node node) {
    if (context.loop == null) {
      unexpectedStatement(node);
    }
  }

  void resolveAssert(Node node) {
    checkStatementLocation(node);
    resolveAsExpressionWithConversion(node.assertValue(), cache.boolType, CastKind.IMPLICIT);
  }

  void resolveExpression(Node node) {
    checkStatementLocation(node);
    Node value = node.expressionValue();
    resolveAsExpression(value);
    checkUnusedExpression(value);
  }

  void resolveSwitch(Node node) {
    checkStatementLocation(node);
    Node value = node.switchValue();
    List<Node> cases = node.switchCases();
    resolveAsExpression(value);

    Node oldSwitchValue = context.switchValue;
    context.switchValue = value;
    resolveNodes(cases);
    context.switchValue = oldSwitchValue;

    int i;
    List<Node> uniqueValues = {};
    for (i = 0; i < cases.length; i++) {
      Node child = cases.get(i);

      // Require only one default case and make sure it's last. That way this
      // switch statement can be converted to an if-else chain without moving
      // the user's code around.
      if (child.children.length == 1 && i < cases.length - 1) {
        semanticErrorBadDefaultCase(log, child.range);
      }

      // Check previous values for duplicates
      List<Node> caseValues = child.caseValues();
      int j;
      for (j = 0; j < caseValues.length; j++) {
        Node caseValue = caseValues.get(j);
        if (caseValue.type.isError(cache)) continue;
        assert caseValue.kind.isConstant();

        int k;
        for (k = 0; k < uniqueValues.length; k++) {
          Node original = uniqueValues.get(k);
          if (original.kind == caseValue.kind && Content.equal(original.content, caseValue.content)) {
            semanticErrorDuplicateCase(log, caseValue.range, original.range);
            break;
          }
        }

        if (k == uniqueValues.length) {
          uniqueValues.push(caseValue);
        }
      }
    }
  }

  void resolveModifier(Node node) {
    resolveNodes(node.modifierStatements());
  }

  void resolveName(Node node) {
    string name = node.asString();
    Member member = context.scope.find(name);
    if (member == null) {
      semanticErrorUndeclaredSymbol(log, node.range, name);
      return;
    }
    initializePotentiallyDuplicatedMember(member, node.range);
    node.symbol = member.symbol;

    // Instance members inside an object must have access to "this"
    if (!checkAccessToInstanceSymbol(node)) {
      node.type = cache.errorType;
      return;
    }

    // Wrap type symbols in a type node to distinguish them from instances
    if (member.symbol.kind.isType()) {
      node.become(Node.createType(member.type).withRange(node.range));
      return;
    }

    node.type = member.type;
  }

  void resolveThis(Node node) {
    if (checkAccessToThis(node.range)) {
      assert context.object != null;
      Symbol symbol = context.object.symbol;
      initializeSymbol(symbol);
      node.type = symbol.type;
    }
  }

  void resolveHook(Node node) {
    Node trueNode = node.hookTrue();
    Node falseNode = node.hookFalse();
    resolveAsExpressionWithConversion(node.hookTest(), cache.boolType, CastKind.IMPLICIT);

    // Resolve both branches with type context but don't warn about type
    // conversion problems yet (warning later gives better error messages)
    resolveAsExpressionWithTypeContext(trueNode, typeContext);
    resolveAsExpressionWithTypeContext(falseNode, typeContext);

    // Avoid reporting further errors
    Type trueType = trueNode.type;
    Type falseType = falseNode.type;
    if (trueType.isError(cache) || falseType.isError(cache)) {
      return;
    }

    // Ensure both branches can implicitly convert to a common type
    Type commonType = cache.commonImplicitType(trueType, falseType);
    if (commonType == null) {

      // As a fallback, try to disambiguate by how the result will be used
      commonType = typeContext;
      if (commonType == null || !cache.canImplicitlyConvert(trueType, commonType) || !cache.canImplicitlyConvert(falseType, commonType)) {
        semanticErrorNoCommonType(log, Range.span(trueNode.range, falseNode.range), trueType, falseType);
        return;
      }
    }

    // Finally, check that the conversion works. This check must be done
    // even when using the common type because it inserts implicit casts.
    checkConversion(commonType, trueNode, CastKind.IMPLICIT);
    checkConversion(commonType, falseNode, CastKind.IMPLICIT);
    node.type = commonType;
  }

  void resolveInitializer(Node node) {
    List<Node> values = node.initializerValues();

    // The type of the literal comes from how it's used
    if (typeContext == null) {
      semanticErrorMissingTypeContext(log, node.range);
      resolveNodesAsExpressions(values);
      return;
    }

    // Avoid reporting further errors
    if (typeContext.isError(cache)) {
      resolveNodesAsExpressions(values);
      return;
    }

    // Special-case list initializers
    if (typeContext.isList(cache)) {
      Type itemType = typeContext.substitutions.get(0);
      int i;
      for (i = 0; i < values.length; i++) {
        resolveAsExpressionWithConversion(values.get(i), itemType, CastKind.IMPLICIT);
      }
      node.type = typeContext;
      return;
    }

    // Resolve this initializer expression as a constructor call expression
    node.become(Node.createCall(Node.createType(typeContext).withRange(node.range), node.removeChildren()).withRange(node.range));
    resolveAsExpression(node);
  }

  void resolveDot(Node node) {
    // The target may be null, which means to use the type context instead
    Node target = node.dotTarget();
    if (target != null) {
      resolve(target, null);
    }

    // Avoid reporting further errors
    Type type = target != null ? target.type : typeContext;
    if (type == null) {
      semanticErrorMissingTypeContext(log, node.range);
      return;
    }
    if (type.isError(cache)) {
      return;
    }

    // The name allowed to be null for autocomplete
    Node dotName = node.dotName();
    if (dotName == null) {
      return;
    }
    string name = dotName.asString();

    // Search for the member symbol
    Member member = type.findMember(name);
    if (member == null) {
      semanticErrorUnknownMemberSymbol(log, dotName.range, name, type);
      return;
    }
    node.symbol = member.symbol;
    initializePotentiallyDuplicatedMember(member, dotName.range);

    // Check the instance/static status of the member
    bool symbolIsType = member.symbol.kind.isType();
    bool targetIsType = target == null || target.kind.isType();
    if (!type.isNamespace() && !type.isEnum()) {
      bool isStatic = symbolIsType || member.symbol.isStatic();

      // Static members can only be accessed from a type
      if (isStatic && !targetIsType) {
        semanticErrorMemberUnexpectedStatic(log, dotName.range, name);
      }

      // Instance members can only be accessed from an instance
      else if (!isStatic && targetIsType) {
        semanticErrorMemberUnexpectedInstance(log, dotName.range, name);
      }
    }

    // Update this node using the member member
    if (symbolIsType) node.become(Node.createType(member.type).withRange(node.range));
    else if (targetIsType) node.become(Node.createName(member.symbol.name).withRange(node.range).withSymbol(member.symbol).withType(member.type));
    else node.type = member.type;
  }

  void resolveCall(Node node) {
    Node value = node.callValue();
    List<Node> arguments = node.callArguments();

    // Special-case immediately-invoked lambdas to provide type context from the arguments
    if (value.kind == NodeKind.LAMBDA && typeContext != null) {
      resolveNodesAsExpressions(arguments);

      // Avoid reporting further errors
      if (typeContext.isError(cache)) {
        resolveAsExpression(value);
        return;
      }

      // Use the argument types as type context for the value being called
      List<Type> argumentTypes = {};
      int i;
      for (i = 0; i < arguments.length; i++) {
        Type type = arguments.get(i).type;
        if (type.isError(cache)) {
          resolveAsExpression(value);
          return;
        }
        argumentTypes.push(type);
      }
      resolveAsExpressionWithConversion(value, cache.functionType(typeContext, argumentTypes), CastKind.IMPLICIT);
    }

    // Otherwise, resolve the value and use that to provide type context to the arguments
    else {
      assert value.kind.isExpression();
      resolve(value, null);
      if (value.kind.isType()) {
        checkIsParameterized(value);
      }
      Type valueType = value.type;

      // Avoid reporting further errors
      if (valueType.isError(cache)) {
        resolveNodesAsExpressions(arguments);
        return;
      }

      // Types are constructed by calling the type, which forwards to the constructor
      if (value.kind.isType()) {
        Member member = valueType.constructor();
        if (member == null) {
          semanticErrorUnconstructableType(log, value.range, valueType);
          resolveNodesAsExpressions(arguments);
          return;
        }
        initializeMember(member);
        node.symbol = member.symbol;
        valueType = member.type;

        // Avoid reporting further errors
        if (valueType.isError(cache)) {
          resolveNodesAsExpressions(arguments);
          return;
        }
      }

      // Can only call an instance of a function type
      if (!valueType.isFunction()) {
        semanticErrorInvalidCall(log, value.range, valueType);
        resolveNodesAsExpressions(arguments);
        return;
      }

      // Set the result type now even if the arguments are incorrect
      node.type = valueType.resultType();
      resolveArguments(arguments, valueType.argumentTypes(), node.range, value.range);
    }
  }

  void resolveSuperCall(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveSequence(Node node) {
    assert node.hasChildren();
    int i;
    int n;
    for (i = 0, n = node.children.length; i < n; i++) {
      Node child = node.children.get(i);
      if (i < n - 1) {
        resolveAsExpression(child);
        checkUnusedExpression(child);
      } else {
        resolveAsExpressionWithConversion(child, typeContext, node.parent.kind == NodeKind.CAST ? CastKind.EXPLICIT : CastKind.IMPLICIT);
      }
    }
  }

  void resolveParameterize(Node node) {
    Node parameterizeType = node.parameterizeType();
    List<Node> substitutions = node.parameterizeTypes();
    resolveAsType(parameterizeType);
    resolveNodesAsVariableTypes(substitutions);

    // Avoid reporting further errors
    Type unparameterized = parameterizeType.type;
    if (unparameterized.isError(cache)) {
      return;
    }

    // Check that the type is parameterizable
    if (!unparameterized.hasParameters() || unparameterized.isParameterized()) {
      semanticErrorCannotParameterize(log, parameterizeType.range, unparameterized);
      return;
    }

    // Validate the type parameter count
    List<Symbol> parameters = unparameterized.symbol.parameters;
    List<Symbol> sortedParameters = unparameterized.symbol.sortedParameters;
    if (parameters.length != substitutions.length) {
      semanticErrorParameterCount(log, Range.after(node.range, parameterizeType.range), parameters.length, substitutions.length);
      return;
    }
    assert parameters.length == sortedParameters.length;

    // Fill in the type parameters, which must be done in order of dependencies
    // to dependents. Type parameters aren't allowed to form cycles but they
    // can still form a DAG of dependencies.
    List<Type> sortedTypes = {};
    int i;
    for (i = 0; i < sortedParameters.length; i++) {
      Symbol parameter = sortedParameters.get(i);
      int index = parameters.indexOf(parameter);
      Node substitution = substitutions.get(index);
      if (parameter.type.isError(cache)) return;
      Type bound = parameter.type.bound();
      if (bound != null) {
        if (i > 0) bound = cache.substitute(bound, sortedParameters.slice(0, i), sortedTypes.slice(0, i));
        checkConversion(bound, substitution, CastKind.IMPLICIT);
      }
      if (substitution.type.isError(cache)) return;
      sortedTypes.push(substitution.type);
    }

    // Only parameterize the type if no errors were found in the type parameters
    List<Type> types = {};
    for (i = 0; i < substitutions.length; i++) types.push(substitutions.get(i).type);
    node.become(Node.createType(cache.parameterize(unparameterized, types)).withRange(node.range));
  }

  void resolveCast(Node node) {
    Node type = node.castType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    resolveAsExpressionWithConversion(node.castValue(), type.type, CastKind.EXPLICIT);
    node.type = type.type;
  }

  void resolveLambda(Node node) {
    Type oldResultType = resultType;
    Node oldLoop = context.loop;
    resultType = cache.errorType;
    context.loop = null;

    List<Node> arguments = node.lambdaArguments();
    Node block = node.lambdaBlock();

    // Lambdas require type context instead of attempting type inference
    if (typeContext == null) {
      semanticErrorMissingTypeContext(log, node.range);
    }

    else if (!typeContext.isError(cache)) {
      if (!typeContext.isFunction()) {
        semanticErrorBadLambdaTypeContext(log, node.range, typeContext);
      }

      else if (!typeContext.isError(cache)) {
        // Set the expression type now even if the arguments are incorrect
        List<Type> argumentTypes = typeContext.argumentTypes();
        resultType = typeContext.resultType();
        node.type = typeContext;

        // Validate the argument count
        if (argumentTypes.length != arguments.length) {
          semanticErrorArgumentCount(log, node.range, argumentTypes.length, arguments.length);
        }

        // Give each argument variable the corresponding type from the function signature
        else {
          int i;
          for (i = 0; i < arguments.length; i++) {
            assert arguments.get(i).variableType() == null;
            arguments.get(i).children.set(1, Node.createType(argumentTypes.get(i)));
          }
        }
      }
    }

    resolveNodes(arguments);
    resolve(block, null);

    resultType = oldResultType;
    context.loop = oldLoop;
  }

  void resolveDefault(Node node) {
    Node type = node.defaultType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    node.type = type.type;
  }

  void resolveVar(Node node) {
    semanticErrorUnexpectedNode(log, node.range, node.kind);
  }

  void resolveFunctionType(Node node) {
    Node result = node.functionTypeResult();
    List<Node> arguments = node.functionTypeArguments();
    resolveAsParameterizedType(result);
    resolveNodesAsVariableTypes(arguments);
    if (!result.type.isError(cache)) {
      List<Type> argumentTypes = {};
      int i;
      for (i = 0; i < arguments.length; i++) {
        Type argumentType = arguments.get(i).type;
        if (argumentType.isError(cache)) {
          return;
        }
        argumentTypes.push(argumentType);
      }
      node.become(Node.createType(cache.functionType(result.type, argumentTypes)).withRange(node.range));
    }
  }

  void resolveUnaryOperator(Node node) {
    NodeKind kind = node.kind;
    Node value = node.unaryValue();
    resolveAsExpression(value);

    // Avoid reporting further errors
    Type type = value.type;
    if (type.isError(cache)) {
      return;
    }

    if (kind == NodeKind.POSITIVE || kind == NodeKind.NEGATIVE) {
      if (type.isEnum()) {
        node.type = cache.intType;
      } else if (type.isNumeric(cache)) {
        node.type = type;
      }
    }

    else if (kind.isUnaryStorageOperator()) {
      if (!type.isEnum() && type.isNumeric(cache)) {
        checkStorage(value);
        node.type = type;
      }
    }

    else if (kind == NodeKind.NOT) {
      if (type.isBool(cache)) {
        node.type = type;
      }
    }

    else if (kind == NodeKind.COMPLEMENT) {
      if (type.isEnumFlags()) {
        node.type = type;
      } else if (type.isInteger(cache)) {
        node.type = cache.intType;
      }
    }

    // Report an error if no match is found
    if (node.type.isError(cache)) {
      semanticErrorNoUnaryOperator(log, node.range, kind, type);
      return;
    }

    // Insert an implicit cast if necessary
    checkConversion(node.type, value, CastKind.IMPLICIT);
  }

  void resolveBinaryOperator(Node node) {
    NodeKind kind = node.kind;
    Node left = node.binaryLeft();
    Node right = node.binaryRight();

    // Special-case assignment logic
    if (kind.isBinaryStorageOperator()) {
      resolveAsExpression(left);
      if (kind == NodeKind.ASSIGN || left.type.isNumeric(cache)) {
        resolveAsExpressionWithConversion(right, left.type, CastKind.IMPLICIT);
        checkStorage(left);
        node.type = left.type;
        return;
      }
    }

    // Special-case equality comparisons to provide type context
    if (kind == NodeKind.EQUAL || kind == NodeKind.NOT_EQUAL) {
      bool leftNeedsContext = needsTypeContext(left);
      bool rightNeedsContext = needsTypeContext(right);
      if (leftNeedsContext && !rightNeedsContext) {
        resolveAsExpression(right);
        resolveAsExpressionWithTypeContext(left, right.type);
      } else if (!leftNeedsContext && rightNeedsContext) {
        resolveAsExpression(left);
        resolveAsExpressionWithTypeContext(right, left.type);
      }
    }

    // This won't resolve twice if the nodes were already resolved above
    resolveAsExpression(left);
    resolveAsExpression(right);

    // Avoid reporting further errors
    Type leftType = left.type;
    Type rightType = right.type;
    Type commonType = null;
    if (leftType.isError(cache) || rightType.isError(cache)) {
      return;
    }

    if (kind == NodeKind.EQUAL || kind == NodeKind.NOT_EQUAL) {
      commonType = cache.commonImplicitType(leftType, rightType);
      if (commonType != null) {
        node.type = cache.boolType;
      }
    }

    else if (kind == NodeKind.ADD || kind == NodeKind.SUBTRACT || kind == NodeKind.MULTIPLY || kind == NodeKind.DIVIDE) {
      if (leftType.isNumeric(cache) && rightType.isNumeric(cache)) {
        node.type = commonType = cache.commonImplicitType(leftType, rightType);
      }
    }

    else if (kind == NodeKind.REMAINDER || kind == NodeKind.SHIFT_LEFT || kind == NodeKind.SHIFT_RIGHT) {
      if (leftType.isInteger(cache) && rightType.isInteger(cache)) {
        node.type = commonType = cache.intType;
      }
    }

    else if (kind == NodeKind.BITWISE_AND || kind == NodeKind.BITWISE_OR || kind == NodeKind.BITWISE_XOR) {
      if (leftType == rightType && leftType.isEnumFlags()) {
        node.type = commonType = leftType;
      } else if (leftType.isInteger(cache) && rightType.isInteger(cache)) {
        node.type = commonType = cache.intType;
      }
    }

    else if (kind == NodeKind.LOGICAL_AND || kind == NodeKind.LOGICAL_OR) {
      if (leftType.isBool(cache) && rightType.isBool(cache)) {
        node.type = commonType = cache.boolType;
      }
    }

    else if (kind == NodeKind.LESS_THAN || kind == NodeKind.GREATER_THAN ||
        kind == NodeKind.LESS_THAN_OR_EQUAL || kind == NodeKind.GREATER_THAN_OR_EQUAL) {
      if (leftType.isNumeric(cache) && rightType.isNumeric(cache) ||
          leftType.isString(cache) && rightType.isString(cache)) {
        commonType = cache.commonImplicitType(leftType, rightType);
        node.type = cache.boolType;
        node.type = cache.boolType;
      }
    }

    // Report an error if no match is found
    if (node.type.isError(cache)) {
      semanticErrorNoBinaryOperator(log, node.range, kind, leftType, rightType);
      return;
    }

    // Insert implicit casts if necessary
    if (commonType != null) {
      checkConversion(commonType, left, CastKind.IMPLICIT);
      checkConversion(commonType, right, CastKind.IMPLICIT);
    }
  }

  void resolveTertiaryOperator(Node node) {
    Node left = node.tertiaryLeft();
    Node middle = node.tertiaryMiddle();
    Node right = node.tertiaryRight();
    resolveAsExpression(left);
    resolveAsExpression(middle);
    resolveAsExpression(right);
    unsupportedNodeKind(node);
  }
}

StringMap<SymbolFlag> createNameToSymbolFlag() {
  StringMap<SymbolFlag> result = new StringMap<SymbolFlag>();
  result.set("export", SymbolFlag.EXPORT);
  result.set("final", SymbolFlag.FINAL);
  result.set("import", SymbolFlag.IMPORT);
  result.set("inline", SymbolFlag.INLINE);
  result.set("override", SymbolFlag.OVERRIDE);
  result.set("private", SymbolFlag.PRIVATE);
  result.set("protected", SymbolFlag.PROTECTED);
  result.set("public", SymbolFlag.PUBLIC);
  result.set("static", SymbolFlag.STATIC);
  result.set("virtual", SymbolFlag.VIRTUAL);
  return result;
}

StringMap<SymbolFlag> nameToSymbolFlag = createNameToSymbolFlag();

IntMap<string> createSymbolFlagToName() {
  IntMap<string> result = new IntMap<string>();
  result.set(SymbolFlag.EXPORT, "export");
  result.set(SymbolFlag.FINAL, "final");
  result.set(SymbolFlag.IMPORT, "import");
  result.set(SymbolFlag.INLINE, "inline");
  result.set(SymbolFlag.OVERRIDE, "override");
  result.set(SymbolFlag.PRIVATE, "private");
  result.set(SymbolFlag.PROTECTED, "protected");
  result.set(SymbolFlag.PUBLIC, "public");
  result.set(SymbolFlag.STATIC, "static");
  result.set(SymbolFlag.VIRTUAL, "virtual");
  return result;
}

IntMap<string> symbolFlagToName = createSymbolFlagToName();
