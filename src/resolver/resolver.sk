class Resolver {
  TypeCache cache = new TypeCache();
  List<Node> parsedDeclarations = {};
  List<Node> parsedBlocks = {};
  Log log;

  static void run(Log log, Node program) {
    assert program.kind == NodeKind.PROGRAM;
    Resolver resolver = new Resolver(log);
    resolver.setupScopesAndMergeSymbols(program, new Scope(null));
    resolver.accumulateSymbolFlags();
    resolver.setSymbolKindsAndMergeSiblings();
    resolver.processUsingStatements();
  }

  void setupScopesAndMergeSymbols(Node node, Scope scope) {
    // The root program introduces the global scope
    if (node.kind == NodeKind.PROGRAM) {
      node.scope = scope;
    }

    // Remember each scope on the node that introduced that scope
    else if (node.kind == NodeKind.BLOCK) {
      node.scope = scope = new Scope(scope);
      parsedBlocks.push(node);

      // Declarations at the file level go in the global scope
      if (node.parent.kind == NodeKind.FILE) {
        scope.type = cache.globalType;
      }

      // Declarations in a block declaration go in that block's type
      else {
        Symbol parentSymbol = node.parent.symbol;
        if (parentSymbol != null && parentSymbol.type != null) {
          scope.type = parentSymbol.type;
        }
      }
    }

    // Declare this node if needed
    if (node.kind.isNamedDeclaration() && node.kind != NodeKind.USING_ALIAS) {
      Node declarationName = node.declarationName();
      if (declarationName != null) {
        string name = declarationName.asString();
        Symbol symbol = scope.findLocal(name);

        // Append this symbol the linked list of sibling nodes
        if (symbol != null) {
          Node last = symbol.node;
          while (last.sibling != null) {
            last = last.sibling;
          }
          last.sibling = node;
        }

        // Make a new symbol
        else {
          symbol = new Symbol(name, SymbolKind.OTHER);
          symbol.node = node;
          scope.insert(symbol);
        }

        // Link the node with its symbol
        parsedDeclarations.push(node);
        node.symbol = symbol;

        // Create a type for block declarations so that declarations inside the
        // block can be linked as siblings with declarations inside other adjacent
        // block declarations:
        //
        //   // Both "Bar" declarations are siblings linked through the type "Foo"
        //   namespace Foo { in Bar {} }
        //   namespace Foo { class Bar {} }
        //
        if (symbol.type == null && node.kind.isNamedBlockDeclaration()) {
          symbol.type = new Type(symbol);
        }
      }
    }

    // Also introduce a scope on object declarations for the type parameters
    // and on function declarations and lambda expressions for the arguments
    if (node.kind.isObjectDeclaration() || node.kind.isFunctionDeclaration() || node.kind == NodeKind.LAMBDA) {
      node.scope = scope = new Scope(scope);
    }

    // Automatically traverse the children of all nodes, even though this pass
    // only initializing scopes. There will be scopes with statements inside
    // some expressions due to lambda expressions.
    if (node.hasChildren()) {
      int i;
      for (i = 0; i < node.children.length; i++) {
        Node child = node.children.get(i);
        if (child != null) setupScopesAndMergeSymbols(child, scope);
      }
    }
  }

  SymbolFlag symbolFlagsForNode(Node node) {
    SymbolFlag flags = 0;
    Node parent = node.parent;

    if (parent.kind == NodeKind.VARIABLE_CLUSTER) {
      parent = parent.parent;
    }

    while (parent != null && parent.kind == NodeKind.MODIFIER) {
      Node modifierName = parent.modifierName();
      string name = modifierName.asString();
      SymbolFlag flag = nameToSymbolFlag.get(name);
      if ((flags & flag) != 0) semanticWarningDuplicateModifier(log, modifierName.range, name);
      flags = flags | flag;
      parent = parent.parent;
    }

    return flags;
  }

  void accumulateSymbolFlags() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);

      // Skip all node in a sibling chain other than the first node
      if (node.symbol.node != node) {
        continue;
      }

      Node declarationName = node.declarationName();
      SymbolFlag flags = symbolFlagsForNode(node);
      Node sibling;

      // Make sure all siblings have the same modifiers
      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        SymbolFlag siblingFlags = symbolFlagsForNode(sibling);
        if (flags != siblingFlags) semanticErrorDifferentModifiers(log, sibling.declarationName().range, declarationName.asString(), declarationName.range);
        flags = flags | siblingFlags;
      }

      node.symbol.flags = flags;
    }
  }

  static bool checkParentsForFunction(Node node) {
    for (node = node.parent; node != null; node = node.parent) {
      if (node.kind.isFunctionDeclaration()) {
        return true;
      }
    }
    return false;
  }

  void setSymbolKindsAndMergeSiblings() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);

      // Skip all node in a sibling chain other than the first node
      if (node.symbol.node != node) {
        continue;
      }

      // The declaration name isn't null here because node.symbol != null
      Node declarationName = node.declarationName();
      NodeKind kind = node.kind;
      Node sibling;

      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        // Extensions off of block declarations are fine
        if (sibling.kind == NodeKind.EXTENSION && kind.isNamedBlockDeclaration()) {
          continue;
        }

        // Merge block declarations with extension blocks
        if (sibling.kind != NodeKind.EXTENSION && sibling.kind.isNamedBlockDeclaration()) {
          if (kind == NodeKind.EXTENSION || kind == NodeKind.NAMESPACE && sibling.kind == NodeKind.NAMESPACE) {
            kind = sibling.kind;
            continue;
          }
        }

        // Disallow all other merges
        Node siblingName = sibling.declarationName();
        semanticErrorDuplicateSymbol(log, siblingName.range, siblingName.asString(), declarationName.range);
      }

      switch (kind) {
        case NodeKind.NAMESPACE { node.symbol.kind = SymbolKind.NAMESPACE; }
        case NodeKind.ENUM { node.symbol.kind = SymbolKind.ENUM; }
        case NodeKind.ENUM_FLAGS { node.symbol.kind = SymbolKind.ENUM_FLAGS; }
        case NodeKind.CLASS { node.symbol.kind = SymbolKind.CLASS; }
        case NodeKind.STRUCT { node.symbol.kind = SymbolKind.STRUCT; }
        case NodeKind.INTERFACE { node.symbol.kind = SymbolKind.INTERFACE; }
        case NodeKind.FUNCTION { node.symbol.kind = SymbolKind.GLOBAL_FUNCTION; }
        case NodeKind.CONSTRUCTOR { node.symbol.kind = SymbolKind.CONSTRUCTOR_FUNCTION; }
        case NodeKind.VARIABLE { node.symbol.kind = SymbolKind.GLOBAL_VARIABLE; }
        case NodeKind.PARAMETER { node.symbol.kind = SymbolKind.PARAMETER; }
        case NodeKind.EXTENSION { semanticErrorExtensionMissingTarget(log, declarationName.range, declarationName.asString()); }
        default { assert false; }
      }
    }

    // Distinguish between global and instance functions and variables now that
    // all symbols have a kind associated with them
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;
      Symbol enclosingSymbol = symbol.enclosingSymbol;

      // Change non-static global functions/variables to instance
      if (enclosingSymbol != null && enclosingSymbol.kind.isObject() && !symbol.isStatic()) {
        if (symbol.kind == SymbolKind.GLOBAL_FUNCTION) symbol.kind = SymbolKind.INSTANCE_FUNCTION;
        else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE) symbol.kind = SymbolKind.INSTANCE_VARIABLE;
      }

      // Change global variables to local
      else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE && checkParentsForFunction(node)) {
        symbol.kind = SymbolKind.LOCAL_VARIABLE;
      }
    }
  }

  void processUsingStatements() {
    int i;
    for (i = 0; i < parsedBlocks.length; i++) {
      Node block = parsedBlocks.get(i);
      int j;

      // Empty blocks will have a children array of null
      if (!block.hasChildren()) {
        continue;
      }

      // Add using aliases. These aren't added in setupScopesAndMergeSymbols()
      // because using aliases are limited to the scope in which they appear
      // and cannot be accessed by or merged symbols in other scopes:
      //
      //   namespace Foo { using Bar = bool; }
      //   namespace Foo { Bar bar; } // This is an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_ALIAS) {
          continue;
        }
        Node declarationName = statement.declarationName();
        string name = declarationName.asString();

        // Detect duplicate symbol declarations
        Symbol symbol = block.scope.findLocal(name);
        if (symbol != null) {
          Node otherName = symbol.node.declarationName();
          if (otherName != null) semanticErrorDuplicateSymbol(log, declarationName.range, name, otherName.range);
          continue;
        }

        // Insert a new unresolved symbol as a local symbol only on this scope.
        // It will not be added on the type associated with this scope, if any.
        symbol = new Symbol(name, SymbolKind.OTHER);
        symbol.node = statement;
        statement.symbol = symbol;
        block.scope.insertLocal(symbol);
      }

      // Add symbols from using statements. These must be added after using
      // aliases because using statements only import symbols from their
      // namespace if there isn't already an existing symbol:
      //
      //   namespace Foo { class Bar {} }
      //   using Foo;
      //   class Bar {} // This is not an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_NAMESPACE) {
          continue;
        }

        // Resolve the namespace as an absolute name
        Symbol symbol = resolveUsingNamespaceValue(statement.usingNamespaceValue());

        // TODO: Resolve using namespace nodes relative to the current (or global?) namespace without considering local symbols
        // - must make sure the order of using namespace nodes doesn't matter
        // TODO: ensure the symbol is a namespace
        // TODO: Insert each imported symbol
        // TODO: Don't import nested namespaces
        // TODO: Importing multiple different symbols with the same name should be replaced with an ambiguous marker that disables the name
      }
    }
  }

  Symbol resolveUsingNamespaceValue(Node node) {
    if (node.kind == NodeKind.NAME) {
      string name = node.asString();
      Symbol symbol = cache.globalType.findMember(name);
      if (symbol == null) semanticErrorUndeclaredGlobalSymbol(log, node.range, name);
      // TODO: Check that symbol is a namespace
      return symbol;
    }

    if (node.kind == NodeKind.DOT) {
      Symbol target = resolveUsingNamespaceValue(node.dotTarget());
      Node dotName = node.dotName();
      if (target == null || dotName == null) {
        return null;
      }
      string name = dotName.asString();
      Symbol symbol = target.type == null ? null : target.type.findMember(name);
      if (symbol == null) semanticErrorUndeclaredSymbol(log, dotName.range, name);
      // TODO: Check that symbol is a namespace
      return symbol;
    }

    semanticErrorUnexpectedExpression(log, node.range, node.kind);
    return null;
  }

  void resolve(Node node) {
    switch (node.kind) {
      case NodeKind.PROGRAM { resolveProgram(node); }
      case NodeKind.FILE { resolveFile(node); }
      case NodeKind.BLOCK { resolveBlock(node); }
      case NodeKind.NODE_LIST { resolveNodeList(node); }
      case NodeKind.CASE { resolveCase(node); }
      case NodeKind.USING_NAMESPACE { resolveUsingNamespace(node); }

      case NodeKind.NAMESPACE { resolveNamespace(node); }
      case NodeKind.ENUM { resolveEnum(node); }
      case NodeKind.ENUM_FLAGS { resolveEnumFlags(node); }
      case NodeKind.CLASS { resolveClass(node); }
      case NodeKind.STRUCT { resolveStruct(node); }
      case NodeKind.INTERFACE { resolveInterface(node); }

      case NodeKind.EXTENSION { resolveExtension(node); }
      case NodeKind.CONSTRUCTOR { resolveConstructor(node); }
      case NodeKind.FUNCTION { resolveFunction(node); }
      case NodeKind.VARIABLE { resolveVariable(node); }
      case NodeKind.VARIABLE_CLUSTER { resolveVariableCluster(node); }
      case NodeKind.PARAMETER { resolveParameter(node); }
      case NodeKind.USING_ALIAS { resolveUsingAlias(node); }

      case NodeKind.IF { resolveIf(node); }
      case NodeKind.FOR { resolveFor(node); }
      case NodeKind.FOREACH { resolveForeach(node); }
      case NodeKind.WHILE { resolveWhile(node); }
      case NodeKind.DO_WHILE { resolveDoWhile(node); }
      case NodeKind.RETURN { resolveReturn(node); }
      case NodeKind.BREAK { resolveBreak(node); }
      case NodeKind.CONTINUE { resolveContinue(node); }
      case NodeKind.ASSERT { resolveAssert(node); }
      case NodeKind.EXPRESSION { resolveExpression(node); }
      case NodeKind.SWITCH { resolveSwitch(node); }
      case NodeKind.MODIFIER { resolveModifier(node); }

      case NodeKind.NAME { resolveName(node); }
      case NodeKind.TYPE { resolveType(node); }
      case NodeKind.NULL { node.type = cache.nullType; }
      case NodeKind.THIS { resolveThis(node); }
      case NodeKind.TRUE { node.type = cache.boolType; }
      case NodeKind.FALSE { node.type = cache.boolType; }
      case NodeKind.HOOK { resolveHook(node); }
      case NodeKind.INT { node.type = cache.intType; }
      case NodeKind.FLOAT { node.type = cache.floatType; }
      case NodeKind.DOUBLE { node.type = cache.doubleType; }
      case NodeKind.STRING { node.type = cache.stringType; }
      case NodeKind.INITIALIZER { resolveInitializer(node); }
      case NodeKind.DOT { resolveDot(node); }
      case NodeKind.DOT_CALL { resolveDotCall(node); }
      case NodeKind.CALL { resolveCall(node); }
      case NodeKind.SUPER_CALL { resolveSuperCall(node); }
      case NodeKind.NEW { resolveNew(node); }
      case NodeKind.ERROR { resolveError(node); }
      case NodeKind.SEQUENCE { resolveSequence(node); }
      case NodeKind.PARAMETERIZE { resolveParameterize(node); }
      case NodeKind.CAST { resolveCast(node); }
      case NodeKind.IMPLICIT_CAST { resolveImplicitCast(node); }
      case NodeKind.DEFAULT { resolveDefault(node); }

      case
        NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
        NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
        NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {
      }

      case
        NodeKind.ADD, NodeKind.BITWISE_AND, NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR,
        NodeKind.DIVIDE, NodeKind.EQUAL, NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL,
        NodeKind.IN, NodeKind.INDEX, NodeKind.LESS_THAN, NodeKind.LESS_THAN_OR_EQUAL,
        NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY, NodeKind.NOT_EQUAL,
        NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT, NodeKind.SUBTRACT {
      }

      case
        NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND, NodeKind.ASSIGN_BITWISE_OR,
        NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE, NodeKind.ASSIGN_MULTIPLY,
        NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT, NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT {
      }

      case NodeKind.ASSIGN_INDEX {}

      default {
        assert false;
      }
    }
  }

  void resolveProgram(Node node) {
  }

  void resolveFile(Node node) {
  }

  void resolveBlock(Node node) {
  }

  void resolveNodeList(Node node) {
  }

  void resolveCase(Node node) {
  }

  void resolveUsingNamespace(Node node) {
  }

  void resolveNamespace(Node node) {
  }

  void resolveEnum(Node node) {
  }

  void resolveEnumFlags(Node node) {
  }

  void resolveClass(Node node) {
  }

  void resolveStruct(Node node) {
  }

  void resolveInterface(Node node) {
  }

  void resolveExtension(Node node) {
  }

  void resolveConstructor(Node node) {
  }

  void resolveFunction(Node node) {
  }

  void resolveVariable(Node node) {
  }

  void resolveVariableCluster(Node node) {
  }

  void resolveParameter(Node node) {
  }

  void resolveUsingAlias(Node node) {
  }

  void resolveIf(Node node) {
  }

  void resolveFor(Node node) {
  }

  void resolveForeach(Node node) {
  }

  void resolveWhile(Node node) {
  }

  void resolveDoWhile(Node node) {
  }

  void resolveReturn(Node node) {
  }

  void resolveBreak(Node node) {
  }

  void resolveContinue(Node node) {
  }

  void resolveAssert(Node node) {
  }

  void resolveExpression(Node node) {
  }

  void resolveSwitch(Node node) {
  }

  void resolveModifier(Node node) {
  }

  void resolveName(Node node) {
  }

  void resolveType(Node node) {
  }

  void resolveThis(Node node) {
  }

  void resolveHook(Node node) {
  }

  void resolveInitializer(Node node) {
  }

  void resolveDot(Node node) {
  }

  void resolveDotCall(Node node) {
  }

  void resolveCall(Node node) {
  }

  void resolveSuperCall(Node node) {
  }

  void resolveNew(Node node) {
  }

  void resolveError(Node node) {
  }

  void resolveSequence(Node node) {
  }

  void resolveParameterize(Node node) {
  }

  void resolveCast(Node node) {
  }

  void resolveImplicitCast(Node node) {
  }

  void resolveDefault(Node node) {
  }
}

StringMap<SymbolFlag> createNameToSymbolFlag() {
  StringMap<SymbolFlag> result = new StringMap<SymbolFlag>();
  result.set("export", SymbolFlag.EXPORT);
  result.set("final", SymbolFlag.FINAL);
  result.set("import", SymbolFlag.IMPORT);
  result.set("inline", SymbolFlag.INLINE);
  result.set("override", SymbolFlag.OVERRIDE);
  result.set("private", SymbolFlag.PRIVATE);
  result.set("protected", SymbolFlag.PROTECTED);
  result.set("public", SymbolFlag.PUBLIC);
  result.set("static", SymbolFlag.STATIC);
  result.set("virtual", SymbolFlag.VIRTUAL);
  return result;
}

StringMap<SymbolFlag> nameToSymbolFlag = createNameToSymbolFlag();
