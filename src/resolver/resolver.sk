enum CastKind {
  IMPLICIT,
  EXPLICIT,
}

enum AllowDeclaration {
  TOP_LEVEL,
  TOP_OR_OBJECT_LEVEL,
}

class ResolveContext {
  Scope scope = null;

  // Keep track of the nearest enclosing node for certain node types
  Node loop = null;
  Node object = null;
  Node function = null;
  Node lambda = null;

  ResolveContext clone() {
    ResolveContext context = new ResolveContext();
    context.scope = scope;
    context.loop = loop;
    context.object = object;
    context.function = function;
    context.lambda = lambda;
    return context;
  }

  static ResolveContext fromNode(Node node) {
    ResolveContext context = new ResolveContext();
    Node parent;
    for (parent = node; node != null; node = node.parent) {
      if (context.scope == null) context.scope = node.scope;
      if (context.loop == null && node.kind.isLoop()) context.loop = node;
      if (context.object == null && node.kind.isObject()) context.object = node;
      if (context.function == null && node.kind.isFunction()) context.function = node;
      if (context.lambda == null && node.kind == NodeKind.LAMBDA) context.lambda = node;
    }
    return context;
  }
}

class Resolver {
  TypeCache cache = new TypeCache();
  ResolveContext context = new ResolveContext();
  List<Node> parsedDeclarations = {};
  List<Node> parsedBlocks = {};
  Type typeContext = null;
  Log log;

  static void run(Log log, Node program) {
    assert program.kind == NodeKind.PROGRAM;
    Resolver resolver = new Resolver(log);
    Scope globalScope = new Scope(null);
    globalScope.insertGlobals(resolver.cache);
    resolver.setupScopesAndUseNamespaces(program, globalScope);
    resolver.accumulateSymbolFlags();
    resolver.setSymbolKindsAndMergeSiblings();
    resolver.processUsingStatements();
    resolver.resolve(program, null);
  }

  void setupScopesAndUseNamespaces(Node node, Scope scope) {
    // The root program introduces the global scope
    if (node.kind == NodeKind.PROGRAM) {
      node.scope = scope;
    }

    // Remember each scope on the node that introduced that scope
    else if (node.kind == NodeKind.BLOCK) {
      // Object declaration blocks just use the scope from their parent node so
      // that symbols inside the block will be marked duplicates of parameters
      //
      //   class Foo<T> {
      //     int T;
      //   }
      //
      if (!node.parent.kind.isNamedBlockDeclaration()) {
        scope = new Scope(scope);
      }

      node.scope = scope;
      parsedBlocks.push(node);

      // Declarations at the file level go in the global scope
      if (node.parent.kind == NodeKind.FILE) {
        scope.type = cache.globalType;
      }

      // Declarations in a block declaration go in that block's type
      else {
        Symbol parentSymbol = node.parent.symbol;
        if (parentSymbol != null && parentSymbol.type != null) {
          scope.type = parentSymbol.type;
        }
      }
    }

    // Declare this node if needed
    if (node.kind.isNamedDeclaration() && node.kind != NodeKind.USING_ALIAS) {
      Node declarationName = node.declarationName();
      if (declarationName != null) {
        string name = declarationName.asString();
        Symbol symbol = scope.findLocal(name);

        // Append this symbol the linked list of sibling nodes
        if (symbol != null) {
          Node last = symbol.node;
          while (last.sibling != null) {
            last = last.sibling;
          }
          last.sibling = node;
        }

        // Make a new symbol
        else {
          symbol = new Symbol(name, SymbolKind.OTHER);
          symbol.node = node;
          scope.insert(symbol);
        }

        // Link the node with its symbol
        parsedDeclarations.push(node);
        declarationName.symbol = symbol;
        node.symbol = symbol;

        // Create a type for block declarations so that declarations inside the
        // block can be linked as siblings with declarations inside other adjacent
        // block declarations:
        //
        //   // Both "Bar" declarations are siblings linked through the type "Foo"
        //   namespace Foo { in Bar {} }
        //   namespace Foo { class Bar {} }
        //
        if (symbol.type == null && node.kind.isNamedBlockDeclaration()) {
          symbol.type = new Type(symbol);
        }
      }
    }

    // Also introduce a scope on object declarations for the type parameters
    // and on function declarations and lambda expressions for the arguments
    if (node.kind.isNamedBlockDeclaration() || node.kind.isFunction() || node.kind == NodeKind.LAMBDA) {
      node.scope = scope = new Scope(scope);
    }

    // Automatically traverse the children of all nodes, even though this pass
    // only initializing scopes. There will be scopes with statements inside
    // some expressions due to lambda expressions.
    if (node.hasChildren()) {
      int i;
      for (i = 0; i < node.children.length; i++) {
        Node child = node.children.get(i);
        if (child != null) setupScopesAndUseNamespaces(child, scope);
      }
    }
  }

  SymbolFlag symbolFlagsForNode(Node node) {
    SymbolFlag flags = 0;
    Node parent = node.parent;

    // Make sure modifiers are detected for variables inside a variable cluster
    if (parent.kind == NodeKind.VARIABLE_CLUSTER) {
      parent = parent.parent;
    }

    // Keep accumulating modifiers that are immediately nested inside each other
    while (parent != null && parent.kind == NodeKind.MODIFIER) {
      Node modifierName = parent.modifierName();
      string name = modifierName.asString();
      SymbolFlag flag = nameToSymbolFlag.get(name);
      if ((flags & flag) != 0) semanticWarningDuplicateModifier(log, modifierName.range, name);
      flags = flags | flag;
      parent = parent.parent;
    }

    // Mark nodes directly inside extension blocks for easy checking later
    if (parent != null && parent.kind == NodeKind.BLOCK && parent.parent.kind == NodeKind.EXTENSION) {
      flags = flags | SymbolFlag.FROM_EXTENSION;
    }

    return flags;
  }

  void accumulateSymbolFlags() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);

      // Skip all nodes in a sibling chain other than the first node
      if (node.symbol.node != node) {
        continue;
      }

      Node declarationName = node.declarationName();
      SymbolFlag flags = symbolFlagsForNode(node);
      Node sibling;

      // Make sure all siblings have the same modifiers
      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        SymbolFlag siblingFlags = symbolFlagsForNode(sibling);

        // Don't count implicitly added modifiers
        if ((flags & ~SymbolFlag.FROM_EXTENSION) != (siblingFlags & ~SymbolFlag.FROM_EXTENSION)) {
          semanticErrorDifferentModifiers(log, sibling.declarationName().range, declarationName.asString(), declarationName.range);
        }

        flags = flags | siblingFlags;
      }

      node.symbol.flags = flags;
    }
  }

  static bool checkParentsForFunction(Node node) {
    for (node = node.parent; node != null; node = node.parent) {
      if (node.kind.isFunction() || node.kind == NodeKind.LAMBDA) {
        return true;
      }
    }
    return false;
  }

  void setSymbolKindsAndMergeSiblings() {
    int i;
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;

      // Skip all node in a sibling chain other than the first node
      if (symbol.node != node) {
        continue;
      }

      // The declaration name isn't null here because symbol != null
      Node declarationName = node.declarationName();
      NodeKind kind = node.kind;
      Node sibling;

      for (sibling = node.sibling; sibling != null; sibling = sibling.sibling) {
        // Extensions off of block declarations are fine
        if (sibling.kind == NodeKind.EXTENSION && kind.isNamedBlockDeclaration()) {
          continue;
        }

        // Merge block declarations with extension blocks
        if (sibling.kind != NodeKind.EXTENSION && sibling.kind.isNamedBlockDeclaration()) {
          if (kind == NodeKind.EXTENSION || kind == NodeKind.NAMESPACE && sibling.kind == NodeKind.NAMESPACE) {
            kind = sibling.kind;
            continue;
          }
        }

        // Disallow all other merges
        Node siblingName = sibling.declarationName();
        semanticErrorDuplicateSymbol(log, siblingName.range, siblingName.asString(), declarationName.range);
      }

      // Set the symbol kind
      switch (kind) {
        case NodeKind.NAMESPACE { symbol.kind = SymbolKind.NAMESPACE; }
        case NodeKind.ENUM { symbol.kind = SymbolKind.ENUM; }
        case NodeKind.ENUM_FLAGS { symbol.kind = SymbolKind.ENUM_FLAGS; }
        case NodeKind.CLASS { symbol.kind = SymbolKind.CLASS; }
        case NodeKind.STRUCT { symbol.kind = SymbolKind.STRUCT; }
        case NodeKind.INTERFACE { symbol.kind = SymbolKind.INTERFACE; }
        case NodeKind.FUNCTION { symbol.kind = SymbolKind.GLOBAL_FUNCTION; }
        case NodeKind.CONSTRUCTOR { symbol.kind = SymbolKind.CONSTRUCTOR_FUNCTION; }
        case NodeKind.VARIABLE { symbol.kind = SymbolKind.GLOBAL_VARIABLE; }
        case NodeKind.PARAMETER { symbol.kind = SymbolKind.PARAMETER; }
        case NodeKind.EXTENSION { semanticErrorExtensionMissingTarget(log, declarationName.range, declarationName.asString()); }
        default { assert false; }
      }
    }

    // Distinguish between global and instance functions and variables now that
    // all symbols have a kind associated with them
    for (i = 0; i < parsedDeclarations.length; i++) {
      Node node = parsedDeclarations.get(i);
      Symbol symbol = node.symbol;
      Symbol enclosingSymbol = symbol.enclosingSymbol;

      // Change non-static global functions/variables to instance
      if (enclosingSymbol != null && enclosingSymbol.kind.isObject() && !symbol.isStatic()) {
        if (symbol.kind == SymbolKind.GLOBAL_FUNCTION) symbol.kind = SymbolKind.INSTANCE_FUNCTION;
        else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE) symbol.kind = SymbolKind.INSTANCE_VARIABLE;
      }

      // Change global variables to local
      else if (symbol.kind == SymbolKind.GLOBAL_VARIABLE && checkParentsForFunction(node)) {
        symbol.kind = SymbolKind.LOCAL_VARIABLE;
      }
    }
  }

  void processUsingStatements() {
    int i;
    for (i = 0; i < parsedBlocks.length; i++) {
      Node block = parsedBlocks.get(i);
      int j;

      // Empty blocks will have a children array of null
      if (!block.hasChildren()) {
        continue;
      }

      // Add using aliases. These aren't added in setupScopesAndUseNamespaces()
      // because using aliases are limited to the scope in which they appear
      // and cannot be accessed by or merged symbols in other scopes:
      //
      //   namespace Foo { using Bar = bool; }
      //   namespace Foo { Bar bar; } // This is an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_ALIAS) {
          continue;
        }
        Node declarationName = statement.declarationName();
        string name = declarationName.asString();

        // Detect duplicate symbol declarations
        Symbol symbol = block.scope.findLocal(name);
        if (symbol != null) {
          Node otherName = symbol.node.declarationName();
          if (otherName != null) semanticErrorDuplicateSymbol(log, declarationName.range, name, otherName.range);
          continue;
        }

        // Insert a new unresolved symbol as a local symbol only on this scope.
        // It will not be added on the type associated with this scope.
        symbol = new Symbol(name, SymbolKind.USING_ALIAS);
        symbol.node = statement;
        statement.symbol = symbol;
        block.scope.insertLocal(symbol);
      }

      // Add symbols from using statements. These must be added after using
      // aliases because using statements only import symbols from their
      // namespace if there isn't already an existing symbol:
      //
      //   namespace Foo { class Bar {} }
      //   using Foo;
      //   class Bar {} // This is not an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind != NodeKind.USING_NAMESPACE) {
          continue;
        }

        // Resolve the namespace as an absolute name
        Node value = statement.usingNamespaceValue();
        resolveGlobalUsingValue(value);
        if (value.type.isError(cache)) {
          continue;
        }
        Symbol symbol = value.type.symbol;
        if (symbol == null) {
          continue;
        }

        // Unlike a using alias, using statements must be a namespace. While
        // this could in theory support arbitrary types, it's more readable and
        // gives clearer errors to limit this to namespaces.
        if (!symbol.kind.isNamespace()) {
          semanticErrorBadUsingNamespace(log, value.range);
          continue;
        }

        // TODO: Insert each non-namespace symbol in the namespace
        // TODO: Importing multiple different symbols with the same name should
        // be replaced with an ambiguous marker that disables the name with an error
      }
    }
  }

  void resolveGlobalUsingValue(Node node) {
    node.type = cache.errorType;
    Symbol symbol;

    // Handle top-level names
    if (node.kind == NodeKind.NAME) {
      string name = node.asString();
      symbol = cache.globalType.findMember(name);
      if (symbol == null) {
        semanticErrorUndeclaredSymbol(log, node.range, name);
        return;
      }
    }

    // Handle nested names
    else if (node.kind == NodeKind.DOT) {
      Node target = node.dotTarget();
      resolveGlobalUsingValue(target);
      Type targetType = target.type;
      Node dotName = node.dotName();
      if (targetType == null || dotName == null) {
        return;
      }
      string name = dotName.asString();
      symbol = targetType.findMember(name);
      if (symbol == null) {
        semanticErrorUnknownMemberSymbol(log, dotName.range, name, targetType);
        return;
      }
    }

    // Non-name nodes are not allowed
    else {
      semanticErrorUnexpectedNode(log, node.range, node.kind);
      return;
    }

    // Validate the symbol type, must not be an instance
    if (!symbol.kind.isType()) {
      semanticErrorBadUsingValue(log, node.range);
      return;
    }

    // Create a type node to distinguish the type from an instance of that type
    node.become(Node.createType(symbol.type).withRange(node.range));
    assert node.type != null; // All type symbols should have a type by now
  }

  void resolve(Node node, Type expectedType) {
    // Only resolve once
    if (node.type != null) {
      return;
    }
    node.type = cache.errorType;

    // Use the current scope for all child nodes
    Scope oldScope = context.scope;
    if (node.scope != null) context.scope = node.scope;

    // Track the type from the context this node is used in
    Type oldType = typeContext;
    typeContext = expectedType;

    switch (node.kind) {
      case NodeKind.PROGRAM { resolveProgram(node); }
      case NodeKind.FILE { resolveFile(node); }
      case NodeKind.BLOCK { resolveBlock(node); }
      case NodeKind.NODE_LIST { resolveChildren(node); }
      case NodeKind.CASE { resolveCase(node); }
      case NodeKind.USING_NAMESPACE { resolveUsingNamespace(node); }

      case NodeKind.NAMESPACE { resolveNamespace(node); }
      case NodeKind.ENUM, NodeKind.ENUM_FLAGS { resolveEnum(node); }
      case NodeKind.CLASS, NodeKind.STRUCT, NodeKind.INTERFACE { resolveObject(node); }

      case NodeKind.EXTENSION { resolveExtension(node); }
      case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION { resolveFunction(node); }
      case NodeKind.VARIABLE { resolveVariable(node); }
      case NodeKind.VARIABLE_CLUSTER { resolveVariableCluster(node); }
      case NodeKind.PARAMETER { resolveParameter(node); }
      case NodeKind.USING_ALIAS { resolveUsingAlias(node); }

      case NodeKind.IF { resolveIf(node); }
      case NodeKind.FOR { resolveFor(node); }
      case NodeKind.FOR_EACH { resolveForEach(node); }
      case NodeKind.WHILE { resolveWhile(node); }
      case NodeKind.DO_WHILE { resolveWhile(node); }
      case NodeKind.RETURN { resolveReturn(node); }
      case NodeKind.BREAK { resolveBreak(node); }
      case NodeKind.CONTINUE { resolveContinue(node); }
      case NodeKind.ASSERT { resolveAssert(node); }
      case NodeKind.EXPRESSION { resolveExpression(node); }
      case NodeKind.SWITCH { resolveSwitch(node); }
      case NodeKind.MODIFIER { resolveModifier(node); }

      case NodeKind.NAME { resolveName(node); }
      case NodeKind.TYPE { resolveType(node); }
      case NodeKind.NULL { node.type = cache.nullType; }
      case NodeKind.THIS { resolveThis(node); }
      case NodeKind.TRUE { node.type = cache.boolType; }
      case NodeKind.FALSE { node.type = cache.boolType; }
      case NodeKind.HOOK { resolveHook(node); }
      case NodeKind.INT { node.type = cache.intType; }
      case NodeKind.FLOAT { node.type = cache.floatType; }
      case NodeKind.DOUBLE { node.type = cache.doubleType; }
      case NodeKind.STRING { node.type = cache.stringType; }
      case NodeKind.INITIALIZER { resolveInitializer(node); }
      case NodeKind.DOT { resolveDot(node); }
      case NodeKind.DOT_CALL { resolveDotCall(node); }
      case NodeKind.CALL { resolveCall(node); }
      case NodeKind.SUPER_CALL { resolveSuperCall(node); }
      case NodeKind.NEW { resolveNew(node); }
      case NodeKind.ERROR { resolveError(node); }
      case NodeKind.SEQUENCE { resolveSequence(node); }
      case NodeKind.PARAMETERIZE { resolveParameterize(node); }
      case NodeKind.CAST { resolveCast(node); }
      case NodeKind.IMPLICIT_CAST { resolveCast(node); }
      case NodeKind.LAMBDA { resolveLambda(node); }
      case NodeKind.DEFAULT { resolveDefault(node); }
      case NodeKind.VAR { resolveVar(node); }
      case NodeKind.FUNCTION_TYPE { resolveFunctionType(node); }

      case
        NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
        NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
        NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {
        unsupportedNodeKind(node);
      }

      case
        NodeKind.ADD, NodeKind.BITWISE_AND, NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR,
        NodeKind.DIVIDE, NodeKind.EQUAL, NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL,
        NodeKind.IN, NodeKind.INDEX, NodeKind.LESS_THAN, NodeKind.LESS_THAN_OR_EQUAL,
        NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY, NodeKind.NOT_EQUAL,
        NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT, NodeKind.SUBTRACT {
        unsupportedNodeKind(node);
      }

      case
        NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND, NodeKind.ASSIGN_BITWISE_OR,
        NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE, NodeKind.ASSIGN_MULTIPLY,
        NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT, NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT {
        unsupportedNodeKind(node);
      }

      case NodeKind.ASSIGN_INDEX {
        unsupportedNodeKind(node);
      }

      default {
        assert false;
      }
    }

    context.scope = oldScope;
    typeContext = oldType;
    assert node.type != null;
  }

  static Node findFirstNonExtension(Node node) {
    while (node != null && node.kind == NodeKind.EXTENSION) {
      node = node.sibling;
    }
    return node;
  }

  void checkIsType(Node node) {
    if (!node.type.isError(cache) && !node.kind.isType()) {
      semanticErrorUnexpectedExpression(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsInstance(Node node) {
    if (!node.type.isError(cache) && node.kind.isType()) {
      semanticErrorUnexpectedType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkIsValidFunctionReturnType(Node node) {
    if (!node.type.isVoid(cache)) {
      checkIsValidVariableType(node);
    }
  }

  void checkIsValidVariableType(Node node) {
    if (node.type.isVoid(cache) || node.type.isNamespace()) {
      semanticErrorBadType(log, node.range, node.type);
      node.type = cache.errorType;
    }
  }

  void checkConversion(Type to, Node node, CastKind kind) {
    Type from = node.type;
    assert from != null;
    assert to != null;

    // Avoid reporting further errors
    if (from.isError(cache) || to.isError(cache)) {
      return;
    }

    // Converting from "void" to "void" always fails
    if (from.isVoid(cache) && to.isVoid(cache)) {
      semanticErrorUnexpectedExpression(log, node.range, to);
      return;
    }

    // No implicit conversion needed for identical types
    if (from == to) {
      return;
    }

    // Special-case assigning 0 to an enum flags type
    if (to.isEnumFlags() && node.kind == NodeKind.INT && node.asInt() == 0) {
      from = to;
    }

    // The implicit conversion must be valid
    if (kind == CastKind.IMPLICIT && !cache.canImplicitlyConvert(from, to) ||
        kind == CastKind.EXPLICIT && !cache.canExplicitlyConvert(from, to)) {
      semanticErrorIncompatibleTypes(log, node.range, from, to, cache.canExplicitlyConvert(from, to));
      node.type = cache.errorType;
      return;
    }

    // Make the implicit conversion explicit for convenience later on
    if (kind == CastKind.IMPLICIT) {
      if (node.kind.isType()) return;
      Node value = new Node(NodeKind.NULL);
      value.become(node);
      node.become(Node.createImplicitCast(Node.createType(to), value).withType(to).withRange(node.range));
    }
  }

  void unexpectedStatement(Node node) {
    semanticErrorUnexpectedStatement(log, node.range);
  }

  void checkInsideBlock(Node node) {
    assert node.parent != null;

    // This will detect statements inside modifier "blocks", which aren't real
    // blocks and don't have their own scope:
    //
    //   inline { using bar = foo; }
    //
    if (node.parent.kind != NodeKind.BLOCK) {
      unexpectedStatement(node);
    }
  }

  void checkDeclarationLocation(Node node, AllowDeclaration allowDeclaration) {
    assert node.parent != null;

    // Top-level declarations cannot live inside object declarations, function
    // declarations, or conditional statements
    Node parent;
    for (parent = node.parent; parent != null; parent = parent.parent) {
      NodeKind kind = parent.kind;
      if (kind != NodeKind.PROGRAM && kind != NodeKind.FILE &&
          kind != NodeKind.MODIFIER && kind != NodeKind.BLOCK &&
          kind != NodeKind.NAMESPACE && kind != NodeKind.EXTENSION &&
          (allowDeclaration != AllowDeclaration.TOP_OR_OBJECT_LEVEL || !kind.isObject())) {
        unexpectedStatement(node);
        break;
      }
    }
  }

  bool checkAccessToThis(Range range) {
    if (context.function != null && context.function.symbol.kind.isInstance()) {
      return true;
    }

    if (context.object != null) semanticErrorStaticThis(log, range);
    else semanticErrorUnexpectedThis(log, range);
    return false;
  }

  void initializeNamespace(Symbol symbol) {
    assert symbol.type.isNamespace();
  }

  void initializeEnum(Symbol symbol) {
    assert symbol.type.isEnum();
  }

  void initializeObject(Symbol symbol) {
    assert symbol.type.isObject();

    Node node = findFirstNonExtension(symbol.node);
    Node parameters = node.objectParameters();
    Node bases = node.objectBases();

    // Resolve type parameters
    if (parameters != null && parameters.hasChildren()) {
      resolveNodes(parameters.children);
    }

    // Resolve base types
    if (bases != null && bases.hasChildren()) {
      List<Node> children = bases.children;
      int i;
      for (i = 0; i < children.length; i++) {
        Node base = children.get(i);
        resolveAsParameterizedType(base);
      }
    }
  }

  void initializeFunction(Symbol symbol) {
    Node node = symbol.node;
    Node result = null;

    // Constructors don't have return types
    if (node.kind == NodeKind.FUNCTION) {
      result = node.functionResult();
      resolveAsParameterizedType(result);
      checkIsValidFunctionReturnType(result);
    }

    // Resolve argument variables
    Node arguments = node.functionArguments();
    resolve(arguments, null);

    // Create the function type. Constructors get a return type of "void" so
    // that return statements inside the constructor cannot have values.
    Type resultType = result != null ? result.type : cache.voidType;
    symbol.type = cache.errorType;
    if (!resultType.isError(cache)) {
      List<Type> argumentTypes = {};
      int i;
      for (i = 0; i < arguments.children.length; i++) {
        Type type = arguments.children.get(i).symbol.type;
        if (type.isError(cache)) return;
        argumentTypes.push(type);
      }
      symbol.type = cache.functionType(resultType, argumentTypes);
    }
  }

  void initializeVariable(Symbol symbol) {
    Node node = symbol.node;
    Node variableType = node.variableType();
    if (variableType == null) {

      // Take the variable type from the enclosing variable cluster
      if (node.parent.kind == NodeKind.VARIABLE_CLUSTER) {
        variableType = node.parent.clusterType().clone();
      }

      // Take the variable type from the enclosing symbol, which should be an
      // enum declaration if it exists. If not, than assume the error has been
      // logged already and just use the error type. This is the case when a
      // lambda expression lacks type context.
      else {
        Symbol enclosingSymbol = node.symbol.enclosingSymbol;
        assert enclosingSymbol != null ? enclosingSymbol.kind.isEnum() : node.parent.kind == NodeKind.LAMBDA;
        variableType = Node.createType(enclosingSymbol != null ? enclosingSymbol.type : cache.errorType);
      }

      assert variableType != null;
      node.replaceChild(1, variableType);
    }

    // Handle implicitly typed variables by taking the type from the assigned value
    if (variableType.kind == NodeKind.VAR) {
      Node value = node.variableValue();
      if (value == null) {
        semanticErrorVarMissingValue(log, node.declarationName().range);
        symbol.type = cache.errorType;
      } else {
        resolveAsExpression(value);
        Type type = value.type;
        if (type.isNull(cache) || type.isVoid(cache)) {
          semanticErrorVarBadType(log, node.declarationName().range, type);
          symbol.type = cache.errorType;
        } else {
          symbol.type = type;
        }
      }
    }

    // Resolve the expression for the variable type
    else {
      resolveAsParameterizedType(variableType);
      checkIsValidVariableType(variableType);
      symbol.type = variableType.type;
    }
  }

  void initializeParameter(Symbol symbol) {
    Type type = symbol.type = new Type(symbol);
    Node bound = symbol.node.parameterBound();

    // Type parameters can optionally have a single interface as an upper bound.
    // This forces all parameterizations to implement that interface and allows
    // use of that interface inside the scope of the parameter:
    //
    //   interface IFoo {
    //     void foo();
    //   }
    //
    //   class Foo<T is IFoo> {
    //     void foo(T value) {
    //       value.foo();
    //     }
    //   }
    //
    if (bound != null) {
      resolveAsParameterizedType(bound);
      Type boundType = bound.type;
      if (boundType.isError(cache)) {
        symbol.type = cache.errorType;
      } else if (!boundType.isInterface()) {
        semanticErrorBadTypeParameterBound(log, bound.range, boundType);
      } else {
        type.copyMembersFrom(boundType);
      }
    }
  }

  void initializeUsingAlias(Symbol symbol) {
    Node value = symbol.node.usingAliasValue();
    resolveAsParameterizedType(value);
    symbol.type = value.type;
  }

  void initializeDeclaration(Node node) {
    // The symbol should already have been set
    Symbol symbol = node.symbol;
    assert symbol != null;

    // Only initialize once
    if (symbol.isUninitialized()) {
      // Flag the symbol's as initializing for the duration of the declaration's
      // initialization. This way we can detect cycles that try to use the symbol
      // in its own type, such as "foo foo;" or "class Foo : Foo {}". Cyclic
      // symbol references will return the error type in this case.
      symbol.flags = symbol.flags | SymbolFlag.INITIALIZING;

      // Resolve using node.symbol.node to start from the first node in the
      // sibling chain to ensure that the entire chain is processed at once
      ResolveContext oldContext = context;
      Type oldTypeContext = typeContext;
      context = ResolveContext.fromNode(node); // TODO: Cache this?
      typeContext = null;
      switch (symbol.kind) {
        case SymbolKind.NAMESPACE { initializeNamespace(symbol); }
        case SymbolKind.ENUM, SymbolKind.ENUM_FLAGS { initializeEnum(symbol); }
        case SymbolKind.CLASS, SymbolKind.STRUCT, SymbolKind.INTERFACE { initializeObject(symbol); }
        case SymbolKind.GLOBAL_FUNCTION, SymbolKind.INSTANCE_FUNCTION, SymbolKind.CONSTRUCTOR_FUNCTION { initializeFunction(symbol); }
        case SymbolKind.LOCAL_VARIABLE, SymbolKind.GLOBAL_VARIABLE, SymbolKind.INSTANCE_VARIABLE { initializeVariable(symbol); }
        case SymbolKind.PARAMETER { initializeParameter(symbol); }
        case SymbolKind.USING_ALIAS { initializeUsingAlias(symbol); }
        case SymbolKind.OTHER {}
        default { assert false; }
      }
      context = oldContext;
      typeContext = oldTypeContext;

      // Update the type now that cycle detection is complete
      assert symbol.type != null;
      assert symbol.isInitializing();
      assert !symbol.isInitialized();
      symbol.flags = (symbol.flags & ~SymbolFlag.INITIALIZING) | SymbolFlag.INITIALIZED;
    }
  }

  void initializeSymbol(Symbol symbol) {
    // Only initialize the symbol once
    if (symbol.isUninitialized()) {
      assert symbol.node != null; // Internal symbols have no node but should already have a type
      initializeDeclaration(symbol.node);
      assert !symbol.isInitializing();
      assert symbol.isInitialized();
      assert symbol.type != null;
    }

    // Detect cyclic symbol references such as "foo foo;"
    else if (symbol.isInitializing()) {
      semanticErrorCyclicDeclaration(log, findFirstNonExtension(symbol.node).declarationName().range, symbol.name);
      symbol.type = cache.errorType;
    }
  }

  void unsupportedNodeKind(Node node) {
    // log.error(node.range, "TODO: Support nodes of kind ".append(node.kind.toString()));
  }

  void resolveAsType(Node node) {
    assert node.kind.isExpression();
    resolve(node, null);
    checkIsType(node);
  }

  void resolveAsParameterizedType(Node node) {
    resolveAsType(node);
  }

  void resolveAsExpression(Node node) {
    assert node.kind.isExpression();
    resolve(node, null);
    checkIsInstance(node);
  }

  void resolveAsExpressionWithTypeContext(Node node, Type type) {
    assert node.kind.isExpression();
    resolve(node, type);
    checkIsInstance(node);
  }

  void resolveAsExpressionWithConversion(Node node, Type type, CastKind kind) {
    assert node.kind.isExpression();
    resolve(node, type);
    checkIsInstance(node);
    if (type != null) checkConversion(type, node, kind);
  }

  void resolveNodes(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      resolve(nodes.get(i), null);
    }
  }

  void resolveNodesAsExpressions(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      resolveAsExpression(nodes.get(i));
    }
  }

  void resolveNodesAsVariableTypes(List<Node> nodes) {
    int i;
    for (i = 0; i < nodes.length; i++) {
      Node node = nodes.get(i);
      resolveAsParameterizedType(node);
      checkIsValidVariableType(node);
    }
  }

  void resolveChildren(Node node) {
    if (node.hasChildren()) {
      resolveNodes(node.children);
    }
  }

  void resolveProgram(Node node) {
    assert node.parent == null;
    resolveChildren(node);
  }

  void resolveFile(Node node) {
    assert node.parent != null;
    assert node.parent.kind == NodeKind.PROGRAM;
    resolve(node.fileBlock(), null);
  }

  void resolveBlock(Node node) {
    resolveChildren(node);
  }

  void resolveCase(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveUsingNamespace(Node node) {
    checkInsideBlock(node);
  }

  void resolveNamespace(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    resolve(node.declarationBlock(), null);
  }

  void resolveEnum(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    resolve(node.declarationBlock(), null);
  }

  void resolveObject(Node node) {
    Node oldObject = context.object;
    context.object = node;
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    initializeSymbol(node.symbol);
    resolve(node.declarationBlock(), null);
    context.object = oldObject;
  }

  void resolveExtension(Node node) {
    checkDeclarationLocation(node, AllowDeclaration.TOP_LEVEL);
    resolve(node.declarationBlock(), null);
  }

  void resolveFunction(Node node) {
    Node oldFunction = context.function;
    context.function = node;
    checkDeclarationLocation(node, AllowDeclaration.TOP_OR_OBJECT_LEVEL);
    initializeSymbol(node.symbol);
    Node block = node.functionBlock();
    if (block != null) resolve(block, null);
    context.function = oldFunction;
  }

  void resolveVariable(Node node) {
    Symbol symbol = node.symbol;
    initializeSymbol(symbol);
    Node value = node.variableValue();

    // Instance variables without initial values aren't allowed in extension
    // blocks because default constructors need to order their arguments
    if (!symbol.isStatic() && symbol.isFromExtension()) {
      Type enclosingType = symbol.enclosingSymbol.type;
      if (!enclosingType.isClass() || value == null) {
        unexpectedStatement(node);
      }
    }

    if (value != null) resolveAsExpressionWithConversion(value, symbol.type, CastKind.IMPLICIT);
  }

  void resolveVariableCluster(Node node) {
    // This must not initialize node.clusterType() here for circular declaration
    // detection to work correctly ("foo foo;" is a circular declaration)
    resolveNodes(node.clusterVariables());
  }

  void resolveParameter(Node node) {
    initializeSymbol(node.symbol);
  }

  void resolveUsingAlias(Node node) {
    checkInsideBlock(node);
    if (node.symbol != null) {
      initializeSymbol(node.symbol);
    }
  }

  void resolveIf(Node node) {
    resolveAsExpressionWithConversion(node.ifTest(), cache.boolType, CastKind.IMPLICIT);
    resolve(node.ifTrue(), null);
    if (node.ifFalse() != null) resolve(node.ifFalse(), null);
  }

  void resolveFor(Node node) {
    Node setup = node.forSetup();
    Node test = node.forTest();
    Node update = node.forUpdate();
    if (setup != null) {
      if (setup.kind == NodeKind.VARIABLE_CLUSTER) resolve(setup, null);
      else resolveAsExpression(setup);
    }
    if (test != null) resolveAsExpressionWithConversion(test, cache.boolType, CastKind.IMPLICIT);
    if (update != null) resolveAsExpression(update);

    Node oldLoop = context.loop;
    context.loop = node;
    resolve(node.forBlock(), null);
    context.loop = oldLoop;
  }

  void resolveForEach(Node node) {
    resolve(node.forEachVariable(), null);
    resolve(node.forEachValue(), null);
    Node oldLoop = context.loop;
    context.loop = node;
    resolve(node.forEachBlock(), null);
    context.loop = oldLoop;
    unsupportedNodeKind(node);
  }

  void resolveWhile(Node node) {
    Node test = node.whileTest();
    if (test != null) resolveAsExpressionWithConversion(test, cache.boolType, CastKind.IMPLICIT);
    Node oldLoop = context.loop;
    context.loop = node;
    resolve(node.whileBlock(), null);
    context.loop = oldLoop;
  }

  void resolveReturn(Node node) {
    Node value = node.returnValue();

    // Return statements must live inside functions
    if (context.function == null && context.lambda == null) {
      unexpectedStatement(node);
      if (value != null) resolveAsExpression(value);
      return;
    }

    // Get the return type
    Type functionType = context.function != null ? context.function.symbol.type : context.lambda.type;
    Type resultType = functionType.isError(cache) ? cache.errorType : functionType.resultType();

    // Check the return value
    if (value != null) {
      resolveAsExpressionWithConversion(value, resultType, CastKind.IMPLICIT);
    }

    // The return value may be missing only when the return type is void
    else if (!resultType.isError(cache) && !resultType.isVoid(cache)) {
      semanticErrorExpectedReturnValue(log, node.range, resultType);
    }
  }

  void resolveBreak(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveContinue(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveAssert(Node node) {
    resolveAsExpressionWithConversion(node.assertValue(), cache.boolType, CastKind.IMPLICIT);
  }

  void resolveExpression(Node node) {
    resolveAsExpression(node.expressionValue());
  }

  void resolveSwitch(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveModifier(Node node) {
    resolveNodes(node.modifierStatements());
  }

  void resolveName(Node node) {
    string name = node.asString();
    Symbol symbol = context.scope.find(name);
    if (symbol == null) {
      semanticErrorUndeclaredSymbol(log, node.range, name);
      return;
    }
    initializeSymbol(symbol);

    // Wrap type symbols in a type node to distinguish them from instances
    if (symbol.kind.isType()) {
      node.become(Node.createType(symbol.type).withRange(node.range));
      return;
    }

    // Instance members inside an object must have access to "this"
    if (symbol.kind.isInstance()) {
      checkAccessToThis(node.range);
    }

    node.symbol = symbol;
    node.type = symbol.type;
  }

  void resolveType(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveThis(Node node) {
    if (checkAccessToThis(node.range)) {
      assert context.object != null;
      Symbol symbol = context.object.symbol;
      initializeSymbol(symbol);
      node.type = symbol.type;
    }
  }

  void resolveHook(Node node) {
    Node trueNode = node.hookTrue();
    Node falseNode = node.hookFalse();
    resolveAsExpressionWithConversion(node.hookTest(), cache.boolType, CastKind.IMPLICIT);

    // Resolve both branches with type context but don't warn about type
    // conversion problems yet (warning later gives better error messages)
    resolveAsExpressionWithTypeContext(trueNode, typeContext);
    resolveAsExpressionWithTypeContext(falseNode, typeContext);

    // Avoid reporting further errors
    Type trueType = trueNode.type;
    Type falseType = falseNode.type;
    if (trueType.isError(cache) || falseType.isError(cache)) {
      return;
    }

    // Ensure both branches can implicitly convert to a common type
    Type commonType = cache.commonImplicitType(trueType, falseType);
    if (commonType == null) {

      // As a fallback, try to disambiguate by how the result will be used
      commonType = typeContext;
      if (commonType == null || !cache.canImplicitlyConvert(trueType, commonType) || !cache.canImplicitlyConvert(falseType, commonType)) {
        semanticErrorNoCommonType(log, Range.span(trueNode.range, falseNode.range), trueType, falseType);
        return;
      }
    }

    // Finally, check that the conversion works. This check must be done
    // even when using the common type because it inserts implicit casts.
    checkConversion(commonType, trueNode, CastKind.IMPLICIT);
    checkConversion(commonType, falseNode, CastKind.IMPLICIT);
    node.type = commonType;
  }

  void resolveInitializer(Node node) {
    List<Node> values = node.initializerValues();

    // The type of the literal comes from how it's used
    if (typeContext == null) {
      semanticErrorMissingTypeContext(log, node.range);
      resolveNodesAsExpressions(values);
      return;
    }

    // Avoid reporting further errors
    if (typeContext.isError(cache)) {
      resolveNodesAsExpressions(values);
      return;
    }

    // TODO
    unsupportedNodeKind(node);
    resolveNodesAsExpressions(values);
  }

  void resolveDot(Node node) {
    // The target may be null, which means to use the type context instead
    Node target = node.dotTarget();
    if (target != null) {
      resolve(target, null);
    }

    // Avoid reporting further errors
    Type type = target != null ? target.type : typeContext;
    if (type == null) {
      semanticErrorMissingTypeContext(log, node.range);
      return;
    }
    if (type.isError(cache)) {
      return;
    }

    // The name allowed to be null for autocomplete
    Node dotName = node.dotName();
    if (dotName == null) {
      return;
    }
    string name = dotName.asString();

    // Search for the member symbol
    Symbol symbol = type.findMember(name);
    if (symbol == null) {
      semanticErrorUnknownMemberSymbol(log, dotName.range, name, type);
      return;
    }
    node.symbol = symbol;
    initializeSymbol(symbol);

    // Check the instance/static status of the symbol
    bool symbolIsType = symbol.kind.isType();
    bool targetIsType = target == null || target.kind.isType();
    if (!type.isNamespace() && !type.isEnum()) {
      bool isStatic = symbolIsType || symbol.isStatic();

      // Static members can only be accessed from a type
      if (isStatic && !targetIsType) {
        semanticErrorMemberUnexpectedStatic(log, dotName.range, name);
      }

      // Instance members can only be accessed from an instance
      else if (!isStatic && targetIsType) {
        semanticErrorMemberUnexpectedInstance(log, dotName.range, name);
      }
    }

    // Update this node using the member symbol
    if (symbolIsType) node.become(Node.createType(symbol.type).withRange(node.range));
    else if (targetIsType) node.become(Node.createName(symbol.name).withRange(node.range).withSymbol(symbol).withType(symbol.type));
    else node.type = symbol.type;
  }

  void resolveDotCall(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveCall(Node node) {
    Node value = node.callValue();
    List<Node> arguments = node.callArguments();
    resolveAsExpression(value);
    Type valueType = value.type;

    // Avoid reporting further errors
    if (valueType.isError(cache)) {
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Can only call an instance of a function type
    if (!valueType.isFunction()) {
      semanticErrorInvalidCall(log, value.range, valueType);
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Set the result type now even if the arguments are incorrect
    Type resultType = valueType.resultType();
    List<Type> argumentTypes = valueType.argumentTypes();
    node.type = resultType;

    // Validate the argument count
    if (argumentTypes.length != arguments.length) {
      semanticErrorArgumentCount(log, Range.after(node.range, value.range), argumentTypes.length, arguments.length);
      resolveNodesAsExpressions(arguments);
      return;
    }

    // Validate the arguments and provide type context
    int i;
    for (i = 0; i < arguments.length; i++) {
      resolveAsExpressionWithConversion(arguments.get(i), argumentTypes.get(i), CastKind.IMPLICIT);
    }
  }

  void resolveSuperCall(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveNew(Node node) {
    unsupportedNodeKind(node);
  }

  void resolveError(Node node) {
    // Error nodes represent parse errors. They exist to allow a valid AST to
    // be produced from an invalid parse after parser recovery, which is most
    // useful when the compiler is being run as part of an IDE.
  }

  void resolveSequence(Node node) {
    assert node.hasChildren();
    int i;
    int n;
    for (i = 0, n = node.children.length; i < n; i++) {
      Node child = node.children.get(i);
      if (i + 1 < n) resolveAsExpression(child);
      else resolveAsExpressionWithConversion(child, typeContext, node.parent.kind == NodeKind.CAST ? CastKind.EXPLICIT : CastKind.IMPLICIT);
    }
  }

  void resolveParameterize(Node node) {
    Node type = node.parameterizeType();
    List<Node> substitutions = node.parameterizeTypes();
    resolveAsParameterizedType(type);
    resolveNodesAsVariableTypes(substitutions);
    unsupportedNodeKind(node);
  }

  void resolveCast(Node node) {
    Node type = node.castType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    resolveAsExpressionWithConversion(node.castValue(), type.type, CastKind.EXPLICIT);
    node.type = type.type;
  }

  void resolveLambda(Node node) {
    Node oldLambda = context.lambda;
    Node oldLoop = context.loop;
    context.lambda = node;
    context.loop = null;

    List<Node> arguments = node.lambdaArguments();
    Node block = node.lambdaBlock();

    // Lambdas require type context instead of attempting type inference
    if (typeContext == null) {
      semanticErrorMissingTypeContext(log, node.range);
    }

    else if (!typeContext.isError(cache)) {
      if (!typeContext.isFunction()) {
        semanticErrorBadLambdaTypeContext(log, node.range, typeContext);
      }

      else if (!typeContext.isError(cache)) {
        // Set the expression type now even if the arguments are incorrect
        Type resultType = typeContext.resultType();
        List<Type> argumentTypes = typeContext.argumentTypes();
        node.type = typeContext;

        // Validate the argument count
        if (argumentTypes.length != arguments.length) {
          semanticErrorArgumentCount(log, node.range, argumentTypes.length, arguments.length);
        }

        // Give each argument variable the corresponding type from the function signature
        else {
          int i;
          for (i = 0; i < arguments.length; i++) {
            assert arguments.get(i).variableType() == null;
            arguments.get(i).children.set(1, Node.createType(argumentTypes.get(i)));
          }
        }
      }
    }

    resolveNodes(arguments);
    resolve(block, null);

    context.lambda = oldLambda;
    context.loop = oldLoop;
  }

  void resolveDefault(Node node) {
    Node type = node.defaultType();
    resolveAsParameterizedType(type);
    checkIsValidVariableType(type);
    node.type = type.type;
  }

  void resolveVar(Node node) {
    semanticErrorUnexpectedNode(log, node.range, node.kind);
  }

  void resolveFunctionType(Node node) {
    Node result = node.functionTypeResult();
    List<Node> arguments = node.functionTypeArguments();
    resolveAsParameterizedType(result);
    resolveNodesAsVariableTypes(arguments);
    if (!result.type.isError(cache)) {
      List<Type> argumentTypes = {};
      int i;
      for (i = 0; i < arguments.length; i++) {
        Type argumentType = arguments.get(i).type;
        if (argumentType.isError(cache)) {
          return;
        }
        argumentTypes.push(argumentType);
      }
      node.become(Node.createType(cache.functionType(result.type, argumentTypes)).withRange(node.range));
    }
  }
}

StringMap<SymbolFlag> createNameToSymbolFlag() {
  StringMap<SymbolFlag> result = new StringMap<SymbolFlag>();
  result.set("export", SymbolFlag.EXPORT);
  result.set("final", SymbolFlag.FINAL);
  result.set("import", SymbolFlag.IMPORT);
  result.set("inline", SymbolFlag.INLINE);
  result.set("override", SymbolFlag.OVERRIDE);
  result.set("private", SymbolFlag.PRIVATE);
  result.set("protected", SymbolFlag.PROTECTED);
  result.set("public", SymbolFlag.PUBLIC);
  result.set("static", SymbolFlag.STATIC);
  result.set("virtual", SymbolFlag.VIRTUAL);
  return result;
}

StringMap<SymbolFlag> nameToSymbolFlag = createNameToSymbolFlag();
