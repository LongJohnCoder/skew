class Resolver {
  TypeCache cache = new TypeCache();
  List<Node> blocks = {};
  Log log;

  static void run(Log log, Node program) {
    assert program.kind == NodeKind.PROGRAM;
    Resolver resolver = new Resolver(log);
    resolver.setupScopesAndMergeSymbols(program, new Scope(null));
    resolver.processBlocks();
  }

  void setupScopesAndMergeSymbols(Node node, Scope scope) {
    // The root program introduces the global scope
    if (node.kind == NodeKind.PROGRAM) {
      node.scope = scope;
    }

    // Remember each scope on the node that introduced that scope
    else if (node.kind == NodeKind.BLOCK) {
      node.scope = scope = new Scope(scope);
      blocks.push(node);

      // Declarations at the file level go in the global scope
      if (node.parent.kind == NodeKind.FILE) {
        scope.type = cache.globalType;
      }

      // Declarations in a block declaration go in that block's type
      else {
        Symbol parentSymbol = node.parent.symbol;
        if (parentSymbol != null && parentSymbol.type != null) {
          scope.type = parentSymbol.type;
        }
      }
    }

    // Also introduce a scope for function declarations for the arguments
    else if (node.kind.isFunctionDeclaration()) {
      node.scope = scope = new Scope(scope);
    }

    // Declare this node if needed
    if (node.kind.isNamedDeclaration() && node.kind != NodeKind.USING_ALIAS) {
      string name = node.declarationName().asString();
      Symbol symbol = scope.findLocal(name);

      // Append the symbol's current node to the linked list of nodes
      if (symbol != null) {
        node.symbol = symbol;
        node.sibling = symbol.node;
      }

      // Make a new symbol
      else {
        symbol = new Symbol(name, SymbolKind.OTHER);
        scope.insert(symbol);
      }

      // Link the node with its symbol
      symbol.node = node;
      node.symbol = symbol;

      // Create a type for block declarations so that declarations inside the
      // block can be linked as siblings with declarations inside other adjacent
      // block declarations:
      //
      //   // Both "Bar" declarations are siblings linked through the type "Foo"
      //   namespace Foo { in Bar {} }
      //   namespace Foo { class Bar {} }
      //
      if (symbol.type == null && node.kind.isNamedBlockDeclaration()) {
        symbol.type = new Type(symbol);
      }
    }

    // Automatically traverse the children of all nodes, even though this pass
    // only initializing scopes. There will be scopes with statements inside
    // some expressions due to lambda expressions.
    if (node.hasChildren()) {
      int i;
      for (i = 0; i < node.children.length; i++) {
        Node child = node.children.get(i);
        if (child != null) setupScopesAndMergeSymbols(child, scope);
      }
    }
  }

  void processBlocks() {
    int i;
    for (i = 0; i < blocks.length; i++) {
      Node block = blocks.get(i);
      int j;

      // Empty blocks will have a children array of null
      if (!block.hasChildren()) {
        continue;
      }

      // Add using aliases. These aren't added in setupScopesAndMergeSymbols()
      // because using aliases are limited to the scope in which they appear
      // and cannot be accessed by or merged symbols in other scopes:
      //
      //   namespace Foo { using Bar = bool; }
      //   namespace Foo { Bar bar; } // This is an error
      //
      for (j = 0; j < block.children.length; j++) {
        Node statement = block.children.get(j);
        if (statement.kind == NodeKind.USING_ALIAS) {
          Node declarationName = statement.declarationName();
          string name = declarationName.asString();

          // Detect duplicate symbol declarations
          Symbol symbol = block.scope.findLocal(name);
          if (symbol != null) {
            semanticErrorDuplicateSymbol(log, declarationName.range, name, symbol.node.declarationName().range);
            continue;
          }

          // Insert a new unresolved symbol as a local symbol only on this scope.
          // It will not be added on the type associated with this scope, if any.
          symbol = new Symbol(name, SymbolKind.OTHER);
          symbol.node = statement;
          statement.symbol = symbol;
          block.scope.insertLocal(symbol);
        }
      }
    }
  }

  void resolve(Node node) {
    switch (node.kind) {
      case NodeKind.PROGRAM { resolveProgram(node); }
      case NodeKind.FILE { resolveFile(node); }
      case NodeKind.BLOCK { resolveBlock(node); }
      case NodeKind.NODE_LIST { resolveNodeList(node); }
      case NodeKind.CASE { resolveCase(node); }
      case NodeKind.USING_NAMESPACE { resolveUsingNamespace(node); }

      case NodeKind.NAMESPACE { resolveNamespace(node); }
      case NodeKind.ENUM { resolveEnum(node); }
      case NodeKind.ENUM_FLAGS { resolveEnumFlags(node); }
      case NodeKind.CLASS { resolveClass(node); }
      case NodeKind.STRUCT { resolveStruct(node); }
      case NodeKind.INTERFACE { resolveInterface(node); }

      case NodeKind.EXTENSION { resolveExtension(node); }
      case NodeKind.CONSTRUCTOR { resolveConstructor(node); }
      case NodeKind.FUNCTION { resolveFunction(node); }
      case NodeKind.VARIABLE { resolveVariable(node); }
      case NodeKind.VARIABLE_CLUSTER { resolveVariableCluster(node); }
      case NodeKind.PARAMETER { resolveParameter(node); }
      case NodeKind.USING_ALIAS { resolveUsingAlias(node); }

      case NodeKind.IF { resolveIf(node); }
      case NodeKind.FOR { resolveFor(node); }
      case NodeKind.FOREACH { resolveForeach(node); }
      case NodeKind.WHILE { resolveWhile(node); }
      case NodeKind.DO_WHILE { resolveDoWhile(node); }
      case NodeKind.RETURN { resolveReturn(node); }
      case NodeKind.BREAK { resolveBreak(node); }
      case NodeKind.CONTINUE { resolveContinue(node); }
      case NodeKind.ASSERT { resolveAssert(node); }
      case NodeKind.EXPRESSION { resolveExpression(node); }
      case NodeKind.SWITCH { resolveSwitch(node); }
      case NodeKind.MODIFIER { resolveModifier(node); }

      case NodeKind.NAME { resolveName(node); }
      case NodeKind.TYPE { resolveType(node); }
      case NodeKind.NULL { node.type = cache.nullType; }
      case NodeKind.THIS { resolveThis(node); }
      case NodeKind.TRUE { node.type = cache.boolType; }
      case NodeKind.FALSE { node.type = cache.boolType; }
      case NodeKind.HOOK { resolveHook(node); }
      case NodeKind.INT { node.type = cache.intType; }
      case NodeKind.FLOAT { node.type = cache.floatType; }
      case NodeKind.DOUBLE { node.type = cache.doubleType; }
      case NodeKind.STRING { node.type = cache.stringType; }
      case NodeKind.INITIALIZER { resolveInitializer(node); }
      case NodeKind.DOT { resolveDot(node); }
      case NodeKind.DOT_CALL { resolveDotCall(node); }
      case NodeKind.CALL { resolveCall(node); }
      case NodeKind.SUPER_CALL { resolveSuperCall(node); }
      case NodeKind.NEW { resolveNew(node); }
      case NodeKind.ERROR { resolveError(node); }
      case NodeKind.SEQUENCE { resolveSequence(node); }
      case NodeKind.PARAMETERIZE { resolveParameterize(node); }
      case NodeKind.CAST { resolveCast(node); }
      case NodeKind.IMPLICIT_CAST { resolveImplicitCast(node); }
      case NodeKind.DEFAULT { resolveDefault(node); }

      case
        NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
        NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
        NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {
      }

      case
        NodeKind.ADD, NodeKind.BITWISE_AND, NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR,
        NodeKind.DIVIDE, NodeKind.EQUAL, NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL,
        NodeKind.IN, NodeKind.INDEX, NodeKind.LESS_THAN, NodeKind.LESS_THAN_OR_EQUAL,
        NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY, NodeKind.NOT_EQUAL,
        NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT, NodeKind.SUBTRACT {
      }

      case
        NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND, NodeKind.ASSIGN_BITWISE_OR,
        NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE, NodeKind.ASSIGN_MULTIPLY,
        NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT, NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT {
      }

      case NodeKind.ASSIGN_INDEX {}

      default {
        assert false;
      }
    }
  }

  void resolveProgram(Node node) {
  }

  void resolveFile(Node node) {
  }

  void resolveBlock(Node node) {
  }

  void resolveNodeList(Node node) {
  }

  void resolveCase(Node node) {
  }

  void resolveUsingNamespace(Node node) {
  }

  void resolveNamespace(Node node) {
  }

  void resolveEnum(Node node) {
  }

  void resolveEnumFlags(Node node) {
  }

  void resolveClass(Node node) {
  }

  void resolveStruct(Node node) {
  }

  void resolveInterface(Node node) {
  }

  void resolveExtension(Node node) {
  }

  void resolveConstructor(Node node) {
  }

  void resolveFunction(Node node) {
  }

  void resolveVariable(Node node) {
  }

  void resolveVariableCluster(Node node) {
  }

  void resolveParameter(Node node) {
  }

  void resolveUsingAlias(Node node) {
  }

  void resolveIf(Node node) {
  }

  void resolveFor(Node node) {
  }

  void resolveForeach(Node node) {
  }

  void resolveWhile(Node node) {
  }

  void resolveDoWhile(Node node) {
  }

  void resolveReturn(Node node) {
  }

  void resolveBreak(Node node) {
  }

  void resolveContinue(Node node) {
  }

  void resolveAssert(Node node) {
  }

  void resolveExpression(Node node) {
  }

  void resolveSwitch(Node node) {
  }

  void resolveModifier(Node node) {
  }

  void resolveName(Node node) {
  }

  void resolveType(Node node) {
  }

  void resolveThis(Node node) {
  }

  void resolveHook(Node node) {
  }

  void resolveInitializer(Node node) {
  }

  void resolveDot(Node node) {
  }

  void resolveDotCall(Node node) {
  }

  void resolveCall(Node node) {
  }

  void resolveSuperCall(Node node) {
  }

  void resolveNew(Node node) {
  }

  void resolveError(Node node) {
  }

  void resolveSequence(Node node) {
  }

  void resolveParameterize(Node node) {
  }

  void resolveCast(Node node) {
  }

  void resolveImplicitCast(Node node) {
  }

  void resolveDefault(Node node) {
  }
}
