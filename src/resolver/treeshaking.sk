class TreeShakingPass {
  CompilerOptions options;
  var isFirstList = true;
  var includedSymbols = IntMap<bool>();
  var includedTypes = IntMap<bool>();

  static void run(Node program, CompilerOptions options, Resolver resolver) {
    var pass = TreeShakingPass(options);
    var allSymbols = resolver.allSymbols;

    // Include all exported symbols
    for (var i = 0; i < allSymbols.size(); i++) {
      var symbol = allSymbols[i];
      if (symbol.isExport() || symbol.isEntryPoint()) {
        pass.includeSymbol(symbol);
      }
    }

    // For each included symbol, also include any overriding symbols if the
    // enclosing type is also included. In the example below, the use of
    // IFoo.foo() will cause Bar.foo() to be included because Bar() is used
    // but will not cause Baz.foo() to be included because Baz() isn't used.
    //
    //   class IFoo { virtual void foo(); }
    //   class Bar : IFoo { override void foo() {} }
    //   class Baz : IFoo { override void foo() {} }
    //   export void test() { ((IFoo)Bar()).foo(); }
    //
    // This iterates until a fixed point is reached because there may be
    // complex dependency issues. The work list is narrowed down before the
    // fixed point loop to reduce overhead.
    List<Symbol> deadSymbolsWithOverrides = [];
    var isFixedPoint = false;
    for (var i = 0; i < allSymbols.size(); i++) {
      var symbol = allSymbols[i];
      if (!(symbol.uniqueID in pass.includedSymbols) && symbol.overriddenMember != null) {
        deadSymbolsWithOverrides.push(symbol);
      }
    }
    while (!isFixedPoint) {
      isFixedPoint = true;
      for (var i = 0; i < deadSymbolsWithOverrides.size(); i++) {
        if (pass.includeDueToOverriddenMember(deadSymbolsWithOverrides[i])) {
          isFixedPoint = false;
        }
      }
    }

    // Remove symbols that aren't included
    for (var i = 0; i < allSymbols.size(); i++) {
      if (pass.removeSymbolIfDead(allSymbols[i])) {
        allSymbols.remove(i);
        i--;
      }
    }
  }

  void includeSymbol(Symbol symbol) {
    // Don't include constants, needed because constant folding hasn't run yet
    if (symbol.kind == .GLOBAL_VARIABLE && symbol.isConst() && options.foldAllConstants) {
      return;
    }

    if (!(symbol.uniqueID in includedSymbols)) {
      includedSymbols[symbol.uniqueID] = true;

      // This symbol depends on the enclosing symbol being present
      if (symbol.enclosingSymbol != null && symbol.kind != .INSTANCE_VARIABLE) {
        includeSymbol(symbol.enclosingSymbol);
      }

      // Object types depend on their constructor even if not explicitly used
      if (symbol.kind.isObject()) {
        var constructor = symbol.type.constructor();
        if (constructor != null) {
          includeSymbol(constructor.symbol);
        }
      }

      // This symbol depends on all other relevant types
      if (symbol.type.hasRelevantTypes()) {
        var types = symbol.type.relevantTypes;
        for (var i = 0; i < types.size(); i++) {
          var relevantSymbol = types[i].symbol;

          // Function types don't have a symbol
          if (relevantSymbol != null) {
            includeSymbol(relevantSymbol);
          }
        }
      }

      // Recursively include child non-structural nodes
      var node = symbol.node;
      if (node != null && !node.kind.isNamedBlockDeclaration()) {
        visit(node);
      }
    }
  }

  void includeType(Type type) {
    if (!(type.uniqueID in includedTypes)) {
      includedTypes[type.uniqueID] = true;
      if (type.symbol != null) {
        includeSymbol(type.symbol);
        if (type.isParameterized()) {
          for (var i = 0; i < type.substitutions.size(); i++) {
            includeType(type.substitutions[i]);
          }
        }
      }
    }
  }

  void visit(Node node) {
    if (node.symbol != null) {
      includeSymbol(node.symbol);
    }

    if (node.type != null) {
      includeType(node.type);
    }

    // Make sure the "_literal_" method is kept around
    if (options.targetFormat == .CPP && node.kind == .LIST && isFirstList) {
      var literal = node.type.findMember("_literal_");
      assert literal != null;
      includeSymbol(literal.symbol);
      isFirstList = false;
    }

    if (node.hasChildren()) {
      for (var i = 0; i < node.children.size(); i++) {
        var child = node.children[i];
        if (child != null) {
          visit(child);
        }
      }
    }
  }

  bool includeDueToOverriddenMember(Symbol symbol) {
    assert symbol.overriddenMember != null;
    assert symbol.enclosingSymbol != null;

    if (!(symbol.uniqueID in includedSymbols) && (symbol.overriddenMember.symbol.isImport() ||
        symbol.enclosingSymbol.uniqueID in includedSymbols && symbol.overriddenMember.symbol.uniqueID in includedSymbols)) {
      includeSymbol(symbol);
      return true;
    }

    return false;
  }

  bool removeSymbolIfDead(Symbol symbol) {
    // Ignore irrelevant symbols
    if (symbol.kind == .LOCAL_VARIABLE) {
      return false;
    }

    // Remove symbols that aren't included
    if (!(symbol.uniqueID in includedSymbols)) {
      if (symbol.enclosingSymbol != null) {
        symbol.enclosingSymbol.type.members.remove(symbol.name);
      }

      // Quoted types need their original node kept around for printing later
      if (symbol.node != null && symbol.kind != .QUOTED_TYPE) {
        symbol.node.remove();
        symbol.node = null;
      }
      return true;
    }

    // Disconnect symbols that are included from overridden symbols that aren't included
    if (symbol.overriddenMember != null && !(symbol.overriddenMember.symbol.uniqueID in includedSymbols)) {
      symbol.overriddenMember = null;
    }
    return false;
  }
}
