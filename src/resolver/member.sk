class Member {
  Symbol symbol;
  Type enclosingType = null;

  // The type of the member may be different from the symbol since the symbol
  // represents the unparameterized type and the member is a parameterization
  // of that symbol
  Type type = null;

  // The member that this symbol re-parameterizes. The type of a member in a
  // derived type may depend on type substitution on that member's type in a
  // base class with a type environment:
  //
  //   class Foo<A, B> { A foo(B bar) {} }
  //   class Bar<T> : Foo<int, T> {}
  //   class Baz : Bar<bool> {}
  //   int baz = Baz().foo(false);
  //
  // In that case, parameterizedType stores the type environment to be applied
  // to the type of the dependency after being resolved. This needs to be
  // separate from enclosingType because the type environment for the dependency
  // may not be from the immediately enclosing type.
  Member dependency = null;
  Type parameterizedType = null;
}
