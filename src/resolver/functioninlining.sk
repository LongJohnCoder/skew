class FunctionInliningPass {
  static void run(CallGraph callGraph, CompilerOptions options) {
    var graph = InliningGraph(callGraph, options);
    for (var i = 0; i < graph.inliningInfo.length; i++) {
      inlineSymbol(graph, graph.inliningInfo.get(i));
    }
  }

  static void inlineSymbol(InliningGraph graph, InliningInfo info) {
    if (!info.shouldInline) {
      return;
    }

    // Inlining nested functions first is more efficient because it results in
    // fewer inlining operations. This won't enter an infinite loop because
    // inlining for all such functions has already been disabled.
    for (var i = 0; i < info.bodyCalls.length; i++) {
      inlineSymbol(graph, info.bodyCalls.get(i));
    }

    for (var i = 0; i < info.callSites.length; i++) {
      var callSite = info.callSites.get(i);
      if (callSite != null && callSite.kind == .CALL) {
        // Make sure each call site is inlined once by setting the call site to
        // null. The call site isn't removed from the list since we don't want
        // to mess up the indices of another call to inlineSymbol() further up
        // the call stack.
        info.callSites.set(i, null);
        var clone = info.inlineValue.clone();
        var values = callSite.removeChildren();
        assert values.length == info.arguments.length + 1;
        var value = values.shift();
        assert value.kind == .NAME && value.symbol == info.symbol;

        // If there are unused arguments, then stick any with side effects in a
        // sequence expression so they will be evaluated before the call body.
        // For example:
        //
        //   import int foo();
        //   int bar(int a, int b) { return a; }
        //   var baz = bar(1, foo());
        //
        // This should compile to:
        //
        //   var baz = (foo(), 1);
        //
        if (info.unusedArguments.length > 0) {
          List<Node> sequence = null;
          for (var j = 0; j < info.unusedArguments.length; j++) {
            var index = info.arguments.indexOf(info.unusedArguments.get(j));
            assert index >= 0;
            var replacement = values.get(index);
            if (!replacement.hasNoSideEffects()) {
              if (sequence == null) sequence = []; // Save on allocations
              sequence.push(replacement);
            }
          }
          if (sequence != null) {
            sequence.push(clone);
            callSite.become(Node.createSequence(sequence));
            recursivelySubstituteArguments(callSite, info.arguments, values);
            continue;
          }
        }

        callSite.become(clone);
        recursivelySubstituteArguments(callSite, info.arguments, values);
      }
    }
  }

  static void recursivelyInlineFunctionCalls(InliningGraph graph, Node node) {
    // Recursively inline child nodes first
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null) {
          recursivelyInlineFunctionCalls(graph, child);
        }
      }
    }

    // Inline calls after all children have been processed
    if (node.kind == .CALL) {
      var symbol = node.callValue().symbol;
      if (symbol != null) {
        var index = graph.symbolToInfoIndex.getOrDefault(symbol.uniqueID, -1);
        if (index >= 0) {
          inlineSymbol(graph, graph.inliningInfo.get(index));
        }
      }
    }
  }

  static void recursivelySubstituteArguments(Node node, List<Symbol> arguments, List<Node> values) {
    // Substitute the argument if this is an argument name
    if (node.symbol != null) {
      var index = arguments.indexOf(node.symbol);
      if (index >= 0) {
        node.replaceWith(values.get(index));
        return;
      }
    }

    // Otherwise, recursively search for substitutions in all child nodes
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null) {
          recursivelySubstituteArguments(child, arguments, values);
        }
      }
    }
  }
}

class InliningInfo {
  Symbol symbol;
  Node inlineValue;
  List<Node> callSites;
  List<Symbol> arguments;
  List<Symbol> unusedArguments;
  var shouldInline = true;
  List<InliningInfo> bodyCalls = [];
}

// Each node in the Inlining graph is a symbol of an inlineable function and
// each directional edge is from a first function to a second function that is
// called directly within the body of the first function. Indirect function
// calls that may become direct calls through inlining can be discovered by
// traversing edges of this graph.
class InliningGraph {
  List<InliningInfo> inliningInfo = [];
  var symbolToInfoIndex = IntMap<int>();

  new(CallGraph graph, CompilerOptions options) {
    // Create the nodes in the graph
    for (var i = 0; i < graph.callInfo.length; i++) {
      var info = createInliningInfo(graph.callInfo.get(i), options);
      if (info != null) {
        symbolToInfoIndex.set(info.symbol.uniqueID, inliningInfo.length);
        inliningInfo.push(info);
      }
    }

    // Create the edges in the graph
    for (var i = 0; i < inliningInfo.length; i++) {
      var info = inliningInfo.get(i);
      var callSites = graph.callInfo.get(graph.symbolToInfoIndex.get(info.symbol.uniqueID)).callSites;
      for (var j = 0; j < callSites.length; j++) {
        var callSite = callSites.get(j);
        for (var node = callSite.parent; node != null; node = node.parent) {
          if (node.kind == .FUNCTION && node.symbol.kind == .GLOBAL_FUNCTION) {
            var index = symbolToInfoIndex.getOrDefault(node.symbol.uniqueID, -1);
            if (index >= 0) {
              var other = inliningInfo.get(index);
              other.bodyCalls.push(info);
            }
          }
        }
      }
    }

    // Detect and disable infinitely expanding inline operations
    for (var i = 0; i < inliningInfo.length; i++) {
      var info = inliningInfo.get(i);
      info.shouldInline = !containsInfiniteExpansion(info, []);
    }

  }

  static bool containsInfiniteExpansion(InliningInfo info, List<Symbol> symbols) {
    // This shouldn't get very long in normal programs so O(n) here is fine
    if (symbols.indexOf(info.symbol) >= 0) {
      return true;
    }

    // Do a depth-first search on the graph and check for cycles
    symbols.push(info.symbol);
    for (var i = 0; i < info.bodyCalls.length; i++) {
      if (containsInfiniteExpansion(info.bodyCalls.get(i), symbols)) {
        return true;
      }
    }
    symbols.pop();
    return false;
  }

  static InliningInfo createInliningInfo(CallInfo info, CompilerOptions options) {
    var symbol = info.symbol;

    // Inline functions consisting of a single return statement
    if (symbol.kind == .GLOBAL_FUNCTION && (symbol.isInline() || options.inlineAllFunctions)) {
      var block = symbol.node.functionBlock();
      if (block == null) {
        return null;
      }

      // Replace functions with empty bodies with null if global constant
      // folding is active, since stray null expressions will automatically
      // be removed
      if (!block.hasChildren()) {
        if (options.foldAllConstants) {
          List<Symbol> arguments = [];
          var argumentVariables = symbol.node.functionArguments().children;
          for (var i = 0; i < argumentVariables.length; i++) {
            arguments.push(argumentVariables.get(i).symbol);
          }
          return InliningInfo(symbol, Node.createNull().withType(symbol.type.resultType()), info.callSites, arguments, arguments);
        }
        return null;
      }

      var first = block.children.get(0);
      Node inlineValue = null;

      // If the first value in the function is a return statement, then the
      // function body doesn't need to only have one statement. Subsequent
      // statements are just dead code and will never be executed anyway.
      if (first.kind == .RETURN) {
        inlineValue = first.returnValue();
      }

      // Otherwise, this statement must be a lone expression statement
      else if (first.kind == .EXPRESSION && block.children.length == 1) {
        inlineValue = first.expressionValue();
      }

      if (inlineValue != null) {
        // Count the number of times each symbol is observed. Argument
        // variables that are used more than once may need a let statement
        // to avoid changing the semantics of the call site. For now, just
        // only inline functions where each argument is used exactly once.
        var symbolCounts = IntMap<int>();
        if (recursivelyCountArgumentUses(inlineValue, symbolCounts)) {
          List<Symbol> unusedArguments = [];
          List<Symbol> arguments = [];
          var argumentVariables = symbol.node.functionArguments().children;
          var isSimpleSubstitution = true;
          for (var i = 0; i < argumentVariables.length; i++) {
            var argument = argumentVariables.get(i).symbol;
            assert argument != null;
            var count = symbolCounts.getOrDefault(argument.uniqueID, 0);
            if (count == 0) {
              unusedArguments.push(argument);
            } else if (count != 1) {
              isSimpleSubstitution = false;
              break;
            }
            arguments.push(argument);
          }
          if (isSimpleSubstitution) {
            return InliningInfo(symbol, inlineValue, info.callSites, arguments, unusedArguments);
          }
        }
      }
    }

    return null;
  }

  // This returns false if inlining is impossible
  static bool recursivelyCountArgumentUses(Node node, IntMap<int> symbolCounts) {
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null && !recursivelyCountArgumentUses(child, symbolCounts)) {
          return false;
        }
      }
    }

    // Prevent inlining of functions containing lambda expressions. These
    // functions may end up capturing their arguments, which means that direct
    // substitution would lead to incorrect code:
    //
    //   inline int fn() foo(int x) {
    //     return => x;
    //   }
    //   var x = 0;
    //   var y = foo(x++);
    //   var z = foo(x++);
    //
    if (node.kind == .LAMBDA) {
      return false;
    }

    var symbol = node.symbol;
    if (symbol != null) {
      symbolCounts.set(symbol.uniqueID, symbolCounts.getOrDefault(symbol.uniqueID, 0) + 1);

      // Prevent inlining of functions that modify their arguments locally. For
      // example, inlining this would lead to incorrect code:
      //
      //   inline int foo(int x, int y) {
      //     return x += y;
      //   }
      //   foo(1, 2);
      //
      if (node.isStorage()) {
        return false;
      }
    }

    return true;
  }
}
