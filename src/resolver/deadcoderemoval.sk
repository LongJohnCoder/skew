class DeadCodeRemovalPass {
  CompilerOptions options;
  var includedSymbols = IntMap<bool>();

  static void run(Node program, CompilerOptions options, Resolver resolver) {
    var pass = DeadCodeRemovalPass(options);
    var allSymbols = resolver.allSymbols;

    // Include all exported symbols
    for (var i = 0; i < allSymbols.size(); i++) {
      var symbol = allSymbols.get(i);
      if (symbol.isExport() || symbol.isVirtual()) {
        pass.includeSymbol(symbol);
      }
    }

    // Remove symbols that aren't included
    for (var i = 0; i < allSymbols.size(); i++) {
      var symbol = allSymbols.get(i);
      var node = symbol.node;
      if (node != null && !pass.includedSymbols.has(symbol.uniqueID)) {
        if (symbol.enclosingSymbol != null) {
          symbol.enclosingSymbol.type.members.remove(symbol.name);
        }
        allSymbols.remove(i);
        node.remove();
        i--;
      }
    }
  }

  void includeSymbol(Symbol symbol) {
    // Don't include constants, needed because constant folding hasn't run yet
    if (symbol.kind == .GLOBAL_VARIABLE && symbol.isConst() && options.foldAllConstants) {
      return;
    }

    if (!includedSymbols.has(symbol.uniqueID)) {
      includedSymbols.set(symbol.uniqueID, true);

      // This symbol depends on the enclosing symbol being present
      if (symbol.enclosingSymbol != null && symbol.kind != .INSTANCE_VARIABLE) {
        includeSymbol(symbol.enclosingSymbol);
      }

      // Object types depend on their constructor even if not explicitly used
      if (symbol.kind.isObject()) {
        var constructor = symbol.type.constructor();
        if (constructor != null) {
          includeSymbol(constructor.symbol);
        }
      }

      // This symbol depends on all other relevant types
      if (symbol.type.hasRelevantTypes()) {
        var types = symbol.type.relevantTypes;
        for (var i = 0; i < types.size(); i++) {
          var relevantSymbol = types.get(i).symbol;

          // Function types don't have a symbol
          if (relevantSymbol != null) {
            includeSymbol(relevantSymbol);
          }
        }
      }

      // Recursively include child non-structural nodes
      var node = symbol.node;
      if (node != null && !node.kind.isNamedBlockDeclaration()) {
        visit(node);
      }
    }
  }

  void visit(Node node) {
    if (node.symbol != null) {
      includeSymbol(node.symbol);
    }

    if (node.hasChildren()) {
      for (var i = 0; i < node.children.size(); i++) {
        var child = node.children.get(i);
        if (child != null) {
          visit(child);
        }
      }
    }
  }
}
