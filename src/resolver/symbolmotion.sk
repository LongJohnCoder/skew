class SymbolMotionPass {
  Resolver resolver;
  var shadowForSymbol = IntMap<Type>();

  static void run(Resolver resolver) {
    var pass = SymbolMotionPass(resolver);
    for (var i = 0; i < resolver.allSymbols.length; i++) {
      pass.moveSymbol(resolver.allSymbols.get(i));
    }
  }

  void moveSymbol(Symbol symbol) {
    var enclosingSymbol = symbol.enclosingSymbol;
    if (!symbol.isImport() && enclosingSymbol != null && symbol.kind != .PARAMETER && (enclosingSymbol.isImport() || symbol.kind.isFunction() && enclosingSymbol.kind.isEnum())) {
      // Move the symbol to an automatically-generated namespace
      var enclosingType = symbol.enclosingSymbol.type;
      var shadow = createShadowForSymbol(enclosingSymbol);
      var member = enclosingType.members.get(symbol.name);
      assert member.symbol == symbol;
      enclosingType.members.remove(symbol.name);
      assert shadow.findMember(symbol.name) == null;
      shadow.addMember(member);
      symbol.enclosingSymbol = shadow.symbol;

      // Move the node for this symbol inside the namespace node
      var block = shadow.symbol.node.declarationBlock();
      var parent = symbol.node.parent;
      var node = symbol.node.remove();
      if (parent.kind == .VARIABLE_CLUSTER) {
        node = Node.createVariableCluster(Node.createType(symbol.type), { node });
        if (parent.children.length == 1) {
          parent.remove();
        }
      }
      block.appendChild(node);
    }
  }

  Type createShadowForSymbol(Symbol symbol) {
    // Shortcut past the shadow setup code for speed
    var existing = shadowForSymbol.getOrDefault(symbol.uniqueID, null);
    if (existing != null) {
      return existing;
    }

    // Get or create a namespace called "in", which must be free since it's a keyword
    var enclosingSymbol = symbol.enclosingSymbol;
    var enclosingType = enclosingSymbol.type;
    var inMember = enclosingType.findMember("in");
    Type inType;
    if (inMember != null) {
      inType = inMember.type;
    } else {
      var inSymbol = resolver.createSymbol("in", .NAMESPACE);
      inSymbol.enclosingSymbol = enclosingSymbol;
      inType = inSymbol.type = Type(inSymbol);
      inMember = Member(inSymbol);
      inMember.type = inType;
      enclosingType.addMember(inMember);
      inSymbol.node = Node.createNamespace(Node.createName("in").withSymbol(inSymbol), Node.createBlock({})).withSymbol(inSymbol);
      symbol.node.insertSiblingAfter(inSymbol.node);
    }

    // Create a namespace with the same name as this symbol
    var shadowSymbol = resolver.createSymbol(symbol.name, .NAMESPACE);
    var shadowType = shadowSymbol.type = Type(shadowSymbol);
    var shadowMember = Member(shadowSymbol);
    shadowSymbol.enclosingSymbol = inType.symbol;
    shadowMember.type = shadowType;
    assert inType.findMember(symbol.name) == null;
    inType.addMember(shadowMember);
    shadowForSymbol.set(symbol.uniqueID, shadowType);
    shadowSymbol.node = Node.createNamespace(Node.createName(symbol.name).withSymbol(shadowSymbol), Node.createBlock({})).withSymbol(shadowSymbol);
    inType.symbol.node.declarationBlock().appendChild(shadowSymbol.node);
    return shadowType;
  }
}
