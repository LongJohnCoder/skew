enum SymbolKind {
  OTHER,
  PARAMETER,
  OTHER_TYPE,
  USING_ALIAS,

  // Namespace kinds
  GLOBAL_NAMESPACE,
  NAMESPACE,

  // Enum kinds
  ENUM,
  ENUM_FLAGS,

  // Object kinds
  CLASS,
  STRUCT,
  INTERFACE,

  // Function kinds
  GLOBAL_FUNCTION,
  INSTANCE_FUNCTION,
  CONSTRUCTOR_FUNCTION,

  // Variable kinds
  LOCAL_VARIABLE,
  GLOBAL_VARIABLE,
  INSTANCE_VARIABLE,
}

in SymbolKind {
  bool isGlobalNamespace() {
    return this == SymbolKind.GLOBAL_NAMESPACE;
  }

  bool isNamespace() {
    return this >= GLOBAL_NAMESPACE && this <= NAMESPACE;
  }

  bool isEnum() {
    return this >= ENUM && this <= ENUM_FLAGS;
  }

  bool isObject() {
    return this >= CLASS && this <= INTERFACE;
  }

  bool isType() {
    return this >= PARAMETER && this <= INTERFACE;
  }

  bool isConstructor() {
    return this == CONSTRUCTOR_FUNCTION;
  }

  bool isFunction() {
    return this >= GLOBAL_FUNCTION && this <= CONSTRUCTOR_FUNCTION;
  }

  bool isVariable() {
    return this >= LOCAL_VARIABLE && this <= INSTANCE_VARIABLE;
  }

  bool isInstance() {
    return this == INSTANCE_FUNCTION || this == INSTANCE_VARIABLE || this == CONSTRUCTOR_FUNCTION;
  }
}

enum flags SymbolFlag {
  // Access flags
  PUBLIC,
  PRIVATE,
  PROTECTED,

  // Structural flags
  ABSTRACT,
  OVERRIDE,
  STATIC,
  VIRTUAL,
  FROM_EXTENSION,

  // Optimization flags
  FINAL,
  INLINE,

  // Binding flags
  EXPORT,
  IMPORT,

  // Symbols have a temporary initializing state to detect cyclic declarations
  // such as "foo foo;" or "class Foo : Foo {}". Symbols can only be uninitialized
  // if they have a declaration.
  INITIALIZING,
  INITIALIZED,
}

class Symbol {
  string name;
  SymbolKind kind;
  SymbolFlag flags = 0;
  Type type = null;

  // This contains the declaration if there was one. Symbols generated by the
  // compiler may have no declaration.
  Node node = null;

  // The symbol whose type contains this symbol as a member, if any. This
  // symbol may be a namespace, enum, or object declaration. Function
  // declarations are not stored here even though they are "enclosing symbols"
  // because you don't access symbols declared inside the function off of the
  // function symbol.
  Symbol enclosingSymbol = null;

  // The value that this symbol takes if it is of enum type. Only user-defined
  // enums have an enum value, so this should be ignored for imported enums.
  int enumValue = 0;

  bool isPublic() {
    return (flags & SymbolFlag.PUBLIC) != 0;
  }

  bool isPrivate() {
    return (flags & SymbolFlag.PRIVATE) != 0;
  }

  bool isProtected() {
    return (flags & SymbolFlag.PROTECTED) != 0;
  }

  bool isAbstract() {
    return (flags & SymbolFlag.ABSTRACT) != 0;
  }

  bool isOverride() {
    return (flags & SymbolFlag.OVERRIDE) != 0;
  }

  bool isStatic() {
    return (flags & SymbolFlag.STATIC) != 0;
  }

  bool isVirtual() {
    return (flags & SymbolFlag.VIRTUAL) != 0;
  }

  bool isFromExtension() {
    return (flags & SymbolFlag.FROM_EXTENSION) != 0;
  }

  bool isFinal() {
    return (flags & SymbolFlag.FINAL) != 0;
  }

  bool isInline() {
    return (flags & SymbolFlag.INLINE) != 0;
  }

  bool isImport() {
    return (flags & SymbolFlag.IMPORT) != 0;
  }

  bool isExport() {
    return (flags & SymbolFlag.EXPORT) != 0;
  }

  bool isUninitialized() {
    assert (flags & (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED)) != (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED);
    return (flags & (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED)) == 0;
  }

  bool isInitializing() {
    assert (flags & (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED)) != (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED);
    return (flags & SymbolFlag.INITIALIZING) != 0;
  }

  bool isInitialized() {
    assert (flags & (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED)) != (SymbolFlag.INITIALIZING | SymbolFlag.INITIALIZED);
    return (flags & SymbolFlag.INITIALIZED) != 0;
  }
}
