enum SymbolKind {
  OTHER,
  DEFINE,
  AUTOMATIC,
  AMBIGUOUS,
  UNMERGED,
  QUOTED_TYPE,
  OTHER_TYPE,
  ALIAS,

  // Parameter kinds
  OBJECT_PARAMETER,
  FUNCTION_PARAMETER,

  // Namespace kinds
  GLOBAL_NAMESPACE,
  NAMESPACE,

  // Enum kinds
  ENUM,
  ENUM_FLAGS,

  // Object kinds
  CLASS,
  INTERFACE,

  // Function kinds
  GLOBAL_FUNCTION,
  INSTANCE_FUNCTION,
  CONSTRUCTOR_FUNCTION,

  // Variable kinds
  LOCAL_VARIABLE,
  GLOBAL_VARIABLE,
  INSTANCE_VARIABLE,
}

in SymbolKind {
  bool isParameter() {
    return this >= OBJECT_PARAMETER && this <= FUNCTION_PARAMETER;
  }

  bool isNamespace() {
    return this >= GLOBAL_NAMESPACE && this <= NAMESPACE;
  }

  bool isTypeWithInstances() {
    return this >= ENUM && this <= INTERFACE;
  }

  bool isEnum() {
    return this >= ENUM && this <= ENUM_FLAGS;
  }

  bool isObject() {
    return this >= CLASS && this <= INTERFACE;
  }

  bool isType() {
    return this >= QUOTED_TYPE && this <= INTERFACE;
  }

  bool isFunction() {
    return this >= GLOBAL_FUNCTION && this <= CONSTRUCTOR_FUNCTION;
  }

  bool isVariable() {
    return this >= LOCAL_VARIABLE && this <= INSTANCE_VARIABLE;
  }

  bool isGlobal() {
    return this == GLOBAL_FUNCTION || this == GLOBAL_VARIABLE;
  }

  bool isInstance() {
    return this == INSTANCE_FUNCTION || this == INSTANCE_VARIABLE || this == CONSTRUCTOR_FUNCTION;
  }
}

enum flags SymbolFlag {
  // Access flags
  PUBLIC,
  PRIVATE,
  PROTECTED,

  // Structural flags
  ABSTRACT,
  FROM_EXTENSION,
  OVERRIDE,
  STATIC,
  VIRTUAL,

  // Optimization flags
  FINAL,
  INLINE,
  CONST,
  PURE,

  // Binding flags
  EXPORT,
  IMPORT,

  // Symbols have a temporary initializing state to detect cyclic declarations
  // such as "foo foo;" or "class Foo : Foo {}". Symbols can only be
  // uninitialized if they have a declaration.
  INITIALIZING,
  INITIALIZED,

  // Other flags
  EXTERN_C,
  PRIMITIVE,
  ENTRY_POINT,
  HAS_ANNOTATIONS,
  HAS_LOCATION_ERROR,

  // Masks
  INITIALIZE_MASK = INITIALIZING | INITIALIZED,
}

class Symbol {
  string name;
  SymbolKind kind;
  SymbolFlag flags = 0;
  Type type = null;

  // This contains the declaration if there was one. Symbols generated by the
  // compiler may have no declaration.
  Node node = null;

  // The symbol whose type contains this symbol as a member, if any. This
  // symbol may be a namespace, enum, or object declaration. Function
  // declarations are not stored here even though they are "enclosing symbols"
  // because you don't access symbols declared inside the function off of the
  // function symbol.
  Symbol enclosingSymbol = null;

  // This stores the symbol that caused this symbol to become abstract. Only
  // object types may be abstract, so this only applies to object types.
  Symbol reasonForAbstract = null;

  // The member from a base type that this symbol is shadowing. If that same
  // member comes from multiple base types, the overridden member will point
  // to an unmerged member containing the members to be merged.
  Member overriddenMember = null;

  // The value for a constant symbol. Variables create constants when the
  // "const" keyword is used, and all non-imported enum values are constants.
  Content constant = null;

  // Ambiguous symbols due to using namespace statements are allowed and are
  // only an error when used. All symbols in the collision are tracked here
  // for nice error messages. This is also used to track unmerged symbols from
  // multiple base types.
  List<Member> identicalMembers = null;

  // These are generic type parameter symbols, in order of declaration
  List<Symbol> parameters = null;

  // Type parameters sorted by dependencies, which occur where one type
  // parameter is used by the other:
  //
  //   class Foo<A is IFoo<B>, B> {}
  //   interface IFoo<T> {}
  //   Foo<IFoo<int>, int> foo;
  //
  List<Symbol> sortedParameters = null;

  // Operator overloading information is held here when present. This maps
  // members of the NodeKind enum to lists of members on this type.
  IntMap<List<Symbol>> operatorOverloads = null;

  // This tracks headers referenced by the @NeedsInclude annotation
  List<string> neededIncludes = null;

  // This tracks the name set by the @EmitAs annotation
  StringContent emitAs = null;

  // Give each type a unique integer as a hash code
  static var nextUniqueID = -1;
  var uniqueID = generateUniqueID();

  static int generateUniqueID() {
    nextUniqueID++;
    return nextUniqueID;
  }

  void sortParametersByDependencies() {
    sortedParameters = parameters.clone();
    for (var i = 0; i < sortedParameters.size(); i++) {
      var j = i;

      // Select a parameter that doesn't depend on any unchecked parameter
      for (; j < sortedParameters.size(); j++) {
        var k = i;

        // Find bounded type parameters
        var parameter = sortedParameters[j];
        if (!parameter.type.isParameter()) {
          continue;
        }
        var parameterBound = parameter.type.bound();
        if (parameterBound == null) {
          break;
        }

        // Check to see if this depends on any other unchecked parameters
        for (; k < sortedParameters.size(); k++) {
          var other = sortedParameters[k];
          if (parameter == other || !other.type.isParameter()) {
            continue;
          }
          if (parameterBound != null && parameterBound.dependsOnParameter(other)) {
            break;
          }
        }
        if (k == sortedParameters.size()) {
          break;
        }
      }

      // Swap the parameter into the correct order
      if (j < sortedParameters.size()) {
        sortedParameters.swap(i, j);
      }
    }
  }

  void addNeededInclude(string name) {
    if (neededIncludes == null) {
      neededIncludes = [];
    }
    if (!(name in neededIncludes)) {
      neededIncludes.push(name);
    }
  }

  List<Symbol> operatorOverloadsForKind(NodeKind kind) {
    if (operatorOverloads == null) {
      operatorOverloads = IntMap<List<Symbol>>();
    }
    var symbols = operatorOverloads.getOrDefault(kind, null);
    if (symbols == null) {
      symbols = [];
      operatorOverloads[kind] = symbols;
    }
    return symbols;
  }

  string fullName() {
    return enclosingSymbol != null && !kind.isParameter() && enclosingSymbol.kind != .GLOBAL_NAMESPACE
      ? enclosingSymbol.fullName() + "." + name : name;
  }

  bool hasParameters() {
    return parameters != null && parameters.size() > 0;
  }

  bool isEnumValue() {
    return kind.isVariable() && enclosingSymbol != null && enclosingSymbol.kind.isEnum() && !isFromExtension();
  }

  bool isObjectMember() {
    return enclosingSymbol != null && enclosingSymbol.kind.isObject();
  }

  bool isEnumMember() {
    return enclosingSymbol != null && enclosingSymbol.kind.isEnum();
  }

  bool isPublic() {
    return (flags & .PUBLIC) != 0;
  }

  bool isPrivate() {
    return (flags & .PRIVATE) != 0;
  }

  bool isProtected() {
    return (flags & .PROTECTED) != 0;
  }

  bool isAbstract() {
    return (flags & .ABSTRACT) != 0;
  }

  bool isFromExtension() {
    return (flags & .FROM_EXTENSION) != 0;
  }

  bool isOverride() {
    return (flags & .OVERRIDE) != 0;
  }

  bool isStatic() {
    return (flags & .STATIC) != 0;
  }

  bool isVirtual() {
    return (flags & .VIRTUAL) != 0;
  }

  bool isFinal() {
    return (flags & .FINAL) != 0;
  }

  bool isInline() {
    return (flags & .INLINE) != 0;
  }

  bool isConst() {
    return (flags & .CONST) != 0;
  }

  bool isPure() {
    return (flags & .PURE) != 0;
  }

  bool isImport() {
    return (flags & .IMPORT) != 0;
  }

  bool isExport() {
    return (flags & .EXPORT) != 0;
  }

  bool isImportOrExport() {
    return (flags & (.IMPORT | .EXPORT)) != 0;
  }

  bool isUninitialized() {
    assert (flags & .INITIALIZE_MASK) != .INITIALIZE_MASK;
    return (flags & .INITIALIZE_MASK) == 0;
  }

  bool isInitializing() {
    assert (flags & .INITIALIZE_MASK) != .INITIALIZE_MASK;
    return (flags & .INITIALIZING) != 0;
  }

  bool isInitialized() {
    assert (flags & .INITIALIZE_MASK) != .INITIALIZE_MASK;
    return (flags & .INITIALIZED) != 0;
  }

  bool isPrimitive() {
    return (flags & .PRIMITIVE) != 0;
  }

  bool isExternC() {
    return (flags & .EXTERN_C) != 0;
  }

  bool isEntryPoint() {
    return (flags & .ENTRY_POINT) != 0;
  }

  bool hasAnnotations() {
    return (flags & .HAS_ANNOTATIONS) != 0;
  }

  bool hasLocationError() {
    return (flags & .HAS_LOCATION_ERROR) != 0;
  }
}

class SymbolComparison : Comparison<Symbol> {
  static final var INSTANCE = SymbolComparison();

  override int compare(Symbol left, Symbol right) {
    return left.uniqueID - right.uniqueID;
  }
}
