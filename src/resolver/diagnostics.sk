string typeToText(Type type) {
  return "type \"" + type + "\"";
}

////////////////////////////////////////////////////////////////////////////////

void semanticWarningUnusedExpression(Log log, Range range) {
  log.warning(range, "Unused expression");
}

void semanticWarningDuplicateModifier(Log log, Range range, string modifier) {
  log.warning(range, "Duplicate modifier " + simpleQuote(modifier));
}

void semanticErrorRedundantModifier(Log log, Range range, string modifier, string where) {
  log.error(range, "Redundant modifier " + simpleQuote(modifier) + " " + where);
}

void semanticErrorUnexpectedModifier(Log log, Range range, string modifier, string where) {
  log.error(range, "Cannot use the " + simpleQuote(modifier) + " modifier " + where);
}

void semanticErrorExpectedModifier(Log log, Range range, string modifier, string where) {
  log.error(range, "Expected the " + simpleQuote(modifier) + " modifier " + where);
}

void semanticErrorDuplicateSymbol(Log log, Range range, string name, Range previous) {
  log.error(range, simpleQuote(name) + " is already declared");
  if (!previous.isEmpty()) log.note(previous, "The previous declaration is here");
}

void semanticErrorUnexpectedNode(Log log, Range range, NodeKind kind) {
  log.error(range, "Unexpected " + kind);
}

void semanticErrorUnexpectedExpression(Log log, Range range, Type type) {
  log.error(range, "Unexpected expression of " + typeToText(type));
}

void semanticErrorUnexpectedType(Log log, Range range, Type type) {
  log.error(range, "Unexpected " + typeToText(type));
}

void semanticErrorUndeclaredSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name) + " is not declared");
}

void semanticErrorUnknownMemberSymbol(Log log, Range range, string name, Type type) {
  log.error(range, simpleQuote(name) + " is not declared on " + typeToText(type));
}

void semanticErrorExtensionMissingTarget(Log log, Range range, string name) {
  log.error(range, "No type named " + simpleQuote(name) + " to extend");
}

void semanticErrorDifferentModifiers(Log log, Range range, string name, Range previous) {
  log.error(range, "Cannot merge multiple declarations for " + simpleQuote(name) + " with different modifiers");
  if (!previous.isEmpty()) log.note(previous, "The conflicting declaration is here");
}

void semanticErrorBadUsingValue(Log log, Range range) {
  log.error(range, "Expected a type here");
}

void semanticErrorBadUsing(Log log, Range range) {
  log.error(range, "Expected a namespace here");
}

void semanticErrorUnexpectedStatement(Log log, Range range) {
  log.error(range, "Cannot use this statement here");
}

void semanticErrorCyclicDeclaration(Log log, Range range, string name) {
  log.error(range, "Cyclic declaration of " + simpleQuote(name));
}

void semanticErrorUnexpectedThis(Log log, Range range, string name) {
  log.error(range, "Cannot use " + simpleQuote(name) + " outside a class");
}

void semanticErrorStaticThis(Log log, Range range, string name) {
  log.error(range, "Cannot access " + simpleQuote(name) + " from a static context");
}

void semanticErrorIncompatibleTypes(Log log, Range range, Type from, Type to, bool isCastAllowed) {
  log.error(range, "Cannot convert from " + typeToText(from) + " to " + typeToText(to) + (isCastAllowed ? " without a cast" : ""));
}

void semanticErrorNoCommonType(Log log, Range range, Type left, Type right) {
  log.error(range, "No common type for " + typeToText(left) + " and " + typeToText(right));
}

void semanticErrorLambdaReturnTypeInferenceFailed(Log log, Range range, Range failed, Type left, Type right) {
  log.error(range, "Could not infer return type of lambda expression");
  if (!failed.isEmpty()) log.note(failed, "No common type for " + typeToText(left) + " and " + typeToText(right));
}

void semanticErrorBadType(Log log, Range range, Type type) {
  log.error(range, "Cannot use " + typeToText(type) + " here");
}

void semanticErrorMemberUnexpectedStatic(Log log, Range range, string name) {
  log.error(range, "Cannot access static member " + simpleQuote(name) + " from an instance context");
}

void semanticErrorMemberUnexpectedInstance(Log log, Range range, string name) {
  log.error(range, "Cannot access instance member " + simpleQuote(name) + " from a static context");
}

void semanticErrorMissingTypeContext(Log log, Range range) {
  log.error(range, "Expression has no type context here");
}

void semanticErrorBadTypeParameterBound(Log log, Range range, Type type) {
  log.error(range, "Cannot use " + typeToText(type) + " as a type parameter bound");
}

void semanticErrorUninitializedExtensionVariable(Log log, Range range) {
  log.error(range, "Instance variables in extension blocks must be initialized");
}

void semanticErrorNonPureGlobalVariable(Log log, Range range) {
  log.error(range, "Global variables must be initialized to a pure expression (one without side effects)");
}

void semanticErrorNonConstantConstValue(Log log, Range range) {
  log.error(range, "Variables with the \"const\" modifier must be initialized to a compile-time constant");
}

void semanticErrorConstMissingValue(Log log, Range range) {
  log.error(range, "Variables with the \"const\" modifier must be initialized");
}

void semanticErrorVarMissingValue(Log log, Range range) {
  log.error(range, "Implicitly typed variables must be initialized");
}

void semanticErrorVarBadType(Log log, Range range, Type type) {
  log.error(range, "Implicitly typed variables cannot be of " + typeToText(type));
}

void semanticErrorInvalidCall(Log log, Range range, Type type) {
  log.error(range, "Cannot call " + typeToText(type));
}

void semanticErrorParameterCount(Log log, Range range, int expected, int found) {
  log.error(range, "Expected " + expected + plural(expected, " type parameter", " type parameters") +
    " but found " + found + plural(found, " type parameter", " type parameters"));
}

void semanticErrorArgumentCount(Log log, Range range, int expected, int found) {
  log.error(range, "Expected " + expected + plural(expected, " argument", " arguments") +
    " but found " + found + plural(found, " argument", " arguments"));
}

void semanticErrorExpectedReturnValue(Log log, Range range, Type type) {
  log.error(range, "Return statement must return " + typeToText(type));
}

void semanticErrorBadLambdaTypeContext(Log log, Range range, Type type) {
  log.error(range, "Cannot use a lambda expression with " + typeToText(type));
}

void semanticErrorNonConstantCaseValue(Log log, Range range) {
  log.error(range, "Non-constant case value");
}

void semanticErrorBadDefaultCase(Log log, Range range) {
  log.error(range, "Only the last case can be a default case");
}

void semanticErrorNonIntegerSwitch(Log log, Range range, Type type) {
  log.error(range, "Expected an integer type but got " + typeToText(type));
}

void semanticErrorDuplicateCase(Log log, Range range, Range previous) {
  log.error(range, "Duplicate case value");
  if (!previous.isEmpty()) log.note(previous, "The first occurrence is here");
}

void semanticErrorUnconstructableType(Log log, Range range, Type type) {
  log.error(range, "Cannot construct " + typeToText(type));
}

void semanticErrorAbstractConstructorInitializer(Log log, Range range) {
  log.error(range, "An abstract constructor must not have initializer list");
}

void semanticErrorAbstractNew(Log log, Range range, Type type, Range reason, string name) {
  log.error(range, "Cannot construct abstract " + typeToText(type));
  if (!reason.isEmpty()) log.note(reason, "The " + typeToText(type) + " is abstract due to member " + simpleQuote(name));
}

void semanticErrorUnexpectedBaseType(Log log, Range range, string what) {
  log.error(range, what + " cannot inherit from another type");
}

void semanticErrorClassBaseNotFirst(Log log, Range range, Type type) {
  log.error(range, "Base " + typeToText(type) + " must come first in a class declaration");
}

void semanticErrorBaseTypeNotInterface(Log log, Range range, Type type) {
  log.error(range, "Base " + typeToText(type) + " must be an interface");
}

void semanticErrorDuplicateBaseType(Log log, Range range, Type type) {
  log.error(range, "Duplicate base " + typeToText(type));
}

void semanticErrorAmbiguousSymbol(Log log, Range range, string name, List<string> names) {
  for (var i = 0; i < names.size(); i++) names.set(i, simpleQuote(names.get(i)));
  log.error(range, "Reference to " + simpleQuote(name) + " is ambiguous, could be " + " or ".join(names));
}

void semanticErrorUnmergedSymbol(Log log, Range range, string name, List<Type> types) {
  List<string> names = [];
  for (var i = 0; i < types.size(); i++) names.push(typeToText(types.get(i)));
  log.error(range, "Member " + simpleQuote(name) + " has an ambiguous inherited type, could be " + " or ".join(names));
}

void semanticErrorBadOverride(Log log, Range range, string name, Type base, Range overridden) {
  log.error(range, simpleQuote(name) + " overrides another declaration with the same name in base " + typeToText(base));
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorOverrideDifferentTypes(Log log, Range range, string name, Type base, Type derived, Range overridden) {
  log.error(range, simpleQuote(name) + " must have the same signature as the method it overrides (expected " +
    typeToText(base) + " but found " + typeToText(derived) + ")");
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorModifierMissingOverride(Log log, Range range, string name, Range overridden) {
  log.error(range, simpleQuote(name) + " overrides another symbol with the same name but is missing the \"override\" modifier");
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorCannotOverrideNonVirtual(Log log, Range range, string name, Range overridden) {
  log.error(range, simpleQuote(name) + " cannot override a non-virtual method");
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorBadIntegerConstant(Log log, Range range, Type type) {
  log.error(range, "Expected integer constant but found expression of " + typeToText(type));
}

void semanticErrorNoUnaryOperator(Log log, Range range, NodeKind kind, Type type) {
  assert kind.isUnaryOperator();
  log.error(range, "No unary operator " + operatorInfo.get(kind).text + " for " + typeToText(type));
}

void semanticErrorNoBinaryOperator(Log log, Range range, NodeKind kind, Type left, Type right) {
  assert kind.isBinaryOperator();
  log.error(range, "No binary operator " + operatorInfo.get(kind).text + " for " + typeToText(left) + " and " + typeToText(right));
}

void semanticErrorNoTernaryOperator(Log log, Range range, NodeKind kind, Type left, Type middle, Type right) {
  assert kind.isTernaryOperator();
  log.error(range, "No ternary operator " + operatorInfo.get(kind).text + " for " + typeToText(left) + ", " + typeToText(middle) + ", and " + typeToText(right));
}

void semanticErrorBadStorage(Log log, Range range) {
  log.error(range, "Cannot store to this location");
}

void semanticErrorStorageToProtectedSymbol(Log log, Range range, string modifier) {
  log.error(range, "Cannot store to a symbol marked as " + simpleQuote(modifier));
}

void semanticErrorUnparameterizedType(Log log, Range range, Type type) {
  log.error(range, "Cannot use unparameterized " + typeToText(type));
}

void semanticErrorCannotParameterize(Log log, Range range, Type type) {
  log.error(range, "Cannot parameterize " + typeToText(type) + (
    type.hasParameters() ? " because it is already parameterized" : " because it has no type parameters"));
}

void semanticErrorBadSuperInitializer(Log log, Range range) {
  log.error(range, "No base constructor to call");
}

void semanticErrorMissingSuperInitializer(Log log, Range range) {
  log.error(range, "Missing call to \"super\" in initializer list");
}

void semanticErrorAlreadyInitialized(Log log, Range range, string name, Range previous) {
  log.error(range, simpleQuote(name) + " is already initialized");
  if (!previous.isEmpty()) log.note(previous, "The previous initialization is here");
}

void semanticErrorBadEnumToString(Log log, Range range, string name, string first, string second, int value) {
  log.error(range, "Cannot automatically generate \"toString\" for " + simpleQuote(name) + " because " +
    simpleQuote(first) + " and " + simpleQuote(second) + " both have the same value " + value);
}

void semanticErrorMissingReturn(Log log, Range range, string name, Type type) {
  log.error(range, "All control paths for " + simpleQuote(name) + " must return a value of " + typeToText(type));
}

void semanticErrorLambdaMissingReturn(Log log, Range range, Type type) {
  log.error(range, "All control paths for lambda expression must return a value of " + typeToText(type));
}

void semanticErrorBaseClassInExtension(Log log, Range range) {
  log.error(range, "The base class must be set from the class declaration, not from an extension block");
}

void semanticErrorMustCallFunctionReference(Log log, Range range) {
  log.error(range, "Raw function references are not allowed (call the function instead)");
}

void semanticErrorMissingToString(Log log, Range range, Type type) {
  log.error(range, "Expression of " + typeToText(type) + " has no toString() member to call");
}

void semanticErrorToStringWrongType(Log log, Range range, Type expected, Type found, Range declaration) {
  log.error(range, "Expected toString() to have " + typeToText(expected) + " but found " + typeToText(found));
  if (!declaration.isEmpty()) log.note(declaration, "The declaration for toString() is here");
}

void semanticErrorCannotImplementImportedFunction(Log log, Range range) {
  log.error(range, "Imported functions cannot have an implementation");
}

void semanticErrorFunctionMustBeAbstract(Log log, Range range) {
  log.error(range, "Abstract functions must use the \"virtual\" modifier");
}

void semanticErrorUnimplementedConstructor(Log log, Range range) {
  log.error(range, "Every constructor must have an implementation");
}

void semanticErrorUnimplementedFunction(Log log, Range range) {
  log.error(range, "Use the \"import\" modifier to import functions");
}

void semanticErrorNonConstantAssert(Log log, Range range) {
  log.error(range, "The argument to a compile-time assert must be a constant");
}

void semanticErrorFalseAssert(Log log, Range range) {
  log.error(range, "Assertion failed");
}

void semanticErrorListTypeInferenceFailed(Log log, Range range) {
  log.error(range, "Cannot infer a common element type for this list literal");
}

void semanticErrorNoDefaultValue(Log log, Range range, Type type) {
  log.error(range, "Cannot create a default value for " + typeToText(type));
}

void semanticErrorEnumValueOutOfRange(Log log, Range range, string name) {
  log.error(range, "Assigned value for enum " + simpleQuote(name) + " cannot fit in an integer");
}

void semanticErrorBadSuperCall(Log log, Range range) {
  log.error(range, "Cannot use \"super\" here");
}

void semanticErrorAbstractSuperCall(Log log, Range range, Range overridden) {
  log.error(range, "Cannot call abstract member in base class");
  if (!overridden.isEmpty()) log.note(overridden, "The overridden member is here");
}

void semanticErrorNestedStorageOperator(Log log, Range range) {
  log.error(range, "Assignment expressions are not allowed inside other expressions");
}

void semanticErrorForVariablesMustBeSameType(Log log, Range range, string firstName, Type firstType, string secondName, Type secondType) {
  log.error(range, "All for loop variables must have the same type (" +
    simpleQuote(firstName) + " has " + typeToText(firstType) + " but " +
    simpleQuote(secondName) + " has " + typeToText(secondType) + ")");
}
