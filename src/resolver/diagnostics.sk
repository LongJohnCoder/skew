string typeToText(Type type) {
  return "type \"".append(type.toString()).append("\"");
}

////////////////////////////////////////////////////////////////////////////////

void semanticWarningDuplicateModifier(Log log, Range range, string modifier) {
  log.warning(range, "Duplicate modifier ".append(simpleQuote(modifier)));
}

void semanticWarningRedundantModifier(Log log, Range range, string modifier) {
  log.warning(range, "Redundant modifier ".append(simpleQuote(modifier)));
}

void semanticWarningShadowedSymbol(Log log, Range range, string name, Range shadowed) {
  log.warning(range, simpleQuote(name).append(" shadows another symbol with the same name"));
  if (!shadowed.isEmpty()) log.note(shadowed, "The shadowed declaration is here");
}

void semanticErrorDuplicateSymbol(Log log, Range range, string name, Range previous) {
  log.error(range, simpleQuote(name).append(" is already declared"));
  if (!previous.isEmpty()) log.note(previous, "Previous declaration is here");
}

void semanticErrorUnexpectedNode(Log log, Range range, NodeKind kind) {
  log.error(range, "Unexpected ".append(kind.toString()));
}

void semanticErrorUnexpectedExpression(Log log, Range range, Type type) {
  log.error(range, "Unexpected expression of ".append(typeToText(type)));
}

void semanticErrorUnexpectedType(Log log, Range range, Type type) {
  log.error(range, "Unexpected ".append(typeToText(type)));
}

void semanticErrorUndeclaredSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name).append(" is not declared"));
}

void semanticErrorUndeclaredGlobalSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name).append(" is not declared at the global scope"));
}

void semanticErrorUnknownMemberSymbol(Log log, Range range, string name, Type type) {
  log.error(range, simpleQuote(name).append(" is not declared on ").append(typeToText(type)));
}

void semanticErrorExtensionMissingTarget(Log log, Range range, string name) {
  log.error(range, "No type named ".append(simpleQuote(name)).append(" to extend"));
}

void semanticErrorDifferentModifiers(Log log, Range range, string name, Range previous) {
  log.error(range, "Cannot merge multiple declarations for ".append(simpleQuote(name)).append(" with different modifiers"));
  if (!previous.isEmpty()) log.note(previous, "Conflicting declaration is here");
}

void semanticErrorBadUsingValue(Log log, Range range) {
  log.error(range, "Expected a type here");
}

void semanticErrorBadUsingNamespace(Log log, Range range) {
  log.error(range, "Expected a namespace here");
}

void semanticErrorUnexpectedStatement(Log log, Range range) {
  log.error(range, "Cannot use this statement here");
}

void semanticErrorCyclicDeclaration(Log log, Range range, string name) {
  log.error(range, "Cyclic declaration of ".append(simpleQuote(name)));
}

void semanticErrorUnexpectedThis(Log log, Range range) {
  log.error(range, "Cannot use \"this\" outside a class or struct");
}

void semanticErrorStaticThis(Log log, Range range) {
  log.error(range, "Cannot access \"this\" from a static context");
}

void semanticErrorIncompatibleTypes(Log log, Range range, Type from, Type to, bool isCastAllowed) {
  log.error(range, "Cannot convert from ".append(typeToText(from)).append(" to ").append(typeToText(to)).append(isCastAllowed ? " without a cast" : ""));
}

void semanticErrorNoCommonType(Log log, Range range, Type left, Type right) {
  log.error(range, "No common type for ".append(typeToText(left)).append(" and ").append(typeToText(right)));
}

void semanticErrorBadType(Log log, Range range, Type type) {
  log.error(range, "Cannot use ".append(typeToText(type)).append(" here"));
}

void semanticErrorMemberUnexpectedStatic(Log log, Range range, string name) {
  log.error(range, "Cannot access static member ".append(simpleQuote(name)).append(" from an instance context"));
}

void semanticErrorMemberUnexpectedInstance(Log log, Range range, string name) {
  log.error(range, "Cannot access instance member ".append(simpleQuote(name)).append(" from a static context"));
}

void semanticErrorMissingTypeContext(Log log, Range range) {
  log.error(range, "Expression has no type context here");
}

void semanticErrorBadTypeParameterBound(Log log, Range range, Type type) {
  log.error(range, "Cannot use ".append(typeToText(type)).append(" as a type parameter bound"));
}

void semanticErrorVarMissingValue(Log log, Range range) {
  log.error(range, "Implicitly typed variables must be initialized");
}

void semanticErrorVarBadType(Log log, Range range, Type type) {
  log.error(range, "Implicitly typed variables cannot be of ".append(typeToText(type)));
}

void semanticErrorInvalidCall(Log log, Range range, Type type) {
  log.error(range, "Cannot call ".append(typeToText(type)));
}

void semanticErrorArgumentCount(Log log, Range range, int expected, int found) {
  log.error(range, "Expected ".append(expected.toString()).append(plural(expected, " argument", " arguments")).append(
    " but found ").append(found.toString()).append(plural(found, " argument", " arguments")));
}

void semanticErrorExpectedReturnValue(Log log, Range range, Type type) {
  log.error(range, "Return statement must return ".append(typeToText(type)));
}

void semanticErrorBadLambdaTypeContext(Log log, Range range, Type type) {
  log.error(range, "Cannot use a lambda expression with ".append(typeToText(type)));
}

void semanticErrorBadDefaultCase(Log log, Range range) {
  log.error(range, "Only the last case can be a default case");
}

void semanticErrorDuplicateCase(Log log, Range range, Range previous) {
  log.error(range, "Duplicate case value here");
  if (!previous.isEmpty()) log.note(previous, "First occurrence is here");
}

void semanticErrorUnconstructableType(Log log, Range range, Type type) {
  log.error(range, "Cannot construct ".append(typeToText(type)));
}

void semanticErrorUnexpectedBaseType(Log log, Range range, string what) {
  log.error(range, what.append(" cannot inherit from another type"));
}

void semanticErrorClassBaseNotFirst(Log log, Range range, Type type) {
  log.error(range, "Base ".append(typeToText(type)).append(" must come first in a class declaration"));
}

void semanticErrorBaseTypeNotInterface(Log log, Range range, Type type) {
  log.error(range, "Base ".append(typeToText(type)).append(" must be an interface"));
}

void semanticErrorDuplicateBaseType(Log log, Range range, Type type) {
  log.error(range, "Duplicate base ".append(typeToText(type)));
}

void semanticErrorAmbiguousSymbol(Log log, Range range, string name, List<string> names) {
  int i;
  for (i = 0; i < names.length; i++) names.set(i, simpleQuote(names.get(i)));
  log.error(range, "Reference to ".append(simpleQuote(name)).append(" is ambiguous, could be ").append(" or ".join(names)));
}

void semanticErrorUnmergedSymbol(Log log, Range range, string name, List<Type> types) {
  List<string> names = {};
  int i;
  for (i = 0; i < types.length; i++) names.push(typeToText(types.get(i)));
  log.error(range, "Member ".append(simpleQuote(name)).append(" has an ambiguous type, could be ").append(" or ".join(names)));
}
