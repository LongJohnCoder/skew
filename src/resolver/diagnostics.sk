string typeToText(Type type) {
  return "type \"".append(type.toString()).append("\"");
}

////////////////////////////////////////////////////////////////////////////////

void semanticWarningDuplicateModifier(Log log, Range range, string modifier) {
  log.warning(range, "Duplicate modifier ".append(simpleQuote(modifier)));
}

void semanticWarningRedundantModifier(Log log, Range range, string modifier) {
  log.warning(range, "Redundant modifier ".append(simpleQuote(modifier)));
}

void semanticWarningShadowedSymbol(Log log, Range range, string name, Range shadowed) {
  log.warning(range, simpleQuote(name).append(" shadows another symbol with the same name"));
  if (!shadowed.isEmpty()) log.note(shadowed, "The shadowed declaration is here");
}

void semanticErrorDuplicateSymbol(Log log, Range range, string name, Range previous) {
  log.error(range, simpleQuote(name).append(" is already declared"));
  if (!previous.isEmpty()) log.note(previous, "Previous declaration is here");
}

void semanticErrorUnexpectedNode(Log log, Range range, NodeKind kind) {
  log.error(range, "Unexpected ".append(kind.toString()));
}

void semanticErrorUnexpectedExpression(Log log, Range range, Type type) {
  log.error(range, "Unexpected expression of ".append(typeToText(type)));
}

void semanticErrorUnexpectedType(Log log, Range range, Type type) {
  log.error(range, "Unexpected ".append(typeToText(type)));
}

void semanticErrorUndeclaredSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name).append(" is not declared"));
}

void semanticErrorUndeclaredGlobalSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name).append(" is not declared at the global scope"));
}

void semanticErrorUnknownMemberSymbol(Log log, Range range, string name, Type type) {
  log.error(range, simpleQuote(name).append(" is not declared on ").append(typeToText(type)));
}

void semanticErrorExtensionMissingTarget(Log log, Range range, string name) {
  log.error(range, "No type named ".append(simpleQuote(name)).append(" to extend"));
}

void semanticErrorDifferentModifiers(Log log, Range range, string name, Range previous) {
  log.error(range, "Cannot merge multiple declarations for ".append(simpleQuote(name)).append(" with different modifiers"));
  if (!previous.isEmpty()) log.note(previous, "Conflicting declaration is here");
}

void semanticErrorBadUsingValue(Log log, Range range) {
  log.error(range, "Expected a type here");
}

void semanticErrorBadUsingNamespace(Log log, Range range) {
  log.error(range, "Expected a namespace here");
}

void semanticErrorUnexpectedStatement(Log log, Range range, string kind) {
  log.error(range, "Cannot use a statement of type ".append(kind).append(" here"));
}

void semanticErrorCyclicDeclaration(Log log, Range range, string name) {
  log.error(range, "Circular declaration of ".append(simpleQuote(name)));
}

void semanticErrorStaticThis(Log log, Range range) {
  log.error(range, "Cannot access \"this\" from a static context");
}

void semanticErrorIncompatibleTypes(Log log, Range range, Type from, Type to, bool isCastAllowed) {
  log.error(range, "Cannot convert from ".append(typeToText(from)).append(" to ").append(typeToText(to)).append(isCastAllowed ? " without a cast" : ""));
}

void semanticErrorNoCommonType(Log log, Range range, Type left, Type right) {
  log.error(range, "No common type for ".append(typeToText(left)).append(" and ").append(typeToText(right)));
}

void semanticErrorBadVariableType(Log log, Range range, Type type) {
  log.error(range, "Cannot use ".append(typeToText(type)).append(" here"));
}
