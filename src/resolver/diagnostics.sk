string typeToText(Type type) {
  return "type \"".append(type.toString()).append("\"");
}

////////////////////////////////////////////////////////////////////////////////

void semanticWarningUnusedExpression(Log log, Range range) {
  log.warning(range, "Unused expression");
}

void semanticWarningDuplicateModifier(Log log, Range range, string modifier) {
  log.warning(range, "Duplicate modifier ".append(simpleQuote(modifier)));
}

void semanticWarningShadowedSymbol(Log log, Range range, string name, Range shadowed) {
  log.warning(range, simpleQuote(name).append(" shadows another declaration with the same name"));
  if (!shadowed.isEmpty()) log.note(shadowed, "The shadowed declaration is here");
}

void semanticErrorRedundantModifier(Log log, Range range, string modifier, string where) {
  log.error(range, "Redundant modifier ".append(simpleQuote(modifier)).append(" ").append(where));
}

void semanticErrorUnexpectedModifier(Log log, Range range, string modifier, string where) {
  log.error(range, "Cannot use the ".append(simpleQuote(modifier)).append(" modifier ").append(where));
}

void semanticErrorExpectedModifier(Log log, Range range, string modifier, string where) {
  log.error(range, "Expected the ".append(simpleQuote(modifier)).append(" modifier ").append(where));
}


void semanticErrorDuplicateSymbol(Log log, Range range, string name, Range previous) {
  log.error(range, simpleQuote(name).append(" is already declared"));
  if (!previous.isEmpty()) log.note(previous, "The previous declaration is here");
}

void semanticErrorUnexpectedNode(Log log, Range range, NodeKind kind) {
  log.error(range, "Unexpected ".append(kind.toString()));
}

void semanticErrorUnexpectedExpression(Log log, Range range, Type type) {
  log.error(range, "Unexpected expression of ".append(typeToText(type)));
}

void semanticErrorUnexpectedType(Log log, Range range, Type type) {
  log.error(range, "Unexpected ".append(typeToText(type)));
}

void semanticErrorUndeclaredSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name).append(" is not declared"));
}

void semanticErrorUndeclaredGlobalSymbol(Log log, Range range, string name) {
  log.error(range, simpleQuote(name).append(" is not declared at the global scope"));
}

void semanticErrorUnknownMemberSymbol(Log log, Range range, string name, Type type) {
  log.error(range, simpleQuote(name).append(" is not declared on ").append(typeToText(type)));
}

void semanticErrorExtensionMissingTarget(Log log, Range range, string name) {
  log.error(range, "No type named ".append(simpleQuote(name)).append(" to extend"));
}

void semanticErrorDifferentModifiers(Log log, Range range, string name, Range previous) {
  log.error(range, "Cannot merge multiple declarations for ".append(simpleQuote(name)).append(" with different modifiers"));
  if (!previous.isEmpty()) log.note(previous, "The conflicting declaration is here");
}

void semanticErrorBadUsingValue(Log log, Range range) {
  log.error(range, "Expected a type here");
}

void semanticErrorBadUsingNamespace(Log log, Range range) {
  log.error(range, "Expected a namespace here");
}

void semanticErrorUnexpectedStatement(Log log, Range range) {
  log.error(range, "Cannot use this statement here");
}

void semanticErrorCyclicDeclaration(Log log, Range range, string name) {
  log.error(range, "Cyclic declaration of ".append(simpleQuote(name)));
}

void semanticErrorUnexpectedThis(Log log, Range range, string name) {
  log.error(range, "Cannot use ".append(simpleQuote(name)).append(" outside a class or struct"));
}

void semanticErrorStaticThis(Log log, Range range, string name) {
  log.error(range, "Cannot access ".append(simpleQuote(name)).append(" from a static context"));
}

void semanticErrorIncompatibleTypes(Log log, Range range, Type from, Type to, bool isCastAllowed) {
  log.error(range, "Cannot convert from ".append(typeToText(from)).append(" to ").append(typeToText(to)).append(isCastAllowed ? " without a cast" : ""));
}

void semanticErrorNoCommonType(Log log, Range range, Type left, Type right) {
  log.error(range, "No common type for ".append(typeToText(left)).append(" and ").append(typeToText(right)));
}

void semanticErrorBadType(Log log, Range range, Type type) {
  log.error(range, "Cannot use ".append(typeToText(type)).append(" here"));
}

void semanticErrorMemberUnexpectedStatic(Log log, Range range, string name) {
  log.error(range, "Cannot access static member ".append(simpleQuote(name)).append(" from an instance context"));
}

void semanticErrorMemberUnexpectedInstance(Log log, Range range, string name) {
  log.error(range, "Cannot access instance member ".append(simpleQuote(name)).append(" from a static context"));
}

void semanticErrorMissingTypeContext(Log log, Range range) {
  log.error(range, "Expression has no type context here");
}

void semanticErrorBadTypeParameterBound(Log log, Range range, Type type) {
  log.error(range, "Cannot use ".append(typeToText(type)).append(" as a type parameter bound"));
}

void semanticErrorUninitializedExtensionVariable(Log log, Range range) {
  log.error(range, "Instance variables in extension blocks must be initialized");
}

void semanticErrorVarMissingValue(Log log, Range range) {
  log.error(range, "Implicitly typed variables must be initialized");
}

void semanticErrorVarBadType(Log log, Range range, Type type) {
  log.error(range, "Implicitly typed variables cannot be of ".append(typeToText(type)));
}

void semanticErrorInvalidCall(Log log, Range range, Type type) {
  log.error(range, "Cannot call ".append(typeToText(type)));
}

void semanticErrorParameterCount(Log log, Range range, int expected, int found) {
  log.error(range, "Expected ".append(expected.toString()).append(plural(expected, " type parameter", " type parameters")).append(
    " but found ").append(found.toString()).append(plural(found, " type parameter", " type parameters")));
}

void semanticErrorArgumentCount(Log log, Range range, int expected, int found) {
  log.error(range, "Expected ".append(expected.toString()).append(plural(expected, " argument", " arguments")).append(
    " but found ").append(found.toString()).append(plural(found, " argument", " arguments")));
}

void semanticErrorExpectedReturnValue(Log log, Range range, Type type) {
  log.error(range, "Return statement must return ".append(typeToText(type)));
}

void semanticErrorBadLambdaTypeContext(Log log, Range range, Type type) {
  log.error(range, "Cannot use a lambda expression with ".append(typeToText(type)));
}

void semanticErrorNonConstantCaseValue(Log log, Range range) {
  log.error(range, "Non-constant case value");
}

void semanticErrorBadDefaultCase(Log log, Range range) {
  log.error(range, "Only the last case can be a default case");
}

void semanticErrorDuplicateCase(Log log, Range range, Range previous) {
  log.error(range, "Duplicate case value");
  if (!previous.isEmpty()) log.note(previous, "The first occurrence is here");
}

void semanticErrorUnconstructableType(Log log, Range range, Type type) {
  log.error(range, "Cannot construct ".append(typeToText(type)));
}

void semanticErrorUnexpectedBaseType(Log log, Range range, string what) {
  log.error(range, what.append(" cannot inherit from another type"));
}

void semanticErrorClassBaseNotFirst(Log log, Range range, Type type) {
  log.error(range, "Base ".append(typeToText(type)).append(" must come first in a class declaration"));
}

void semanticErrorBaseTypeNotInterface(Log log, Range range, Type type) {
  log.error(range, "Base ".append(typeToText(type)).append(" must be an interface"));
}

void semanticErrorDuplicateBaseType(Log log, Range range, Type type) {
  log.error(range, "Duplicate base ".append(typeToText(type)));
}

void semanticErrorAmbiguousSymbol(Log log, Range range, string name, List<string> names) {
  int i;
  for (i = 0; i < names.length; i++) names.set(i, simpleQuote(names.get(i)));
  log.error(range, "Reference to ".append(simpleQuote(name)).append(" is ambiguous, could be ").append(" or ".join(names)));
}

void semanticErrorUnmergedSymbol(Log log, Range range, string name, List<Type> types) {
  List<string> names = {};
  int i;
  for (i = 0; i < types.length; i++) names.push(typeToText(types.get(i)));
  log.error(range, "Member ".append(simpleQuote(name)).append(" has an ambiguous inherited type, could be ").append(" or ".join(names)));
}

void semanticErrorBadOverride(Log log, Range range, string name, Type base, Range overridden) {
  log.error(range, simpleQuote(name).append(" overrides another declaration with the same name in base ").append(typeToText(base)));
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorOverrideDifferentTypes(Log log, Range range, string name, Type base, Type derived, Range overridden) {
  log.error(range, simpleQuote(name).append(" must have the same signature as the method it overrides (").append(
    "expected ").append(typeToText(base)).append(" but found ").append(typeToText(derived)).append(")"));
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorModifierMissingOverride(Log log, Range range, string name, Range overridden) {
  log.error(range, simpleQuote(name).append(" overrides another symbol with the same name but is missing the \"override\" modifier"));
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorCannotOverrideNonVirtual(Log log, Range range, string name, Range overridden) {
  log.error(range, simpleQuote(name).append(" cannot override a non-virtual method"));
  if (!overridden.isEmpty()) log.note(overridden, "The overridden declaration is here");
}

void semanticErrorBadIntegerConstant(Log log, Range range, Type type) {
  log.error(range, "Expected integer constant but found expression of ".append(typeToText(type)));
}

void semanticErrorNoUnaryOperator(Log log, Range range, NodeKind kind, Type type) {
  assert kind.isUnaryOperator();
  log.error(range, "No unary operator ".append(operatorInfo.get(kind).text).append(" for ").append(typeToText(type)));
}

void semanticErrorNoBinaryOperator(Log log, Range range, NodeKind kind, Type left, Type right) {
  assert kind.isBinaryOperator();
  log.error(range, "No binary operator ".append(operatorInfo.get(kind).text).append(" for ").append(typeToText(left)).append(" and ").append(typeToText(right)));
}

void semanticErrorBadStorage(Log log, Range range) {
  log.error(range, "Cannot store to this location");
}

void semanticErrorStorageToFinal(Log log, Range range) {
  log.error(range, "Cannot store to a symbol marked as \"final\"");
}

void semanticErrorUnparameterizedType(Log log, Range range, Type type) {
  log.error(range, "Cannot use unparameterized ".append(typeToText(type)));
}

void semanticErrorCannotParameterize(Log log, Range range, Type type) {
  log.error(range, "Cannot parameterize ".append(typeToText(type)).append(
    type.hasParameters() ? " because it is already parameterized" : " because it has no type parameters"));
}

void semanticErrorBadSuperInitializer(Log log, Range range) {
  log.error(range, "No base constructor to call");
}
