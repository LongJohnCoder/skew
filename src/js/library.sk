namespace js {
  const var NATIVE_LIBRARY = "
import class int { string toString(); }
import class bool { string toString(); }
import class float { string toString(); }
import class double { string toString(); }

import namespace operators {
  void delete(int value);
  void sort<T>(List<T> list, Comparison<T> comparison);
}

import class string {
  string slice(int start, int end);
  int indexOf(string value);
  int lastIndexOf(string value);
  string toLowerCase();
  string toUpperCase();
}

in string {
  inline {
    int size() { return untyped(this.length); }
    static string fromCodeUnit(int value) { return untyped(String.fromCharCode(typed(value))); }
    string get(int index) { return untyped(this[typed(index)]); }
    string join(List<string> values) { return untyped(typed(values).join(this)); }
    int codeUnitAt(int index) { return untyped(this.charCodeAt(typed(index))); }
  }

  bool startsWith(string prefix) { return size() >= prefix.size() && slice(0, prefix.size()) == prefix; }
  bool endsWith(string suffix) { return size() >= suffix.size() && slice(size() - suffix.size(), size()) == suffix; }
  string repeat(int count) { var result = \"\"; for (var i = 0; i < count; i++) result += this; return result; }
}

export interface Comparison<T> {
  virtual int compare(T left, T right);
}

import class List<T> {
  new();
  void push(T value);
  void unshift(T value);
  List<T> slice(int start, int end);
  int indexOf(T value);
  int lastIndexOf(T value);
  T shift();
  T pop();
  void reverse();
}

in List {
  inline {
    int size() { return untyped(this.length); }
    void sort(Comparison<T> comparison) { operators.sort<T>(this, comparison); }
    List<T> clone() { return untyped(this.slice()); }
    T remove(int index) { return untyped(this.splice(typed(index), 1)[0]); }
    void insert(int index, T value) { untyped(this.splice(typed(index), 0, typed(value))); }
    T get(int index) { return untyped(this[typed(index)]); }
    void set(int index, T value) { untyped(this[typed(index)] = typed(value)); }
  }
  void swap(int a, int b) { var temp = get(a); set(a, get(b)); set(b, temp); }
}

class StringMap<T> {
  var table = untyped(Object.create(null));
}

in StringMap {
  inline {
    T get(string key) { return untyped(typed(table)[typed(key)]); }
    void set(string key, T value) { untyped(typed(table)[typed(key)] = typed(value)); }
    bool has(string key) { return untyped(typed(key) in typed(table)); }
    void remove(string key) { operators.delete(untyped(typed(table)[typed(key)])); }
  }

  T getOrDefault(string key, T defaultValue) {
    return has(key) ? get(key) : defaultValue;
  }

  List<string> keys() {
    List<string> keys = [];
    for (string key in untyped(typed(table))) keys.push(key);
    return keys;
  }

  List<T> values() {
    List<T> values = [];
    for (string key in untyped(typed(table))) values.push(get(key));
    return values;
  }

  StringMap<T> clone() {
    var clone = StringMap<T>();
    for (string key in untyped(typed(table))) clone.set(key, get(key));
    return clone;
  }
}

class IntMap<T> {
  var table = untyped(Object.create(null));
}

in IntMap {
  inline {
    T get(int key) { return untyped(typed(table)[typed(key)]); }
    void set(int key, T value) { untyped(typed(table)[typed(key)] = typed(value)); }
    bool has(int key) { return untyped(typed(key) in typed(table)); }
    void remove(int key) { operators.delete(untyped(typed(table)[typed(key)])); }
  }

  T getOrDefault(int key, T defaultValue) {
    return has(key) ? get(key) : defaultValue;
  }

  List<int> keys() {
    List<int> keys = [];
    for (double key in untyped(typed(table))) keys.push((int)key);
    return keys;
  }

  List<T> values() {
    List<T> values = [];
    for (int key in untyped(typed(table))) values.push(get(key));
    return values;
  }

  IntMap<T> clone() {
    var clone = IntMap<T>();
    for (int key in untyped(typed(table))) clone.set(key, get(key));
    return clone;
  }
}

import namespace math {}

in math {
  inline double abs(double x) { return untyped(Math.abs(typed(x))); }
  inline double sin(double x) { return untyped(Math.sin(typed(x))); }
  inline double cos(double x) { return untyped(Math.cos(typed(x))); }
  inline double tan(double x) { return untyped(Math.tan(typed(x))); }
  inline double asin(double x) { return untyped(Math.asin(typed(x))); }
  inline double acos(double x) { return untyped(Math.acos(typed(x))); }
  inline double atan(double x) { return untyped(Math.atan(typed(x))); }
  inline double atan2(double y, double x) { return untyped(Math.atan2(typed(y), typed(x))); }
  inline double sqrt(double x) { return untyped(Math.sqrt(typed(x))); }
  inline double exp(double x) { return untyped(Math.exp(typed(x))); }
  inline double log(double x) { return untyped(Math.log(typed(x))); }
  inline double pow(double x, double y) { return untyped(Math.pow(typed(x), typed(y))); }
  inline double floor(double x) { return untyped(Math.floor(typed(x))); }
  inline double round(double x) { return untyped(Math.round(typed(x))); }
  inline double ceil(double x) { return untyped(Math.ceil(typed(x))); }
  inline double min(double x, double y) { return untyped(Math.min(typed(x), typed(y))); }
  inline double max(double x, double y) { return untyped(Math.max(typed(x), typed(y))); }

  const double SQRT2 = 1.414213562373095;
  const double PI = 3.141592653589793;
  const double E = 2.718281828459045;
  const double INFINITY = 1 / 0.0;
  const double NAN = 0 / 0.0;
}
";
}
