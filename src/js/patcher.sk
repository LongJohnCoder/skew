namespace js {
  enum BooleanSwap {
    SWAP,
    NO_SWAP,
  }

  class Patcher {
    var lambdaCount = 0;
    var createdThisAlias = false;
    Symbol currentFunction = null;
    var needExtends = false;
    var needMathImul = false;
    var namingGroupIndexForSymbol = IntMap<int>();
    var nextSymbolName = 0;
    StringMap<bool> reservedNames = null;
    CompilerOptions options = null;
    UnionFind localVariableUnionFind = null;
    TypeCache cache = null;
    Resolver resolver;

    void run(Node program) {
      assert program.kind == .PROGRAM;
      options = resolver.options;
      cache = resolver.cache;

      // A union-find data structure is used to quickly merge symbols into
      // groups. All local variables inside a function are merged with that
      // function. Also create a quick way of getting from a symbol to its
      // union/find index.
      if (options.jsMangle) {
        localVariableUnionFind = UnionFind(resolver.allSymbols.length);
        for (var i = 0; i < resolver.allSymbols.length; i++) {
          var symbol = resolver.allSymbols.get(i);
          namingGroupIndexForSymbol.set(symbol.uniqueID, i);
        }
      }

      // Traverse the tree of nodes, fixing up everything for emission in one
      // pass. Local variables will be grouped during the traversal of the node
      // tree for speed. It should be faster because we can access the top-
      // level function symbol instantly and avoid needing to traverse up to
      // the function from every local variable symbol, which we would have to
      // do if we just looped over symbols.
      patchNode(program);

      // Rename all internal symbols
      if (options.jsMangle) {
        // This holds the groups used for naming. Unioning two labels using
        // this object will cause both groups of symbols to have the same name.
        var namingGroupsUnionFind = UnionFind(resolver.allSymbols.length);

        // Merge local variables from different functions together in the order
        // they were declared. This will cause every argument list to use the
        // same variables in the same order, which should offer better gzip:
        //
        //   function d(a, b) {}
        //   function e(a, b, c) {}
        //
        List<int> order = [];
        var localVariableGroups = extractGroups(localVariableUnionFind, symbol => symbol.kind == .LOCAL_VARIABLE);
        zipTogetherInOrder(namingGroupsUnionFind, localVariableGroups, order);

        // Ensure all overridden symbols have the same generated name
        for (var i = 0; i < resolver.allSymbols.length; i++) {
          var symbol = resolver.allSymbols.get(i);
          if (symbol.overriddenMember != null) {
            var overridden = symbol.overriddenMember.symbol;
            var index = namingGroupIndexForSymbol.get(symbol.uniqueID);
            namingGroupsUnionFind.union(index, namingGroupIndexForSymbol.get(overridden.uniqueID));
            if (overridden.identicalMembers != null) {
              for (var j = 0; j < overridden.identicalMembers.length; j++) {
                namingGroupsUnionFind.union(index, namingGroupIndexForSymbol.get(overridden.identicalMembers.get(j).symbol.uniqueID));
              }
            }
          }
        }

        // Collect all reserved names together into one big set for querying
        reservedNames = Emitter.isKeyword.clone();
        var members = cache.globalType.members.values();
        for (var i = 0; i < members.length; i++) {
          var member = members.get(i);
          if (!canRename(member.symbol)) {
            reservedNames.set(member.symbol.name, true);
          }
        }

        // TODO: Remove this once the minified output is wrapped in a closure.
        // This is needed because otherwise "var fs = require('fs');" writes
        // over a generated variable used by the compiler.
        reservedNames.set("fs", true);

        // Everything that should have the same name is now grouped together
        var namingGroups = extractGroups(namingGroupsUnionFind, null);
        for (var i = 0; i < namingGroups.length; i++) {
          var group = namingGroups.get(i);
          var name = "";
          for (var j = 0; j < group.length; j++) {
            var symbol = group.get(j);
            if (canRename(symbol)) {
              if (name == "") name = generateSymbolName();
              symbol.name = name;
            }
          }
        }
      }
    }

    void zipTogetherInOrder(UnionFind unionFind, List<List<Symbol>> groups, List<int> order) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups.get(i);
        if (group.length > 1) {
          group.sort((a, b) => a.node.range.start - b.node.range.start);
        }
        for (var j = 0; j < group.length; j++) {
          var symbol = group.get(j);
          var index = namingGroupIndexForSymbol.get(symbol.uniqueID);
          if (order.length <= j) {
            order.push(index);
          }
          unionFind.union(index, order.get(j));
        }
      }
    }

    List<List<Symbol>> extractGroups(UnionFind unionFind, bool fn(Symbol) filter) {
      var labelToGroup = IntMap<List<Symbol>>();
      for (var i = 0; i < resolver.allSymbols.length; i++) {
        var symbol = resolver.allSymbols.get(i);
        if (filter != null && !filter(symbol)) {
          continue;
        }
        var label = unionFind.find(namingGroupIndexForSymbol.get(symbol.uniqueID));
        var group = labelToGroup.getOrDefault(label, null);
        if (group == null) {
          group = [];
          labelToGroup.set(label, group);
        }
        group.push(symbol);
      }
      return labelToGroup.values();
    }

    bool canRename(Symbol symbol) {
      return !symbol.isImportOrExport();
    }

    void patchNode(Node node) {
      switch (node.kind) {
        case .LAMBDA { lambdaCount++; }
        case .CONSTRUCTOR { patchConstructor(node); setCurrentFunction(node.symbol); }
        case .FUNCTION { setCurrentFunction(node.symbol); }
        case .CAST { patchCast(node); }
        case .CLASS { patchClass(node); }
        case .THIS { patchThis(node); }
        case .NAME { patchName(node); }
        case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER { patchBinary(node); }
        case .PREFIX_INCREMENT, .PREFIX_DECREMENT, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT { patchUnary(node); }
        case .ASSIGN_ADD, .ASSIGN_SUBTRACT, .ASSIGN_MULTIPLY, .ASSIGN_DIVIDE, .ASSIGN_REMAINDER { patchAssign(node); }
      }

      // This is not inside the switch statement above because one of the other
      // case clauses may have introduced a let statement
      if (node.kind == .LET) {
        patchLet(node);
      }

      if (node.hasChildren()) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children.get(i);
          if (child != null) {
            patchNode(child);
          }
        }
      }

      switch (node.kind) {
        case .LAMBDA { lambdaCount--; }
        case .CONSTRUCTOR, .FUNCTION { setCurrentFunction(null); }
        case .VARIABLE { if (options.jsMangle) unionVariableWithFunction(node); }
      }

      if (options.jsMangle) {
        switch (node.kind) {
          case .IF { peepholeMangleIf(node); }
          case .FOR { peepholeMangleBoolean(node.forTest(), .NO_SWAP); }
          case .GREATER_THAN_OR_EQUAL, .LESS_THAN_OR_EQUAL { peepholeMangleBinaryRelational(node); }
          case .WHILE, .DO_WHILE { peepholeMangleBoolean(node.whileTest(), .NO_SWAP); }
          case .BLOCK { peepholeMangleBlock(node); }
          case .HOOK { peepholeMangleHook(node); }
        }
      }
    }

    void peepholeMangleBinaryRelational(Node node) {
      assert node.kind == .GREATER_THAN_OR_EQUAL || node.kind == .LESS_THAN_OR_EQUAL;
      var left = node.binaryLeft();
      var right = node.binaryRight();
      if (left.type != null && left.type.isInteger(cache) && right.type != null && right.type.isInteger(cache)) {
        if (left.kind == .INT) {
          var value = left.asInt();

          // "2 >= a" => "3 > a"
          if (node.kind == .GREATER_THAN_OR_EQUAL && value.canIncrement()) {
            left.content = IntContent(value + 1);
            node.kind = .GREATER_THAN;
          }

          // "2 <= a" => "1 < a"
          else if (node.kind == .LESS_THAN_OR_EQUAL && value.canDecrement()) {
            left.content = IntContent(value - 1);
            node.kind = .LESS_THAN;
          }
        } else if (right.kind == .INT) {
          var value = right.asInt();

          // "a >= 2" => "a > 1"
          if (node.kind == .GREATER_THAN_OR_EQUAL && value.canDecrement()) {
            right.content = IntContent(value - 1);
            node.kind = .GREATER_THAN;
          }

          // "a <= 2" => "a < 3"
          else if (node.kind == .LESS_THAN_OR_EQUAL && value.canIncrement()) {
            right.content = IntContent(value + 1);
            node.kind = .LESS_THAN;
          }
        }
      }
    }

    bool isFalsy(Node node) {
      var kind = node.kind;
      if (kind == .NULL) return true;
      else if (kind == .INT) return node.asInt() == 0;
      else if (kind.isReal()) return node.asDouble() == 0;
      else if (kind == .STRING) return node.asString() == "";
      else if (kind.isCast()) return isFalsy(node.castValue());
      else return false;
    }

    BooleanSwap peepholeMangleBoolean(Node node, BooleanSwap canSwap) {
      var kind = node.kind;

      // "if (!a) b; else c;" => "if (a) c; else b;"
      if (kind == .NOT && canSwap == .SWAP) {
        node.become(node.unaryValue().replaceWith(null));
        return .SWAP;
      }

      if (kind == .EQUAL || kind == .NOT_EQUAL) {
        var left = node.binaryLeft();
        var right = node.binaryRight();
        var replacement = isFalsy(right) ? left : isFalsy(left) ? right : null;

        // "if (a != 0) b;" => "if (a) b;"
        if (replacement != null) {

          // This minification is not valid for floating-point values because
          // of NaN, since NaN != 0 but NaN is falsy in JavaScript
          if (left.type != null && !left.type.isReal(cache) && right.type != null && !right.type.isReal(cache)) {
            replacement.replaceWith(null);
            node.become(kind == .EQUAL ? Node.createUnary(.NOT, replacement) : replacement);
          }
        }

        else if (left.type != null && left.type.isInteger(cache) && right.type != null && right.type.isInteger(cache)) {

          // "if (a != b) c;" => "if (a ^ b) c;"
          if (kind == .NOT_EQUAL) {
            node.kind = .BITWISE_XOR;
          }

          // "if (a == b) c; else d;" => "if (a ^ b) d; else c;"
          else if (kind == .EQUAL && canSwap == .SWAP) {
            node.kind = .BITWISE_XOR;
            return .SWAP;
          }
        }
      }

      // "if (a != 0 || b != 0) c;" => "if (a || b) c;"
      else if (kind == .LOGICAL_AND || kind == .LOGICAL_OR) {
        peepholeMangleBoolean(node.binaryLeft(), .NO_SWAP);
        peepholeMangleBoolean(node.binaryRight(), .NO_SWAP);
      }

      return .NO_SWAP;
    }

    void peepholeMangleIf(Node node) {
      var test = node.ifTest();
      var trueBlock = node.ifTrue();
      var falseBlock = node.ifFalse();
      var swapped = peepholeMangleBoolean(test, falseBlock != null ? .SWAP : .NO_SWAP);

      // "if (!a) b; else c;" => "if (a) c; else b;"
      if (swapped == .SWAP) {
        var temp = trueBlock;
        trueBlock = falseBlock;
        falseBlock = temp;
        trueBlock.swapWith(falseBlock);
      }

      var trueStatement = trueBlock.singleStatement();
      if (falseBlock != null) {
        var falseStatement = falseBlock.singleStatement();
        if (trueStatement != null && falseStatement != null) {

          // "if (a) b; else c;" => "a ? b : c;"
          if (trueStatement.kind == .EXPRESSION && falseStatement.kind == .EXPRESSION) {
            var hook = Node.createHook(test.replaceWith(null), trueStatement.expressionValue().replaceWith(null), falseStatement.expressionValue().replaceWith(null));
            peepholeMangleHook(hook);
            node.replaceWith(Node.createExpression(hook));
          }

          // "if (a) return b; else return c;" => "return a ? b : c;"
          else if (trueStatement.kind == .RETURN && falseStatement.kind == .RETURN) {
            var trueValue = trueStatement.returnValue();
            var falseValue = falseStatement.returnValue();
            if (trueValue != null && falseValue != null) {
              var hook = Node.createHook(test.replaceWith(null), trueValue.replaceWith(null), falseValue.replaceWith(null));
              peepholeMangleHook(hook);
              node.replaceWith(Node.createReturn(hook));
            }
          }
        }
      }

      // "if (a) b;" => "a && b;"
      else if (trueStatement != null && trueStatement.kind == .EXPRESSION) {
        node.replaceWith(Node.createExpression(Node.createBinary(.LOGICAL_AND, test.replaceWith(null), trueStatement.expressionValue().replaceWith(null))));
      }
    }

    void peepholeMangleBlock(Node node) {
      if (!node.hasChildren()) {
        return;
      }

      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        var kind = child.kind;

        // "var a = 0; var b = 1;" => "var a = 0, b = 1;"
        if (kind == .VARIABLE_CLUSTER) {
          while (i + 1 < node.children.length) {
            var next = node.children.get(i + 1);
            if (next.kind != .VARIABLE_CLUSTER) {
              break;
            }
            var variables = next.remove().clusterVariables();
            for (var j = 0; j < variables.length; j++) {
              child.appendChild(variables.get(j).replaceWith(null));
            }
          }
        }

        // "a; b; c;" => "a, b, c;"
        else if (kind == .EXPRESSION) {
          List<Node> nodes;
          while (i + 1 < node.children.length) {
            var next = node.children.get(i + 1);
            if (next.kind != .EXPRESSION) {
              break;
            }
            if (nodes == null) {
              nodes = []; // Save on allocations
            }
            nodes.push(next.remove().expressionValue().remove());
          }
          if (nodes != null) {
            nodes.unshift(child.expressionValue().remove());
            child.replaceWith(Node.createExpression(Node.createSequence(nodes)));
          }
        }

        else if (kind == .RETURN && child.returnValue() != null) {
          while (i > 0) {
            var previous = node.children.get(i - 1);

            // "if (a) return b; if (c) return d; return e;" => "return a ? b : c ? d : e;"
            if (previous.kind == .IF && previous.ifFalse() == null) {
              var statement = previous.ifTrue().singleStatement();
              if (statement != null && statement.kind == .RETURN && statement.returnValue() != null) {
                var hook = Node.createHook(previous.ifTest().replaceWith(null), statement.returnValue().replaceWith(null), child.returnValue().replaceWith(null));
                peepholeMangleHook(hook);
                child.remove();
                child = Node.createReturn(hook);
                previous.replaceWith(child);
              } else {
                break;
              }
            }

            // "a(); return b;" => "return a(), b;"
            else if (previous.kind == .EXPRESSION) {
              var values = previous.remove().expressionValue().replaceWith(null);
              var value = child.returnValue().replaceWith(null);
              if (values.kind == .SEQUENCE) {
                values.appendChild(value);
              } else {
                values = Node.createSequence([values, value]);
              }
              var combined = Node.createReturn(values);
              child.replaceWith(combined);
              child = combined;
            }

            else {
              break;
            }

            i--;
          }
        }
      }
    }

    bool looksTheSame(Node left, Node right) {
      if (left.kind == right.kind) {
        switch (left.kind) {
          case .NULL, .THIS { return true; }
          case .INT { return left.asInt() == right.asInt(); }
          case .BOOL { return left.asBool() == right.asBool(); }
          case .FLOAT, .DOUBLE { return left.asDouble() == right.asDouble(); }
          case .STRING { return left.asString() == right.asString(); }
          case .NAME { return left.symbol != null && left.symbol == right.symbol || left.asString() == right.asString(); }
          case .DOT { return left.symbol == right.symbol && left.dotName().asString() == right.dotName().asString() && looksTheSame(left.dotTarget(), right.dotTarget()); }
        }
      }
      return false;
    }

    void peepholeMangleHook(Node node) {
      var test = node.hookTest();
      var trueValue = node.hookTrue();
      var falseValue = node.hookFalse();
      var swapped = peepholeMangleBoolean(test, .SWAP);

      // "!a ? b : c;" => "a ? c : b;"
      if (swapped == .SWAP) {
        var temp = trueValue;
        trueValue = falseValue;
        falseValue = temp;
        trueValue.swapWith(falseValue);
      }

      // Collapse partially-identical binary expressions
      if (trueValue.kind == falseValue.kind && trueValue.kind.isBinaryOperator()) {
        var trueLeft = trueValue.binaryLeft();
        var trueRight = trueValue.binaryRight();
        var falseLeft = falseValue.binaryLeft();
        var falseRight = falseValue.binaryRight();

        // "a ? b = c : b = d;" => "b = a ? c : d;"
        if (looksTheSame(trueLeft, falseLeft)) {
          var hook = Node.createHook(test.replaceWith(null), trueRight.replaceWith(null), falseRight.replaceWith(null));
          peepholeMangleHook(hook);
          node.become(Node.createBinary(trueValue.kind, trueLeft.replaceWith(null), hook));
        }

        // "a ? b + 100 : c + 100;" => "(a ? b + c) + 100;"
        else if (looksTheSame(trueRight, falseRight) && !trueValue.kind.isBinaryStorageOperator()) {
          var hook = Node.createHook(test.replaceWith(null), trueLeft.replaceWith(null), falseLeft.replaceWith(null));
          peepholeMangleHook(hook);
          node.become(Node.createBinary(trueValue.kind, hook, trueRight.replaceWith(null)));
        }
      }
    }

    void patchThis(Node node) {
      if (lambdaCount > 0) {
        node.become(thisAlias());
      }
    }

    void patchClass(Node node) {
      if (!node.symbol.isImport() && node.symbol.type.baseClass() != null) {
        needExtends = true;
      }
    }

    void patchName(Node node) {
      if (node.symbol != null && node.symbol.kind.isInstance() && node.isNameExpression()) {
        node.become(Node.createDot(Node.createThis(), node.clone()));
      }
    }

    void unionVariableWithFunction(Node node) {
      assert (node.symbol.kind == .LOCAL_VARIABLE) == (currentFunction != null);
      if (currentFunction != null) {
        var left = namingGroupIndexForSymbol.get(currentFunction.uniqueID);
        var right = namingGroupIndexForSymbol.get(node.symbol.uniqueID);
        localVariableUnionFind.union(left, right);
      }
    }

    void patchBinary(Node node) {
      if (node.type.isInt(cache) && (node.kind == .MULTIPLY || !alwaysConvertsOperandsToInt(node.parent.kind))) {
        node.become(createBinaryInt(node.kind, node.binaryLeft().replaceWith(null), node.binaryRight().replaceWith(null)).withRange(node.range));
      }
    }

    void patchLet(Node node) {
      var value = node.letValue().replaceWith(null);
      var variable = node.letVariable().replaceWith(null);
      node.become(Node.createCall(Node.createLambda([variable], Node.createBlock([Node.createReturn(value)])), [variable.variableValue().replaceWith(null)]));
    }

    void patchAssign(Node node) {
      if (node.type.isInt(cache)) {
        var isPostfix = node.kind == .POSTFIX_INCREMENT || node.kind == .POSTFIX_DECREMENT;
        var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
        var left = node.binaryLeft();
        var right = node.binaryRight();
        NodeKind kind =
          node.kind == .ASSIGN_ADD ? .ADD :
          node.kind == .ASSIGN_SUBTRACT ? .SUBTRACT :
          node.kind == .ASSIGN_MULTIPLY ? .MULTIPLY :
          node.kind == .ASSIGN_DIVIDE ? .DIVIDE :
          .REMAINDER;
        node.become(createBinaryIntAssignment(kind, left.replaceWith(null), right.replaceWith(null)).withRange(node.range));
      }
    }

    void patchUnary(Node node) {
      if (node.type.isInt(cache)) {
        var isPostfix = node.kind == .POSTFIX_INCREMENT || node.kind == .POSTFIX_DECREMENT;
        var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
        var result = createBinaryIntAssignment(isIncrement ? .ADD : .SUBTRACT, node.unaryValue().replaceWith(null), Node.createInt(1));
        if (isPostfix && isExpressionUsed(node)) {
          result = createBinaryInt(isIncrement ? .SUBTRACT : .ADD, result, Node.createInt(1));
        }
        node.become(result.withRange(node.range).withType(node.type));
      }
    }

    void patchCast(Node node) {
      var value = node.castValue();

      // Cast to bool
      if (node.type.isBool(cache) && !value.type.isBool(cache)) {
        value = Node.createUnary(.NOT, value.replaceWith(null)).withRange(node.range).withType(node.type);
        node.become(Node.createUnary(.NOT, value).withRange(node.range).withType(node.type));
      }

      // Cast to int
      else if (node.type.isInt(cache) && !value.type.isInteger(cache) && !alwaysConvertsOperandsToInt(node.parent.kind)) {
        node.become(Node.createBinary(.BITWISE_OR, value.replaceWith(null), Node.createInt(0)).withRange(node.range).withType(node.type));
      }

      // Cast to float/double
      else if (node.type.isReal(cache) && !value.type.isNumeric(cache)) {
        node.become(Node.createUnary(.POSITIVE, value.replaceWith(null)).withRange(node.range).withType(node.type));
      }
    }

    void patchConstructor(Node node) {
      var block = node.functionBlock();
      if (block == null) {
        return;
      }
      var superInitializer = node.superInitializer();
      var memberInitializers = node.memberInitializers();
      var index = 0;
      if (superInitializer != null) {
        block.insertChild(index++, Node.createExpression(superInitializer.replaceWith(null)));
      }
      if (memberInitializers != null) {
        for (var i = 0; i < memberInitializers.children.length; i++) {
          var child = memberInitializers.children.get(i);
          var name = child.memberInitializerName();
          var value = child.memberInitializerValue();
          block.insertChild(index++, Node.createExpression(Node.createBinary(.ASSIGN, name.replaceWith(null), value.replaceWith(null))));
        }
      }
    }

    Node createBinaryInt(NodeKind kind, Node left, Node right) {
      if (kind == .MULTIPLY) {
        needMathImul = true;
        return Node.createCall(Node.createName("$imul"), [left, right]).withType(cache.intType);
      }
      return Node.createBinary(.BITWISE_OR, Node.createBinary(kind, left, right).withType(cache.intType), Node.createInt(0).withType(cache.intType)).withType(cache.intType);
    }

    static bool isSimpleNameAccess(Node node) {
      return node.kind == .NAME || node.kind == .THIS || node.kind == .DOT && isSimpleNameAccess(node.dotTarget());
    }

    Node createBinaryIntAssignment(NodeKind kind, Node left, Node right) {
      if (isSimpleNameAccess(left)) {
        return Node.createBinary(.ASSIGN, left.clone(), createBinaryInt(kind, left, right));
      }
      assert left.kind == .DOT;
      var target = left.dotTarget();
      var name = left.dotName();
      var temporaryName = Node.createName("$temp");
      var dot = Node.createDot(temporaryName, name.replaceWith(null));
      return Node.createLet(
        Node.createVariable(temporaryName.clone(), null, target.replaceWith(null)),
        Node.createBinary(.ASSIGN, dot, createBinaryInt(kind, dot.clone(), right)).withType(cache.intType)).withType(cache.intType);
    }

    bool alwaysConvertsOperandsToInt(NodeKind kind) {
      switch (kind) {
        case
          .BITWISE_OR, .BITWISE_AND, .BITWISE_XOR, .SHIFT_LEFT,
          .SHIFT_RIGHT, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_XOR, .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT {

          return true;
        }

        default {
          return false;
        }
      }
    }

    static bool isExpressionUsed(Node node) {
      assert node.kind.isExpression();
      var parent = node.parent;
      if (!parent.kind.isExpression()) {
        return false;
      }
      if (parent.kind == .SEQUENCE && (!isExpressionUsed(parent) || parent.children.indexOf(node) < parent.children.length - 1)) {
        return false;
      }
      return true;
    }

    void setCurrentFunction(Symbol symbol) {
      currentFunction = symbol;
      createdThisAlias = false;
    }

    Node thisAlias() {
      if (!createdThisAlias) {
        createdThisAlias = true;
        currentFunction.node.functionBlock().insertChild(0, Node.createVariableCluster(Node.createError(),
          [Node.createVariable(Node.createName("$this"), null, Node.createThis())]));
      }
      return Node.createName("$this");
    }

    static string numberToName(int number) {
      var name = "";
      if (number >= 52) {
        name = numberToName(number / 52 - 1);
        number = number % 52;
      }
      name += string.fromCodeUnit(number + (number < 26 ? 97 : 39));
      return name;
    }

    string generateSymbolName() {
      string name;
      do {
        name = numberToName(nextSymbolName++);
      } while (reservedNames.has(name));
      return name;
    }
  }
}
