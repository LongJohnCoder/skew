namespace js {
  enum BooleanSwap {
    SWAP,
    NO_SWAP,
  }

  struct GroupWithCount {
    final List<Symbol> group;
    final int count;
  }

  class Patcher {
    var nextTempID = 0;
    var createdThisAlias = false;
    Symbol currentFunction = null;
    var imul = "$imul";
    var extends = "$extends";
    var needExtends = false;
    var needMathImul = false;
    var nextSymbolName = 0;
    CompilerOptions options = null;
    TypeCache cache = null;
    final var reservedNames = Emitter.isKeyword.clone();
    final var symbolCounts = IntMap<int>();
    final var namingGroupIndexForSymbol = IntMap<int>();
    final Resolver resolver;

    void run(Node program) {
      assert program.kind == .PROGRAM;
      var allSymbols = resolver.allSymbols;
      options = resolver.options;
      cache = resolver.cache;

      // Traverse the tree of nodes, fixing up everything for emission in one
      // pass. Local variables will be grouped during the traversal of the node
      // tree for speed. It should be faster because we can access the top-
      // level function symbol instantly and avoid needing to traverse up to
      // the function from every local variable symbol, which we would have to
      // do if we just looped over symbols.
      patchNode(program);
    }

    bool canRename(Symbol symbol) {
      return !symbol.isImportOrExport() && !symbol.kind.isConstructor();
    }

    void trackSymbolCount(Node node) {
      var symbol = node.symbol;
      if (symbol != null && node.kind != .TYPE && !node.isDeclarationName()) {
        symbolCounts.set(symbol.uniqueID, symbolCounts.getOrDefault(symbol.uniqueID, 0) + 1);
      }
    }

    void patchNode(Node node) {
      trackSymbolCount(node);

      switch (node.kind) {
        case .CONSTRUCTOR { patchConstructor(node); setCurrentFunction(node.symbol); }
        case .FUNCTION { setCurrentFunction(node.symbol); }
        case .CAST { patchCast(node); }
        case .CLASS { patchClass(node); }
        case .NAME { patchName(node); }
        case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER { patchBinary(node); }
        case .PREFIX_INCREMENT, .PREFIX_DECREMENT, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT { patchUnary(node); }
        case .ASSIGN_ADD, .ASSIGN_SUBTRACT, .ASSIGN_MULTIPLY, .ASSIGN_DIVIDE, .ASSIGN_REMAINDER { patchAssign(node); }
      }

      if (node.hasChildren()) {
        for (var i = 0; i < node.children.size(); i++) {
          var child = node.children.get(i);
          if (child != null) {
            patchNode(child);
          }
        }
      }

      switch (node.kind) {
        case .CONSTRUCTOR, .FUNCTION { setCurrentFunction(null); }
      }
    }

    bool isFalsy(Node node) {
      var kind = node.kind;
      if (kind == .NULL) return true;
      else if (kind == .INT) return node.asInt() == 0;
      else if (kind.isReal()) return node.asDouble() == 0;
      else if (kind == .STRING) return node.asString() == "";
      else if (kind.isCast()) return isFalsy(node.castValue());
      else return false;
    }

    bool isJumpImplied(Node node, NodeKind kind) {
      assert node.kind == .BLOCK;
      assert kind == .RETURN || kind == .CONTINUE;
      var parent = node.parent;
      var parentKind = parent.kind;
      if (kind == .RETURN && parentKind == .FUNCTION || kind == .CONTINUE && parentKind.isLoop()) {
        return true;
      }
      if (parentKind == .IF && parent.isLastChild()) {
        return isJumpImplied(parent.parent, kind);
      }
      return false;
    }

    Node assignSourceIfNoSideEffects(Node node) {
      if (node.kind == .ASSIGN && node.binaryLeft().hasNoSideEffects()) {
        var right = node.binaryRight();
        return right.hasNoSideEffects() ? right : null;
      }

      if (node.kind == .ASSIGN_INDEX && node.ternaryLeft().hasNoSideEffects() && node.ternaryMiddle().hasNoSideEffects()) {
        var right = node.ternaryRight();
        return right.hasNoSideEffects() ? right : null;
      }

      return null;
    }

    Node joinExpressions(Node left, Node right) {
      var sequence = Node.createSequence(left.kind == .SEQUENCE ? left.removeChildren() : [left]);
      sequence.appendChildren(right.kind == .SEQUENCE ? right.removeChildren() : [right]);
      return sequence;
    }

    bool looksTheSame(Node left, Node right) {
      if (left.kind == right.kind) {
        switch (left.kind) {
          case .NULL, .THIS { return true; }
          case .INT { return left.asInt() == right.asInt(); }
          case .BOOL { return left.asBool() == right.asBool(); }
          case .FLOAT, .DOUBLE { return left.asDouble() == right.asDouble(); }
          case .STRING { return left.asString() == right.asString(); }
          case .NAME { return left.symbol != null && left.symbol == right.symbol || left.asString() == right.asString(); }
          case .DOT { return left.symbol == right.symbol && left.dotName().asString() == right.dotName().asString() && looksTheSame(left.dotTarget(), right.dotTarget()); }
        }
      }

      // Null literals are always implicitly casted, so unwrap implicit casts
      if (left.kind == .IMPLICIT_CAST) return looksTheSame(left.castValue(), right);
      if (right.kind == .IMPLICIT_CAST) return looksTheSame(left, right.castValue());
      return false;
    }

    void patchClass(Node node) {
      if (!node.symbol.isImport() && node.symbol.type.baseClass() != null) {
        needExtends = true;
      }
    }

    void patchName(Node node) {
      if (node.symbol != null && node.symbol.kind.isInstance() && node.isNameExpression()) {
        node.become(Node.createDot(Node.createThis(), node.clone()));
      }
    }

    void patchBinary(Node node) {
      if (node.type.isInt(cache) && (node.kind == .MULTIPLY || !alwaysConvertsOperandsToInt(node.parent.kind))) {
        node.become(createBinaryInt(node.kind, node.binaryLeft().replaceWith(null), node.binaryRight().replaceWith(null)).withRange(node.range));
      }
    }

    void patchAssign(Node node) {
      if (node.type.isInt(cache)) {
        var left = node.binaryLeft();
        var right = node.binaryRight();
        NodeKind kind =
          node.kind == .ASSIGN_ADD ? .ADD :
          node.kind == .ASSIGN_SUBTRACT ? .SUBTRACT :
          node.kind == .ASSIGN_MULTIPLY ? .MULTIPLY :
          node.kind == .ASSIGN_DIVIDE ? .DIVIDE :
          .REMAINDER;
        createBinaryIntAssignment(node, kind, left.replaceWith(null), right.replaceWith(null));
      }
    }

    void patchUnary(Node node) {
      if (node.type.isInt(cache)) {
        var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
        createBinaryIntAssignment(node, isIncrement ? .ADD : .SUBTRACT, node.unaryValue().replaceWith(null), Node.createInt(1));
      }
    }

    void patchCast(Node node) {
      var value = node.castValue();

      // Cast to bool
      if (node.type.isBool(cache) && !value.type.isBool(cache)) {
        value = Node.createUnary(.NOT, value.replaceWith(null)).withRange(node.range).withType(node.type);
        node.become(Node.createUnary(.NOT, value).withRange(node.range).withType(node.type));
      }

      // Cast to int
      else if (node.type.isInt(cache) && !value.type.isInteger(cache) && !alwaysConvertsOperandsToInt(node.parent.kind)) {
        node.become(Node.createBinary(.BITWISE_OR, value.replaceWith(null), Node.createInt(0)).withRange(node.range).withType(node.type));
      }

      // Cast to float/double
      else if (node.type.isReal(cache) && !value.type.isNumeric(cache)) {
        node.become(Node.createUnary(.POSITIVE, value.replaceWith(null)).withRange(node.range).withType(node.type));
      }
    }

    void patchConstructor(Node node) {
      var block = node.functionBlock();
      if (block == null) {
        return;
      }
      var superInitializer = node.superInitializer();
      var memberInitializers = node.memberInitializers();
      var index = 0;
      if (superInitializer != null) {
        block.insertChild(index, Node.createExpression(superInitializer.replaceWith(null)));
        index++;
      }
      if (memberInitializers != null) {
        for (var i = 0; i < memberInitializers.children.size(); i++) {
          var child = memberInitializers.children.get(i);
          var name = child.memberInitializerName();
          var value = child.memberInitializerValue();
          block.insertChild(index, Node.createExpression(Node.createBinary(.ASSIGN, name.replaceWith(null), value.replaceWith(null))));
          index++;
        }
      }
    }

    Node createBinaryInt(NodeKind kind, Node left, Node right) {
      if (kind == .MULTIPLY) {
        needMathImul = true;
        return Node.createCall(Node.createName(imul), [left, right]).withType(cache.intType);
      }
      return Node.createBinary(.BITWISE_OR, Node.createBinary(kind, left, right).withType(cache.intType), Node.createInt(0).withType(cache.intType)).withType(cache.intType);
    }

    static bool isSimpleNameAccess(Node node) {
      return node.kind == .NAME || node.kind == .THIS || node.kind == .DOT && isSimpleNameAccess(node.dotTarget());
    }

    void createBinaryIntAssignment(Node target, NodeKind kind, Node left, Node right) {
      if (isSimpleNameAccess(left)) {
        target.become(Node.createBinary(.ASSIGN, left.clone(), createBinaryInt(kind, left, right)).withRange(target.range));
        return;
      }
      assert left.kind == .DOT;
      var current = target;
      var parent = current.parent;
      while (parent.kind != .BLOCK) {
        current = parent;
        parent = parent.parent;
      }
      var name = "$temp" + nextTempID; nextTempID++;
      var symbol = resolver.createSymbol(name, .LOCAL_VARIABLE);
      var reference = Node.createName(name).withSymbol(symbol);
      var property = Node.createDot(reference, left.dotName().replaceWith(null));
      symbol.node = Node.createVariable(reference.clone(), Node.createType(cache.intType), null).withSymbol(symbol);
      parent.insertChild(parent.children.indexOf(current), Node.createVariableCluster(Node.createType(cache.intType), [symbol.node]));
      target.become(Node.createSequence([
        Node.createBinary(.ASSIGN, reference.clone(), left.dotTarget().replaceWith(null)),
        Node.createBinary(.ASSIGN, property.clone(), createBinaryInt(kind, property, right))]).withRange(target.range));
    }

    bool alwaysConvertsOperandsToInt(NodeKind kind) {
      switch (kind) {
        case
          .BITWISE_OR, .BITWISE_AND, .BITWISE_XOR, .SHIFT_LEFT,
          .SHIFT_RIGHT, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_XOR, .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT {

          return true;
        }

        default {
          return false;
        }
      }
    }

    void setCurrentFunction(Symbol symbol) {
      currentFunction = symbol;
      createdThisAlias = false;
    }

    Node thisAlias() {
      if (!createdThisAlias) {
        createdThisAlias = true;
        currentFunction.node.functionBlock().insertChild(0, Node.createVariableCluster(Node.createError(),
          [Node.createVariable(Node.createName("$this"), null, Node.createThis())]));
      }
      return Node.createName("$this");
    }

    static string numberToName(int number) {
      var name = "";
      if (number >= 52) {
        name = numberToName(number / 52 - 1);
        number = number % 52;
      }
      name += string.fromCodeUnit(number + (number < 26 ? 97 : 39));
      return name;
    }

    string generateSymbolName() {
      string name;
      do {
        name = numberToName(nextSymbolName);
        nextSymbolName++;
      } while (reservedNames.has(name));
      return name;
    }
  }
}
