namespace js {
  enum ClusterState {
    NONE,
    VAR_CHAIN,
    COMPOUND_NAME,
  }

  enum AfterToken {
    AFTER_KEYWORD,
    AFTER_PARENTHESIS,
  }

  enum BracesMode {
    MUST_KEEP_BRACES,
    CAN_OMIT_BRACES,
  }

  class Emitter : IEmitter {
    static StringMap<bool> isKeyword;
    var newline = "\n";
    var space = " ";
    var indent = "";
    var currentLine = 0;
    var currentColumn = 0;
    var needsSemicolon = false;
    Source currentSource = null;
    Patcher patcher = null;
    CompilerOptions options = null;
    final var generator = SourceMapGenerator();
    final Resolver resolver;

    // Numbers normally need to be wrapped in parentheses when toString() is
    // called on them because "1.toString()" is a syntax error in JavaScript.
    // However, toString() can be called implicitly as part of a string binary
    // + operation. This variable prevents wrapping in parentheses when the
    // toString() call has been elided.
    Node toStringTarget = null;

    void patchProgram(Node program) {
      if (isKeyword == null) {
        isKeyword = createIsKeyword();
      }
      options = resolver.options;
      if (options.jsMinify) {
        newline = "";
        space = "";
      }
      patcher = Patcher(resolver);
      patcher.run(program);
    }

    override List<Source> emitProgram(Node program) {
      patchProgram(program);

      // Collect all interesting nodes for easy access
      var collector = Collector(program, .SORT_BY_INHERITANCE_AND_CONTAINMENT);
      currentSource = Source(options.outputFile, "");

      // Prepend inputs
      for (var i = 0; i < options.prepend.size(); i++) {
        appendSource(options.prepend.get(i));
      }

      // The entire body of code is wrapped in a closure for safety
      emit(indent + minifySpaces("(function() {" + newline));
      increaseIndent();

      // Emit helper functions
      if (patcher.needMathImul) {
        emit(indent + "var " + patcher.imul + minifySpaces(" = Math.imul || function(a, b) {" + newline));
        increaseIndent();
        emit(indent + "var " + minifySpaces("ah = a >>> 16, al = a & 65535, bh = b >>> 16, bl = b & 65535;" + newline));
        emit(indent + "return " + minifySpaces("al * bl + (ah * bl + al * bh << 16) | 0"));
        emitSemicolonAfterStatement();
        decreaseIndent();
        emit(indent + "};" + newline);
        needsSemicolon = false;
      }
      if (patcher.needExtends) {
        var derived = options.jsMangle ? "d" : "derived";
        var base = options.jsMangle ? "b" : "base";
        emit(indent + "function " + minifySpaces(patcher.extends + "(" + derived + ", " + base + ") {" + newline));
        increaseIndent();
        emit(indent + derived + minifySpaces(".prototype = Object.create(" + base + ".prototype);" + newline));
        emit(indent + derived + minifySpaces(".prototype.constructor = " + derived));
        emitSemicolonAfterStatement();
        decreaseIndent();
        emit(indent + "}" + newline);
        needsSemicolon = false;
      }

      // Emit types
      for (var i = 0; i < collector.typeSymbols.size(); i++) {
        var type = collector.typeSymbols.get(i).type;
        if (type.isNamespace()) {
          if (!type.symbol.isImport()) {
            maybeEmitMinifedNewline();
            emitNode(type.symbol.node.firstNonExtensionSibling());
          }
          continue;
        }
        if (!type.symbol.isImport()) {
          if (type.isEnum()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          } else {
            var constructor = type.constructor();
            if (constructor != null) {
              emitNode(constructor.symbol.node);
            }
          }
        }
        var members = type.sortedMembers();
        for (var j = 0; j < members.size(); j++) {
          var symbol = members.get(j).symbol;
          if (symbol.enclosingSymbol == type.symbol && symbol.node != null) {
            if (symbol.kind.isFunction() && symbol.kind != .CONSTRUCTOR_FUNCTION) {
              emitNode(symbol.node);
            } else if (symbol.kind == .GLOBAL_VARIABLE && !symbol.isEnumValue()) {
              collector.freeVariableSymbols.push(symbol);
            }
          }
        }
      }

      // Emit free functions
      for (var i = 0; i < collector.freeFunctionSymbols.size(); i++) {
        emitNode(collector.freeFunctionSymbols.get(i).node);
      }

      // Emit free variables
      List<Node> variables = [];
      for (var i = 0; i < collector.freeVariableSymbols.size(); i++) {
        var variable = collector.freeVariableSymbols.get(i).node;
        if (options.jsMinify) variables.push(variable);
        else emitVariables([variable]);
      }
      emitVariables(variables);

      // End the closure wrapping everything
      decreaseIndent();
      emit(indent + "}());\n");

      // Append inputs
      for (var i = 0; i < options.append.size(); i++) {
        appendSource(options.append.get(i));
      }

      // Create the source map
      if (options.jsSourceMap) {
        // Obfuscate the sourceMappingURL so it's not incorrectly picked up as
        // the sourceMappingURL for the compiled JavaScript compiler file
        currentSource.contents = currentSource.contents + "/";

        // Append the source map inline with the compiled output
        if (options.outputFile == "") {
          currentSource.contents = currentSource.contents +
            "/# sourceMappingURL=data:application/json;base64," +
            encodeBase64(generator.toString()) + "\n";
        }

        // Create the source map as another file alongside the output
        else {
          var name = options.outputFile + ".map";
          currentSource.contents = currentSource.contents +
            "/# sourceMappingURL=" + splitPath(name).entry + "\n";
          return [currentSource, Source(name, generator.toString())];
        }
      }

      return [currentSource];
    }

    void appendSource(Source source) {
      if (currentColumn > 0) {
        emit("\n");
      }
      currentSource.contents += source.contents;
      if (options.jsSourceMap) {
        for (var i = 0, n = source.lineCount(); i < n; i++) {
          generator.addMapping(source, i, 0, currentLine, 0);
          currentLine++;
        }
      }
      if (source.contents.codeUnitAt(source.contents.size() - 1) != '\n') {
        emit("\n");
      }
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        var range = node.range;
        if (range.source != null) {
          var location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      if (!options.jsMinify) {
        indent += "  ";
      }
    }

    void decreaseIndent() {
      if (!options.jsMinify) {
        indent = indent.slice(2, indent.size());
      }
    }

    void emit(string text) {
      if (options.jsMinify || options.jsSourceMap) {
        for (var i = 0; i < text.size(); i++) {
          var c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents += text;
    }

    string minifySpaces(string text) {
      return text.replace(" ", space);
    }

    // Lots of text editors choke up on long lines, so add a newline every now
    // and then for usability's sake
    void maybeEmitMinifedNewline() {
      if (newline == "" && currentColumn > 1024) {
        emit("\n");
      }
    }

    void emitSemicolonAfterStatement() {
      if (!options.jsMinify) {
        emit(";\n");
      } else {
        needsSemicolon = true;
      }
    }

    void emitSemicolonIfNeeded() {
      if (needsSemicolon) {
        emit(";");
        needsSemicolon = false;
      }
    }

    void emitStatements(List<Node> nodes) {
      for (var i = 0; i < nodes.size(); i++) {
        emitSemicolonIfNeeded();
        maybeEmitMinifedNewline();
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      for (var i = 0; i < nodes.size(); i++) {
        if (i > 0) emit("," + space);
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      for (var i = 0; i < nodes.size(); i++) {
        if (i > 0) {
          emit("," + space);
          maybeEmitMinifedNewline();
        }
        emitExpression(nodes.get(i), .COMMA);
      }
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void recursiveEmitIfStatement(Node node) {
      var trueBlock = node.ifTrue();
      var falseBlock = node.ifFalse();
      var trueStatement = trueBlock.blockStatement();
      emit("if" + space + "(");
      emitExpression(node.ifTest(), .LOWEST);
      emit(")");

      // Make sure to always keep braces to avoid the dangling "else" case
      emitBlock(trueBlock, .AFTER_PARENTHESIS, falseBlock != null && trueStatement != null && trueStatement.kind == .IF ? .MUST_KEEP_BRACES : .CAN_OMIT_BRACES);

      if (falseBlock != null) {
        emitSemicolonIfNeeded();
        maybeEmitMinifedNewline();
        emit(space + "else");
        var falseStatement = falseBlock.blockStatement();
        if (falseStatement != null && falseStatement.kind == .IF) {
          emit(" ");
          addMapping(falseStatement);
          recursiveEmitIfStatement(falseStatement);
        } else {
          emitBlock(falseBlock, .AFTER_KEYWORD, .CAN_OMIT_BRACES);
        }
      }
    }

    void emitNode(Node node) {
      addMapping(node);

      // Separating the case bodies into separate functions makes the JavaScript JIT go faster
      switch (node.kind) {
        case .CASE { emitCase(node); }
        case .VARIABLE_CLUSTER { emitVariables(node.clusterVariables()); }
        case .NAMESPACE { emitNamespace(node); }
        case .ENUM, .ENUM_FLAGS { emitEnum(node); }
        case .CONSTRUCTOR, .FUNCTION { emitFunction(node); }
        case .VARIABLE { emitVariable(node); }
        case .IF { emitIf(node); }
        case .FOR { emitFor(node); }
        case .FOR_EACH { emitForEach(node); }
        case .WHILE { emitWhile(node); }
        case .DO_WHILE { emitDoWhile(node); }
        case .RETURN { emitReturn(node); }
        case .BREAK { emitBreak(node); }
        case .CONTINUE { emitContinue(node); }
        case .ASSERT { emitAssert(node); }
        case .EXPRESSION { emitExpressionStatement(node); }
        case .SWITCH { emitSwitch(node); }
        case .MODIFIER { emitModifier(node); }
        case .PARAMETER, .ALIAS, .USING {}
        default { assert false; }
      }
    }

    void emitBlock(Node node, AfterToken after, BracesMode mode) {
      var shouldMinify = mode == .CAN_OMIT_BRACES && options.jsMinify;
      addMapping(node);
      if (shouldMinify && !node.hasChildren()) {
        emit(";");
      } else if (shouldMinify && node.children.size() == 1) {
        if (after == .AFTER_KEYWORD) emit(" ");
        emitNode(node.children.get(0));
      } else {
        emit(space + "{" + newline);
        if (node.hasChildren()) {
          increaseIndent();
          emitStatements(node.children);
          decreaseIndent();
        }
        emit(indent + "}");
        needsSemicolon = false;
      }
    }

    void emitCase(Node node) {
      var values = node.caseValues();
      var block = node.caseBlock();
      emitSemicolonIfNeeded();
      for (var i = 0; i < values.size(); i++) {
        emit(indent + "case ");
        emitExpression(values.get(i), .LOWEST);
        emit(":" + newline);
        maybeEmitMinifedNewline();
      }
      if (values.size() == 0) {
        emit(indent + "default:" + newline);
      }
      increaseIndent();
      if (block.hasChildren()) {
        emitStatements(block.children);
      }
      if (!block.blockAlwaysEndsWithReturn() && (!options.jsMinify || !node.isLastChild())) {
        emitSemicolonIfNeeded();
        emit(indent + "break");
        emitSemicolonAfterStatement();
      }
      decreaseIndent();
    }

    void emitVariables(List<Node> variables) {
      var state = ClusterState.NONE;
      for (var i = 0; i < variables.size(); i++) {
        var variable = variables.get(i);
        var symbol = variable.symbol;
        var isCompoundName = symbol != null && (hasCompoundName(symbol) || symbol.isExport());
        if (symbol != null && (symbol.kind.isInstance() || symbol.isImport()) || isCompoundName && variable.variableValue() == null) {
          continue;
        }
        emitSemicolonIfNeeded();
        if (isCompoundName) {
          if (state != .NONE) {
            emit(";" + newline);
          }
          state = .COMPOUND_NAME;
          emit(indent);
        } else {
          if (state != .VAR_CHAIN) {
            if (state == .COMPOUND_NAME) {
              emit(";" + newline);
            }
            emit(indent + "var ");
            state = .VAR_CHAIN;
          } else {
            emit("," + space);
            maybeEmitMinifedNewline();
          }
        }
        emitNode(variable);
      }
      if (state != .NONE) {
        emitSemicolonAfterStatement();
      }
    }

    void emitNamespace(Node node) {
      var symbol = node.symbol;
      if (options.jsMangle && !symbol.isImportOrExport()) {
        return;
      }
      emitSemicolonIfNeeded();
      emit(indent);
      if (!hasCompoundName(symbol) && !symbol.isExport()) {
        emit("var ");
      }
      emit(fullName(symbol) + space + "=" + space + "{}");
      emitSemicolonAfterStatement();
    }

    void emitEnum(Node node) {
      var symbol = node.symbol;
      var block = node.declarationBlock();
      if (options.foldAllConstants && !symbol.isImportOrExport()) {
        return;
      }
      emitSemicolonIfNeeded();
      emit(indent);
      if (!hasCompoundName(symbol) && !symbol.isExport()) {
        emit("var ");
      }
      emit(fullName(symbol) + space + "=" + space + "{" + newline);
      increaseIndent();
      for (var i = 0; i < block.children.size(); i++) {
        var child = block.children.get(i).symbol;
        emit(indent + mangleName(child) + ":" + space + child.constant.asInt());
        if (i != block.children.size() - 1) {
          emit("," + newline);
          maybeEmitMinifedNewline();
        } else {
          emit(newline);
        }
      }
      decreaseIndent();
      emit(indent + "}");
      emitSemicolonAfterStatement();
    }

    void emitFunction(Node node) {
      var block = node.functionBlock();
      var symbol = node.symbol;
      if (block == null) {
        return;
      }
      var useFunctionStatement = !hasCompoundName(symbol) && !symbol.isExport();
      emitSemicolonIfNeeded();
      emit(useFunctionStatement
        ? indent + "function " + fullName(symbol)
        : indent + fullName(symbol) + space + "=" + space + "function");
      emitArgumentVariables(node.functionArguments().children);
      emitBlock(block, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES);
      if (useFunctionStatement) {
        emit(newline);
      } else {
        emitSemicolonAfterStatement();
      }
      if (node.kind == .CONSTRUCTOR) {
        var type = symbol.enclosingSymbol.type;
        if (type.isClass() && type.baseClass() != null) {
          emitSemicolonIfNeeded();
          emit(indent + patcher.extends + "(" + fullName(type.symbol) + "," + space + fullName(type.baseClass().symbol) + ")");
          emitSemicolonAfterStatement();
        }
      }
    }

    void emitVariable(Node node) {
      var value = node.variableValue();
      emit(node.symbol == null ? node.declarationName().asString() : fullName(node.symbol));
      if (value != null) {
        emit(space + "=" + space);
        emitExpression(value, .COMMA);
      }
    }

    void emitIf(Node node) {
      emit(indent);
      recursiveEmitIfStatement(node);
      emit(newline);
    }

    void emitFor(Node node) {
      var setup = node.forSetup();
      var test = node.forTest();
      var update = node.forUpdate();
      emit(indent + "for" + space + "(");
      if (setup != null) {
        if (setup.kind == .VARIABLE_CLUSTER) {
          emit("var ");
          emitCommaSeparatedNodes(setup.clusterVariables());
        } else {
          emitExpression(setup, .LOWEST);
        }
      }
      if (test != null) {
        emit(";" + space);
        emitExpression(test, .LOWEST);
      } else {
        emit(";");
      }
      if (update != null) {
        emit(";" + space);
        emitExpression(update, .LOWEST);
      } else {
        emit(";");
      }
      emit(")");
      emitBlock(node.forBlock(), .AFTER_PARENTHESIS, .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitForEach(Node node) {
      var variable = node.forEachVariable();
      var value = node.forEachValue();
      emit(indent + "for" + space + "(var ");
      emitNode(variable);
      emit(" in ");
      emitExpression(value, .LOWEST);
      emit(")");
      emitBlock(node.forEachBlock(), .AFTER_PARENTHESIS, .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitWhile(Node node) {
      emit(indent + "while" + space + "(");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")");
      emitBlock(node.whileBlock(), .AFTER_PARENTHESIS, .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitDoWhile(Node node) {
      emit(indent + "do");
      emitBlock(node.whileBlock(), .AFTER_KEYWORD, .CAN_OMIT_BRACES);
      emitSemicolonIfNeeded();
      emit(space + "while" + space + "(");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")");
      emitSemicolonAfterStatement();
    }

    void emitReturn(Node node) {
      var value = node.returnValue();
      emit(indent);
      if (value != null) {
        emit("return ");
        emitExpression(value, .LOWEST);
      } else {
        emit("return");
      }
      emitSemicolonAfterStatement();
    }

    void emitBreak(Node node) {
      emit(indent + "break");
      emitSemicolonAfterStatement();
    }

    void emitContinue(Node node) {
      emit(indent + "continue");
      emitSemicolonAfterStatement();
    }

    void emitAssert(Node node) {
      var value = node.assertValue();
      value.invertBooleanCondition(resolver.cache);
      if (!value.isFalse()) {
        var couldBeFalse = !value.isTrue();
        if (couldBeFalse) {
          emit(indent + "if" + space + "(");
          emitExpression(value, .LOWEST);
          emit(")");
          if (!options.jsMinify) {
            emit(" {\n");
            increaseIndent();
          }
        }
        var text = node.range + " (" + node.range.locationString() + ")";
        emit(indent + "throw new Error(" + quoteStringJS(text) + ")");
        emitSemicolonAfterStatement();
        if (couldBeFalse && !options.jsMinify) {
          decreaseIndent();
          emit(indent + "}\n");
        }
      }
    }

    void emitExpressionStatement(Node node) {
      emit(indent);
      emitExpression(node.expressionValue(), .LOWEST);
      emitSemicolonAfterStatement();
    }

    void emitSwitch(Node node) {
      emit(indent + "switch" + space + "(");
      emitExpression(node.switchValue(), .LOWEST);
      emit(")" + space + "{" + newline);
      emitStatements(node.switchCases());
      emit(indent + "}" + newline);
      needsSemicolon = false;
    }

    void emitModifier(Node node) {
      emitStatements(node.modifierStatements());
    }

    void emitExpression(Node node, Precedence precedence) {
      addMapping(node);

      var kind = node.kind;
      switch (kind) {
        case .NAME { emit(node.symbol == null ? node.asString() : fullName(node.symbol)); }
        case .TYPE { emit(fullName(node.type.symbol)); }
        case .THIS { emit("this"); }
        case .HOOK { emitHook(node, precedence); }
        case .NULL { emit("null"); }
        case .BOOL { emitBool(node); }
        case .INT { emitInt(node); }
        case .FLOAT, .DOUBLE { emitDouble(node); }
        case .STRING { emit(quoteStringJS(node.asString())); }
        case .LIST { emitList(node); }
        case .DOT, .DOT_ARROW, .DOT_COLON { emitDot(node); }
        case .CALL { emitCall(node); }
        case .SUPER_CALL { emitSuperCall(node); }
        case .SEQUENCE { emitSequence(node, precedence); }
        case .QUOTED { emitExpression(node.quotedValue(), precedence); }
        case .INDEX { emitIndex(node, precedence); }
        case .ASSIGN_INDEX { emitTernary(node, precedence); }
        case .CAST, .IMPLICIT_CAST { emitExpression(node.castValue(), precedence); }
        default {
          if (kind.isUnaryOperator()) emitUnary(node, precedence);
          else if (kind.isBinaryOperator()) emitBinary(node, precedence);
          else assert false;
        }
      }
    }

    void emitHook(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.hookTest(), .LOGICAL_OR);
      emit(space + "?" + space);
      emitExpression(node.hookTrue(), .ASSIGN);
      emit(space + ":" + space);
      emitExpression(node.hookFalse(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    void emitBool(Node node) {
      if (options.jsMangle) {
        emit(node.asBool() ? "!0" : "!1");
      } else {
        emit(node.asBool() ? "true" : "false");
      }
    }

    void emitInt(Node node) {
      var wrap = node.parent.kind == .DOT && node != toStringTarget;
      if (wrap) emit("(");
      emit(node.asInt().toString());
      if (wrap) emit(")");
    }

    void emitDouble(Node node) {
      var wrap = node.parent.kind == .DOT && node != toStringTarget;
      var value = node.asDouble();
      if (wrap) emit("(");
      if (value == math.INFINITY) emit("Infinity");
      else if (value == -math.INFINITY) emit("-Infinity");
      else if (value != value) emit("NaN");
      else emit(value.toString());
      if (wrap) emit(")");
    }

    void emitList(Node node) {
      emit("[");
      emitCommaSeparatedExpressions(node.listValues());
      emit("]");
    }

    void emitDot(Node node) {
      emitExpression(node.dotTarget(), .MEMBER);
      emit(".");
      var name = node.dotName();
      if (name.kind == .QUOTED) {
        name = name.quotedValue();
      }
      emit(
        name.symbol == null ? name.asString() :
        name.symbol.kind.isInstance() ? mangleName(name.symbol) :
        fullName(name.symbol));
    }

    void emitCall(Node node) {
      var value = node.callValue();
      if (value.kind.isType()) emit("new ");
      emitExpression(value, .UNARY_POSTFIX);
      emit("(");
      emitCommaSeparatedExpressions(node.callArguments());
      emit(")");
    }

    void emitSuperCall(Node node) {
      var arguments = node.superCallArguments();
      emit(fullName(node.symbol));
      emit(".call(this");
      for (var i = 0; i < arguments.size(); i++) {
        emit("," + space);
        emitExpression(arguments.get(i), .COMMA);
      }
      emit(")");
    }

    void emitSequence(Node node, Precedence precedence) {
      if (.COMMA <= precedence) emit("(");
      emitCommaSeparatedExpressions(node.sequenceValues());
      if (.COMMA <= precedence) emit(")");
    }

    void emitUnary(Node node, Precedence precedence) {
      var value = node.unaryValue();
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var isPostfix = info.precedence == .UNARY_POSTFIX;
      if (!isPostfix) {
        emit(info.text);

        var kind = node.kind;
        var valueKind = value.kind;
        if (kind == .NEW || kind == .DELETE ||
            kind == .POSITIVE && (valueKind == .POSITIVE || valueKind == .PREFIX_INCREMENT) ||
            kind == .NEGATIVE && (valueKind == .NEGATIVE || valueKind == .PREFIX_DECREMENT || valueKind == .INT && value.asInt() < 0)) {
          emit(" "); // Prevent "- -1" from becoming "--1"
        }
      }
      emitExpression(value, info.precedence);
      if (isPostfix) emit(info.text);
      if (info.precedence < precedence) emit(")");
    }

    bool isToStringCall(Node node) {
      if (node.kind == .CALL) {
        var value = node.callValue();
        return value.kind == .DOT && value.symbol != null && value.symbol.name == "toString" && node.callArguments().size() == 0;
      }
      return false;
    }

    void emitBinary(Node node, Precedence precedence) {
      var kind = node.kind;
      var left = node.binaryLeft();
      var right = node.binaryRight();
      var info = operatorInfo.get(kind);
      if (info.precedence < precedence) emit("(");

      // Special case adding a string with the result of calling toString()
      // since the JavaScript runtime will automatically call toString()
      if ((kind == .ADD || kind == .ASSIGN_ADD) && left.type != null && left.type.isString(resolver.cache) && isToStringCall(right)) {
        right = right.callValue().dotTarget();
      } else if (kind == .ADD && right.type != null && right.type.isString(resolver.cache) && isToStringCall(left)) {
        left = left.callValue().dotTarget();
      }

      toStringTarget = left;
      emitExpression(left, info.precedence.incrementIfRightAssociative(info.associativity));
      emit(kind == .IN ? " in " : space + (kind == .EQUAL ? "===" : kind == .NOT_EQUAL ? "!==" : info.text) + space);

      // Prevent "x - -1" from becoming "x--1"
      if (space == "" && (
          kind == .ADD && (right.kind == .POSITIVE || right.kind == .PREFIX_INCREMENT) ||
          kind == .SUBTRACT && (right.kind == .NEGATIVE || right.kind == .PREFIX_DECREMENT || right.kind == .INT && right.asInt() < 0))) {
        emit(" ");
      }

      toStringTarget = right;
      emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity));
      if (info.precedence < precedence) emit(")");
    }

    bool isIdentifierString(Node node) {
      if (node.kind == .STRING) {
        var value = node.asString();
        for (var i = 0; i < value.size(); i++) {
          var c = value.codeUnitAt(i);
          if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && c != '_' && c != '$' && (i == 0 || c < '0' || c > '9')) {
            return false;
          }
        }
        return value.size() > 0 && !isKeyword.has(value);
      }
      return false;
    }

    void emitIndexProperty(Node node) {
      if (options.jsMangle && isIdentifierString(node)) {
        emit("." + node.asString());
      } else {
        emit("[");
        emitExpression(node, .LOWEST);
        emit("]");
      }
    }

    void emitIndex(Node node, Precedence precedence) {
      emitExpression(node.binaryLeft(), .MEMBER);
      emitIndexProperty(node.binaryRight());
    }

    void emitTernary(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.ternaryLeft(), .MEMBER);
      emitIndexProperty(node.ternaryMiddle());
      emit(space + "=" + space);
      emitExpression(node.ternaryRight(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    string quoteStringJS(string text) {
      var doubleCount = 0;
      var singleCount = 0;
      for (var i = 0; i < text.size(); i++) {
        var c = text.codeUnitAt(i);
        if (c == '"') doubleCount++;
        else if (c == '\'') singleCount++;
      }
      return quoteString(text, singleCount > doubleCount ? '"' : '\'');
    }

    static bool hasCompoundName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      return enclosingSymbol != null && enclosingSymbol.kind != .GLOBAL_NAMESPACE && (
        symbol.kind != .CONSTRUCTOR_FUNCTION || hasCompoundName(enclosingSymbol));
    }

    static StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result.set("apply", true);
      result.set("arguments", true);
      result.set("Boolean", true);
      result.set("break", true);
      result.set("call", true);
      result.set("case", true);
      result.set("catch", true);
      result.set("class", true);
      result.set("const", true);
      result.set("constructor", true);
      result.set("continue", true);
      result.set("Date", true);
      result.set("debugger", true);
      result.set("default", true);
      result.set("delete", true);
      result.set("do", true);
      result.set("double", true);
      result.set("else", true);
      result.set("export", true);
      result.set("extends", true);
      result.set("false", true);
      result.set("finally", true);
      result.set("float", true);
      result.set("for", true);
      result.set("Function", true);
      result.set("function", true);
      result.set("if", true);
      result.set("import", true);
      result.set("in", true);
      result.set("instanceof", true);
      result.set("int", true);
      result.set("let", true);
      result.set("new", true);
      result.set("null", true);
      result.set("Number", true);
      result.set("Object", true);
      result.set("return", true);
      result.set("String", true);
      result.set("super", true);
      result.set("this", true);
      result.set("throw", true);
      result.set("true", true);
      result.set("try", true);
      result.set("var", true);
      return result;
    }

    static string mangleName(Symbol symbol) {
      if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (isKeyword.has(symbol.name)) {
        return "$" + symbol.name;
      }
      return symbol.name;
    }

    static string fullName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      if (enclosingSymbol != null && enclosingSymbol.kind != .GLOBAL_NAMESPACE) {
        var enclosingName = fullName(enclosingSymbol);
        if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
          return enclosingName;
        }
        if (symbol.kind.isInstance()) {
          enclosingName += ".prototype";
        }
        return enclosingName + "." + mangleName(symbol);
      }
      return mangleName(symbol);
    }
  }
}
