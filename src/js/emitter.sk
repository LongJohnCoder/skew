namespace js {
  class Emitter : IEmitter {
    int currentLine = 0;
    int currentColumn = 0;
    Source currentSource = null;
    SourceMapGenerator generator = new SourceMapGenerator();
    CompilerOptions options;
    TypeCache cache;
    string indent = "";

    override List<Source> emitProgram(Node program) {
      currentSource = new Source(options.outputFile, "");
      emitNode(program);
      return { currentSource };
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        Range range = node.range;
        if (range.source != null) {
          LineColumn location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      indent = indent.append("  ");
    }

    void decreaseIndent() {
      indent = indent.slice(2, indent.length);
    }

    void emit(string text) {
      if (options.jsSourceMap) {
        int i;
        for (i = 0; i < text.length; i++) {
          int c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents = currentSource.contents.append(text);
    }

    void emitNodes(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitExpression(nodes.get(i), Precedence.COMMA);
      }
    }

    void emitArguments(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void emitChildren(Node node) {
      if (node.hasChildren()) {
        emitNodes(node.children);
      }
    }

    void recursiveEmitIfStatement(Node node) {
      emit("if (");
      emitExpression(node.ifTest(), Precedence.LOWEST);
      emit(") ");
      emitNode(node.ifTrue());
      Node block = node.ifFalse();
      if (block != null) {
        emit(" else ");
        Node statement = block.hasChildren() && block.children.length == 1 ? block.children.get(0) : null;
        if (statement != null && statement.kind == NodeKind.IF) {
          addMapping(statement);
          recursiveEmitIfStatement(statement);
        } else {
          emitNode(block);
        }
      }
    }

    void emitNode(Node node) {
      addMapping(node);
      switch (node.kind) {
        case NodeKind.PROGRAM {
          emitChildren(node);
        }

        case NodeKind.FILE {
          emitChildren(node.fileBlock());
        }

        case NodeKind.BLOCK {
          emit("{\n");
          increaseIndent();
          emitChildren(node);
          decreaseIndent();
          emit(indent.append("}"));
        }

        case NodeKind.CASE {
          List<Node> values = node.caseValues();
          int i;
          for (i = 0; i < values.length; i++) {
            emit(indent.append("case "));
            emitExpression(values.get(i), Precedence.LOWEST);
            emit(":\n");
          }
          if (values.length == 0) {
            emit(indent.append("default:\n"));
          }
          increaseIndent();
          emitChildren(node.caseBlock());
          emit(indent.append("break;\n"));
          decreaseIndent();
        }

        case NodeKind.VARIABLE_CLUSTER {
          emit(indent.append("var "));
          emitCommaSeparatedNodes(node.clusterVariables());
          emit(";\n");
        }

        case NodeKind.NAMESPACE {}
        case NodeKind.ENUM {}
        case NodeKind.ENUM_FLAGS {}
        case NodeKind.CLASS {}
        case NodeKind.STRUCT {}
        case NodeKind.INTERFACE {}

        case NodeKind.EXTENSION {}
        case NodeKind.CONSTRUCTOR {}
        case NodeKind.FUNCTION {}

        case NodeKind.VARIABLE {
          Node value = node.variableValue();
          emit(node.symbol.name);
          if (value != null) {
            emit(" = ");
            emitExpression(value, Precedence.COMMA);
          }
        }

        case NodeKind.PARAMETER {
        }

        case NodeKind.USING_ALIAS {
        }

        case NodeKind.IF {
          emit(indent);
          recursiveEmitIfStatement(node);
          emit("\n");
        }

        case NodeKind.FOR {
          Node setup = node.forSetup();
          Node test = node.forTest();
          Node update = node.forUpdate();
          emit(indent.append("for ("));
          if (setup != null) {
            if (setup.kind == NodeKind.VARIABLE_CLUSTER) {
              emit("var ");
              emitCommaSeparatedNodes(setup.clusterVariables());
            } else {
              emitExpression(setup, Precedence.LOWEST);
            }
          }
          if (test != null) {
            emit("; ");
            emitExpression(test, Precedence.LOWEST);
          } else {
            emit(";");
          }
          if (update != null) {
            emit("; ");
            emitExpression(update, Precedence.LOWEST);
          } else {
            emit(";");
          }
          emit(") ");
          emitNode(node.forBlock());
        }

        case NodeKind.FOR_EACH {
        }

        case NodeKind.WHILE {
          emit(indent.append("while ("));
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(") ");
          emitNode(node.whileBlock());
          emit("\n");
        }

        case NodeKind.DO_WHILE {
          emit(indent.append("do "));
          emitNode(node.whileBlock());
          emit(" while (");
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(");\n");
        }

        case NodeKind.RETURN {
          Node value = node.returnValue();
          emit(indent);
          if (value != null) {
            emit("return ");
            emitExpression(value, Precedence.LOWEST);
            emit(";\n");
          } else {
            emit("return;\n");
          }
        }

        case NodeKind.BREAK {
          emit(indent.append("break;\n"));
        }

        case NodeKind.CONTINUE {
          emit(indent.append("continue;\n"));
        }

        case NodeKind.ASSERT {
        }

        case NodeKind.EXPRESSION {
          emit(indent);
          emitExpression(node.expressionValue(), Precedence.LOWEST);
          emit(";\n");
        }

        case NodeKind.SWITCH {
          emit(indent.append("switch ("));
          emitExpression(node.switchValue(), Precedence.LOWEST);
          emit(") {\n");
          emitNodes(node.switchCases());
          emit(indent.append("}"));
        }

        case NodeKind.MODIFIER {
          emitNodes(node.modifierStatements());
        }

        case NodeKind.USING_NAMESPACE {
        }

        default {
          assert false;
        }
      }
    }

    void emitExpression(Node node, Precedence precedence) {
      addMapping(node);
      switch (node.kind) {
        case NodeKind.NAME {
          emit(node.asString());
        }

        case NodeKind.TYPE {
        }

        case NodeKind.THIS {
          emit("this");
        }

        case NodeKind.HOOK {
          if (Precedence.ASSIGN < precedence) emit("(");
          emitExpression(node.hookTest(), Precedence.LOGICAL_OR);
          emit(" ? ");
          emitExpression(node.hookTrue(), Precedence.ASSIGN);
          emit(" : ");
          emitExpression(node.hookFalse(), Precedence.ASSIGN);
          if (Precedence.ASSIGN < precedence) emit(")");
        }

        case NodeKind.NULL {
          emit("null");
        }

        case NodeKind.TRUE {
          emit("true");
        }

        case NodeKind.FALSE {
          emit("false");
        }

        case NodeKind.INT {
          emit(node.asInt().toString());
        }

        case NodeKind.FLOAT, NodeKind.DOUBLE {
          emit(node.asDouble().toString());
        }

        case NodeKind.STRING {
          emit(quoteString(node.asString(), '"'));
        }

        case NodeKind.INITIALIZER {
          emit("[");
          emitCommaSeparatedExpressions(node.initializerValues());
          emit("]");
        }

        case NodeKind.DOT {
          emitExpression(node.dotTarget(), Precedence.MEMBER);
          emit(".");
          emitExpression(node.dotName(), Precedence.MEMBER);
        }

        case NodeKind.CALL {
          if (Precedence.MEMBER < precedence) emit("(");
          emitExpression(node.callValue(), Precedence.UNARY_POSTFIX);
          emit("(");
          emitCommaSeparatedExpressions(node.callArguments());
          emit(")");
          if (Precedence.MEMBER < precedence) emit(")");
        }

        case NodeKind.SUPER_CALL {
        }

        case NodeKind.SEQUENCE {
          emitCommaSeparatedExpressions(node.children);
        }

        case NodeKind.CAST {
          emitExpression(node.castValue(), precedence);
        }

        case NodeKind.IMPLICIT_CAST {
          emitExpression(node.castValue(), precedence);
        }

        case NodeKind.LAMBDA {
          emit("function ");
          emitArguments(node.lambdaArguments());
          emit(" ");
          emitNode(node.lambdaBlock());
        }

        case NodeKind.DEFAULT {
        }

        case
          NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
          NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
          NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {

          OperatorInfo info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          bool isPostfix = info.precedence == Precedence.UNARY_POSTFIX;
          if (!isPostfix) emit(info.text);
          emitExpression(node.unaryValue(), info.precedence);
          if (isPostfix) emit(info.text);
          if (info.precedence < precedence) emit(")");
        }

        case
          NodeKind.ADD, NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND,
          NodeKind.ASSIGN_BITWISE_OR, NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE,
          NodeKind.ASSIGN_MULTIPLY, NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT,
          NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT, NodeKind.BITWISE_AND,
          NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR, NodeKind.DIVIDE, NodeKind.EQUAL,
          NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL, NodeKind.IN, NodeKind.LESS_THAN,
          NodeKind.LESS_THAN_OR_EQUAL, NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY,
          NodeKind.NOT_EQUAL, NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT,
          NodeKind.SUBTRACT {

          OperatorInfo info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          emitExpression(node.binaryLeft(), info.precedence);
          emit(" ".append(info.text).append(" "));
          emitExpression(node.binaryRight(), info.precedence);
          if (info.precedence < precedence) emit(")");
        }

        case NodeKind.INDEX {
          emitExpression(node.binaryLeft(), Precedence.MEMBER);
          emit("[");
          emitExpression(node.binaryRight(), Precedence.LOWEST);
          emit("]");
        }

        case NodeKind.ASSIGN_INDEX {
        }

        default {
          assert false;
        }
      }
    }
  }
}
