namespace js {
  class PatchContext {
    var lambdaCount = 0;
    var createdThisAlias = false;
    Node function = null;

    void setFunction(Node node) {
      function = node;
      createdThisAlias = false;
    }

    Node thisAlias() {
      if (!createdThisAlias) {
        createdThisAlias = true;
        function.functionBlock().insertChild(0, Node.createVariableCluster(Node.createError(),
          { Node.createVariable(Node.createName("$this"), null, Node.createThis()) }));
      }
      return Node.createName("$this");
    }
  }

  class Emitter : IEmitter {
    var indent = "";
    var currentLine = 0;
    var currentColumn = 0;
    var needExtends = false;
    var needMathImul = false;
    var isStartOfExpression = false;
    var generator = SourceMapGenerator();
    Source currentSource = null;
    CompilerOptions options;
    TypeCache cache;

    override List<Source> emitProgram(Node program) {
      patchNode(program, PatchContext());
      currentSource = Source(options.outputFile, "");
      var collector = Collector(program, .SORT_BY_INHERITANCE_AND_CONTAINMENT);

      // Emit helper functions
      if (needMathImul) {
        emit(
"var $imul = Math.imul || function(a, b) {
  var ah = a >>> 16, al = a & 0xFFFF;
  var bh = b >>> 16, bl = b & 0xFFFF;
  return al * bl + (ah * bl + al * bh << 16) | 0;
};
");
      }
      if (needExtends) {
        emit(
"function $extends(derived, base) {
  derived.prototype = Object.create(base.prototype);
  derived.prototype.constructor = derived;
}
");
      }

      // Emit types
      for (var i = 0; i < collector.typeSymbols.length; i++) {
        var type = collector.typeSymbols.get(i).type;
        if (type.isNamespace()) {
          if (!type.symbol.isImport()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          }
          continue;
        }
        if (!type.symbol.isImport()) {
          if (type.isEnum()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          } else {
            var constructor = type.constructor();
            if (constructor != null) {
              emitNode(constructor.symbol.node);
            }
          }
        }
        var members = type.members.values();
        for (var j = 0; j < members.length; j++) {
          var symbol = members.get(j).symbol;
          if (symbol.enclosingSymbol == type.symbol && symbol.node != null && symbol.kind.isFunction() && !symbol.kind.isConstructor()) {
            emitNode(symbol.node);
          }
        }
      }

      // Emit free functions
      for (var i = 0; i < collector.freeFunctionSymbols.length; i++) {
        emitNode(collector.freeFunctionSymbols.get(i).node);
      }

      // Emit top-level statements
      for (var i = 0; i < collector.topLevelStatements.length; i++) {
        emitNode(collector.topLevelStatements.get(i));
      }

      // Append the source map inline with the compiled output
      if (options.jsSourceMap) {
        currentSource.contents = currentSource.contents.append("/").append(
          "/# sourceMappingURL=data:application/json;base64,").append(
          encodeBase64(generator.toString()));
      }

      return { currentSource };
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        var range = node.range;
        if (range.source != null) {
          var location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      indent = indent.append("  ");
    }

    void decreaseIndent() {
      indent = indent.slice(2, indent.length);
    }

    void emit(string text) {
      if (options.jsSourceMap) {
        for (var i = 0; i < text.length; i++) {
          var c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents = currentSource.contents.append(text);
    }

    void emitNodes(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitExpression(nodes.get(i), Precedence.COMMA);
      }
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void emitChildren(Node node) {
      if (node.hasChildren()) {
        emitNodes(node.children);
      }
    }

    void recursiveEmitIfStatement(Node node) {
      emit("if (");
      emitExpression(node.ifTest(), Precedence.LOWEST);
      emit(") ");
      emitNode(node.ifTrue());
      var block = node.ifFalse();
      if (block != null) {
        emit(" else ");
        var statement = block.hasChildren() && block.children.length == 1 ? block.children.get(0) : null;
        if (statement != null && statement.kind == .IF) {
          addMapping(statement);
          recursiveEmitIfStatement(statement);
        } else {
          emitNode(block);
        }
      }
    }

    void emitNode(Node node) {
      isStartOfExpression = false;
      addMapping(node);

      switch (node.kind) {
        case .PROGRAM {
          emitChildren(node);
        }

        case .FILE {
          emitChildren(node.fileBlock());
        }

        case .BLOCK {
          emit("{\n");
          increaseIndent();
          emitChildren(node);
          decreaseIndent();
          emit(indent.append("}"));
        }

        case .CASE {
          var values = node.caseValues();
          var block = node.caseBlock();
          for (var i = 0; i < values.length; i++) {
            emit(indent.append("case "));
            emitExpression(values.get(i), Precedence.LOWEST);
            emit(":\n");
          }
          if (values.length == 0) {
            emit(indent.append("default:\n"));
          }
          increaseIndent();
          emitChildren(block);
          if (!block.blockAlwaysEndsWithReturn()) {
            emit(indent.append("break;\n"));
          }
          decreaseIndent();
        }

        case .VARIABLE_CLUSTER {
          var variables = node.clusterVariables();
          for (var i = 0; i < variables.length; i++) {
            var variable = variables.get(i);
            var isCompoundName = variable.symbol != null && hasCompoundName(variable.symbol);
            if ((variable.symbol == null || !variable.symbol.kind.isInstance()) && (!isCompoundName || variable.variableValue() != null)) {
              emit(indent);
              if (!isCompoundName) {
                emit("var ");
              }
              emitNode(variable);
              emit(";\n");
            }
          }
        }

        case .NAMESPACE {
          if (!hasCompoundName(node.symbol)) {
            emit("var ");
          }
          emit(indent.append(fullName(node.symbol)).append(" = {};\n"));
        }

        case .ENUM, .ENUM_FLAGS {
          var block = node.declarationBlock();
          if (!hasCompoundName(node.symbol)) {
            emit("var ");
          }
          if (options.optimize && !node.symbol.isImportOrExport()) {
            emit(indent.append(fullName(node.symbol)).append(" = {};\n")); // Remove this once extension methods are flattened into global scope
          } else {
            emit(indent.append(fullName(node.symbol)).append(" = {\n"));
            increaseIndent();
            for (var i = 0; i < block.children.length; i++) {
              var symbol = block.children.get(i).symbol;
              emit(indent.append(mangleName(symbol)).append(": ").append(symbol.enumValue.toString()).append(i == block.children.length - 1 ? "\n" : ",\n"));
            }
            decreaseIndent();
            emit(indent.append("};\n"));
          }
        }

        case .CONSTRUCTOR, .FUNCTION {
          var block = node.functionBlock();
          if (block == null) {
            return;
          }
          var isCompoundName = hasCompoundName(node.symbol);
          if (!isCompoundName) {
            emit(indent.append("function ").append(fullName(node.symbol)));
          } else {
            emit(indent.append(fullName(node.symbol)).append(" = function"));
          }
          emitArgumentVariables(node.functionArguments().children);
          emit(" ");
          emit("{\n");
          increaseIndent();
          emitChildren(block);
          decreaseIndent();
          emit(indent.append(isCompoundName ? "};\n" : "}\n"));
          if (node.kind == .CONSTRUCTOR) {
            Type type = node.symbol.enclosingSymbol.type;
            if (type.isClass() && type.baseClass() != null) {
              emit(indent.append("$extends(").append(fullName(type.symbol)).append(", ").append(fullName(type.baseClass().symbol)).append(");\n"));
            }
          }
        }

        case .VARIABLE {
          var value = node.variableValue();
          emit(node.symbol == null ? node.declarationName().asString() : fullName(node.symbol));
          if (value != null) {
            emit(" = ");
            emitExpression(value, Precedence.COMMA);
          }
        }

        case .IF {
          emit(indent);
          recursiveEmitIfStatement(node);
          emit("\n");
        }

        case .FOR {
          var setup = node.forSetup();
          var test = node.forTest();
          var update = node.forUpdate();
          emit(indent.append("for ("));
          if (setup != null) {
            if (setup.kind == .VARIABLE_CLUSTER) {
              emit("var ");
              emitCommaSeparatedNodes(setup.clusterVariables());
            } else {
              emitExpression(setup, Precedence.LOWEST);
            }
          }
          if (test != null) {
            emit("; ");
            emitExpression(test, Precedence.LOWEST);
          } else {
            emit(";");
          }
          if (update != null) {
            emit("; ");
            emitExpression(update, Precedence.LOWEST);
          } else {
            emit(";");
          }
          emit(") ");
          emitNode(node.forBlock());
          emit("\n");
        }

        case .FOR_EACH {
        }

        case .WHILE {
          emit(indent.append("while ("));
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(") ");
          emitNode(node.whileBlock());
          emit("\n");
        }

        case .DO_WHILE {
          emit(indent.append("do "));
          emitNode(node.whileBlock());
          emit(" while (");
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(");\n");
        }

        case .RETURN, .IMPLICIT_RETURN {
          var value = node.returnValue();
          emit(indent);
          if (value != null) {
            emit("return ");
            emitExpression(value, Precedence.LOWEST);
            emit(";\n");
          } else {
            emit("return;\n");
          }
        }

        case .BREAK {
          emit(indent.append("break;\n"));
        }

        case .CONTINUE {
          emit(indent.append("continue;\n"));
        }

        case .ASSERT {
          var value = node.assertValue();
          value.invertBooleanCondition(cache);
          if (value.kind != .FALSE && !options.optimize) {
            var couldBeFalse = value.kind != .TRUE;
            if (couldBeFalse) {
              emit(indent.append("if ("));
              emitExpression(value, Precedence.LOWEST);
              emit(") {\n");
              increaseIndent();
            }
            var text = node.range.toString().append(" (").append(node.range.locationString()).append(")");
            emit(indent.append("throw new Error(").append(quoteString(text, '"')).append(");\n"));
            if (couldBeFalse) {
              decreaseIndent();
              emit(indent.append("}\n"));
            }
          }
        }

        case .EXPRESSION {
          emit(indent);
          isStartOfExpression = true;
          emitExpression(node.expressionValue(), Precedence.LOWEST);
          emit(";\n");
        }

        case .SWITCH {
          emit(indent.append("switch ("));
          emitExpression(node.switchValue(), Precedence.LOWEST);
          emit(") {\n");
          emitNodes(node.switchCases());
          emit(indent.append("}\n"));
        }

        case .MODIFIER {
          emitNodes(node.modifierStatements());
        }

        case .PARAMETER, .USING_ALIAS, .ALIAS, .USING_NAMESPACE {
        }

        default {
          assert false;
        }
      }
    }

    void emitExpression(Node node, Precedence precedence) {
      var wasStartOfExpression = isStartOfExpression;
      isStartOfExpression = false;
      addMapping(node);

      switch (node.kind) {
        case .NAME {
          emit(node.symbol == null ? node.asString() : fullName(node.symbol));
        }

        case .TYPE {
          emit(fullName(node.type.symbol));
        }

        case .THIS {
          emit("this");
        }

        case .HOOK {
          if (Precedence.ASSIGN < precedence) emit("(");
          emitExpression(node.hookTest(), Precedence.LOGICAL_OR);
          emit(" ? ");
          emitExpression(node.hookTrue(), Precedence.ASSIGN);
          emit(" : ");
          emitExpression(node.hookFalse(), Precedence.ASSIGN);
          if (Precedence.ASSIGN < precedence) emit(")");
        }

        case .NULL {
          emit("null");
        }

        case .TRUE {
          emit("true");
        }

        case .FALSE {
          emit("false");
        }

        case .INT {
          emit(node.asInt().toString());
          if (node.parent.kind == .DOT) {
            emit(".");
          }
        }

        case .FLOAT, .DOUBLE {
          var text = node.asDouble().toString();
          emit(text);
          if (node.parent.kind == .DOT && text.indexOf(".") < 0) {
            emit(".");
          }
        }

        case .STRING {
          emit(quoteString(node.asString(), '"'));
        }

        case .INITIALIZER {
          emit("[");
          emitCommaSeparatedExpressions(node.initializerValues());
          emit("]");
        }

        case .DOT {
          emitExpression(node.dotTarget(), Precedence.MEMBER);
          emit(".");
          var name = node.dotName();
          emit(
            name.symbol == null ? name.asString() :
            name.symbol.kind.isInstance() ? mangleName(name.symbol) :
            fullName(name.symbol));
        }

        case .CALL {
          var value = node.callValue();
          if (value.kind.isType()) emit("new ");
          isStartOfExpression = wasStartOfExpression;
          emitExpression(value, Precedence.UNARY_POSTFIX);
          emit("(");
          emitCommaSeparatedExpressions(node.callArguments());
          emit(")");
        }

        case .SUPER_CALL {
          var arguments = node.superCallArguments();
          emit(fullName(node.symbol));
          emit(".call(this");
          for (var i = 0; i < arguments.length; i++) {
            emit(", ");
            emitExpression(arguments.get(i), Precedence.COMMA);
          }
          emit(")");
        }

        case .BIND {
          emitExpression(node.bindValue(), precedence);
        }

        case .SEQUENCE {
          if (Precedence.COMMA <= precedence) emit("(");
          isStartOfExpression = wasStartOfExpression;
          emitCommaSeparatedExpressions(node.children);
          if (Precedence.COMMA <= precedence) emit(")");
        }

        case .CAST, .IMPLICIT_CAST {
          isStartOfExpression = wasStartOfExpression;
          emitExpression(node.castValue(), precedence);
        }

        case .LAMBDA {
          if (wasStartOfExpression) emit("(");
          emit("function");
          emitArgumentVariables(node.lambdaArguments());
          emit(" ");
          emitNode(node.lambdaBlock());
          if (wasStartOfExpression) emit(")");
        }

        case .DEFAULT {
          if (node.type.isNumeric(cache)) emit("0");
          else if (node.type.isBool(cache)) emit("false");
          else if (node.type.isReference()) emit("null");
          else assert false; // TODO: Handle structs
        }

        case
          .NOT, .POSITIVE, .NEGATIVE, .COMPLEMENT,
          .PREFIX_INCREMENT, .PREFIX_DECREMENT,
          .POSTFIX_INCREMENT, .POSTFIX_DECREMENT {

          var value = node.unaryValue();
          var info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          var isPostfix = info.precedence == Precedence.UNARY_POSTFIX;
          if (!isPostfix) {
            emit(info.text);

            // Prevent "- -1" from becoming "--1"
            if (node.kind == .POSITIVE && (value.kind == .POSITIVE || value.kind == .PREFIX_INCREMENT) ||
                node.kind == .NEGATIVE && (value.kind == .NEGATIVE || value.kind == .PREFIX_DECREMENT || value.kind == NodeKind.INT && value.asInt() < 0)) {
              emit(" ");
            }
          }
          emitExpression(value, info.precedence);
          if (isPostfix) emit(info.text);
          if (info.precedence < precedence) emit(")");
        }

        case
          .ADD, .ASSIGN, .ASSIGN_ADD, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR, .ASSIGN_DIVIDE,
          .ASSIGN_MULTIPLY, .ASSIGN_REMAINDER, .ASSIGN_SHIFT_LEFT,
          .ASSIGN_SHIFT_RIGHT, .ASSIGN_SUBTRACT, .BITWISE_AND,
          .BITWISE_OR, .BITWISE_XOR, .DIVIDE, .EQUAL,
          .GREATER_THAN, .GREATER_THAN_OR_EQUAL, .IN, .LESS_THAN,
          .LESS_THAN_OR_EQUAL, .LOGICAL_AND, .LOGICAL_OR, .MULTIPLY,
          .NOT_EQUAL, .REMAINDER, .SHIFT_LEFT, .SHIFT_RIGHT,
          .SUBTRACT {

          var info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          emitExpression(node.binaryLeft(), (Precedence)(info.precedence + (int)(info.associativity == Associativity.RIGHT)));
          emit(node.kind == .EQUAL ? " === " : node.kind == .NOT_EQUAL ? " !== " : " ".append(info.text).append(" "));
          emitExpression(node.binaryRight(), (Precedence)(info.precedence + (int)(info.associativity == Associativity.LEFT)));
          if (info.precedence < precedence) emit(")");
        }

        case .INDEX {
          emitExpression(node.binaryLeft(), Precedence.MEMBER);
          emit("[");
          emitExpression(node.binaryRight(), Precedence.LOWEST);
          emit("]");
        }

        case .ASSIGN_INDEX {
        }

        default {
          assert false;
        }
      }
    }

    static bool alwaysConvertsOperandsToInt(NodeKind kind) {
      switch (kind) {
        case
          .BITWISE_OR, .BITWISE_AND, .BITWISE_XOR, .SHIFT_LEFT,
          .SHIFT_RIGHT, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_XOR, .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT {

          return true;
        }

        default {
          return false;
        }
      }
    }

    static bool isExpressionUsed(Node node) {
      assert node.kind.isExpression();
      var parent = node.parent;
      if (!parent.kind.isExpression()) {
        return false;
      }
      if (parent.kind == .SEQUENCE && (!isExpressionUsed(parent) || parent.children.indexOf(node) < parent.children.length - 1)) {
        return false;
      }
      return true;
    }

    void patchNode(Node node, PatchContext context) {
      switch (node.kind) {
        case .CLASS {
          if (!node.symbol.isImport() && node.symbol.type.baseClass() != null) {
            needExtends = true;
          }
        }

        case .CONSTRUCTOR {
          var superInitializer = node.superInitializer();
          var memberInitializers = node.memberInitializers();
          var block = node.functionBlock();
          var index = 0;
          if (superInitializer != null) {
            block.insertChild(index++, Node.createExpression(superInitializer.remove()));
          }
          if (memberInitializers != null) {
            for (var i = 0; i < memberInitializers.children.length; i++) {
              var child = memberInitializers.children.get(i);
              block.insertChild(index++, Node.createExpression(Node.createBinary(.ASSIGN, child.memberInitializerName().remove(), child.memberInitializerValue().remove())));
            }
          }
          context.setFunction(node);
        }

        case .FUNCTION {
          context.setFunction(node);
        }

        case .BIND {
          if (node.symbol.kind == .INSTANCE_FUNCTION) {
            var function = node.bindValue();
            Node target;
            Node name;
            if (function.kind == .DOT) {
              target = function.dotTarget().remove();
              name = function.dotName().remove();
            } else {
              assert function.kind == .NAME;
              target = Node.createThis();
              name = function.remove();
            }
            if (isSimpleNameAccess(target)) {
              node.become(Node.createCall(Node.createDot(Node.createDot(target.clone(), name), Node.createName("bind")), { target }).withRange(node.range));
            } else {
              var temporaryName = Node.createName("$temp");
              node.become(Node.createLet(
                Node.createVariable(temporaryName.clone(), null, target),
                Node.createCall(Node.createDot(Node.createDot(temporaryName.clone(), name), Node.createName("bind")), { temporaryName })).withRange(node.range));
            }
          }
        }

        case .THIS {
          if (context.lambdaCount > 0) {
            node.become(context.thisAlias());
          }
        }

        case .NAME {
          if (node.symbol != null && node.symbol.kind.isInstance() && node.isNameExpression()) {
            node.become(Node.createDot(Node.createThis(), node.clone()));
          }
        }

        case .CAST {
          var value = node.castValue();

          // Cast to bool
          if (node.type.isBool(cache) && !value.type.isBool(cache)) {
            node.become(Node.createUnary(.NOT, value.remove()).withRange(node.range).withType(node.type));
          }

          // Cast to int
          else if (node.type.isInt(cache) && !value.type.isInteger(cache) && !alwaysConvertsOperandsToInt(node.parent.kind)) {
            node.become(Node.createBinary(.BITWISE_OR, value.remove(), Node.createInt(0)).withRange(node.range).withType(node.type));
          }

          // Cast to float/double
          else if (node.type.isReal(cache) && !value.type.isNumeric(cache)) {
            node.become(Node.createUnary(.POSITIVE, value.remove()).withRange(node.range).withType(node.type));
          }
        }

        case .PREFIX_INCREMENT, .PREFIX_DECREMENT, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT {
          if (node.type.isInt(cache)) {
            var isPostfix = node.kind == .POSTFIX_INCREMENT || node.kind == .POSTFIX_DECREMENT;
            var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
            var result = createBinaryIntAssignment(context, isIncrement ? .ADD : .SUBTRACT, node.unaryValue().remove(), Node.createInt(1));
            if (isPostfix && isExpressionUsed(node)) {
              result = createBinaryInt(isIncrement ? .SUBTRACT : .ADD, result, Node.createInt(1));
            }
            node.become(result.withRange(node.range).withType(node.type));
          }
        }

        case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER {
          if (node.type.isInt(cache) && (node.kind == .MULTIPLY || !alwaysConvertsOperandsToInt(node.parent.kind))) {
            node.become(createBinaryInt(node.kind, node.binaryLeft().remove(), node.binaryRight().remove()).withRange(node.range));
          }
        }

        case .ASSIGN_ADD, .ASSIGN_SUBTRACT, .ASSIGN_MULTIPLY, .ASSIGN_DIVIDE, .ASSIGN_REMAINDER {
          if (node.type.isInt(cache)) {
            var isPostfix = node.kind == .POSTFIX_INCREMENT || node.kind == .POSTFIX_DECREMENT;
            var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
            var left = node.binaryLeft();
            var right = node.binaryRight();
            NodeKind kind =
              node.kind == .ASSIGN_ADD ? .ADD :
              node.kind == .ASSIGN_SUBTRACT ? .SUBTRACT :
              node.kind == .ASSIGN_MULTIPLY ? .MULTIPLY :
              node.kind == .ASSIGN_DIVIDE ? .DIVIDE :
              .REMAINDER;
            node.become(createBinaryIntAssignment(context, kind, left.remove(), right.remove()).withRange(node.range));
          }
        }

        case .LAMBDA {
          context.lambdaCount++;
        }
      }

      if (node.kind == .LET) {
        var value = node.letValue();
        var variable = node.letVariable();
        node.become(Node.createCall(Node.createLambda({ variable.remove() }, Node.createBlock({ Node.createReturn(value.remove()) })), { variable.variableValue().remove() }));
      }

      if (node.hasChildren()) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children.get(i);
          if (child != null) {
            patchNode(child, context);
          }
        }
      }

      switch (node.kind) {
        case .LAMBDA {
          context.lambdaCount--;
        }

        case .CONSTRUCTOR, .FUNCTION {
          context.setFunction(null);
        }
      }
    }

    Node createBinaryInt(NodeKind kind, Node left, Node right) {
      if (kind == .MULTIPLY) {
        needMathImul = true;
        return Node.createCall(Node.createName("$imul"), { left, right }).withType(cache.intType);
      }
      return Node.createBinary(.BITWISE_OR, Node.createBinary(kind, left, right).withType(cache.intType), Node.createInt(0).withType(cache.intType)).withType(cache.intType);
    }

    static bool isSimpleNameAccess(Node node) {
      return node.kind == .NAME || node.kind == .THIS || node.kind == .DOT && isSimpleNameAccess(node.dotTarget());
    }

    Node createBinaryIntAssignment(PatchContext context, NodeKind kind, Node left, Node right) {
      if (isSimpleNameAccess(left)) {
        return Node.createBinary(.ASSIGN, left.clone(), createBinaryInt(kind, left, right));
      }
      assert left.kind == .DOT;
      var target = left.dotTarget().remove();
      var temporaryName = Node.createName("$temp");
      var dot = Node.createDot(temporaryName, left.dotName().remove());
      return Node.createLet(
        Node.createVariable(temporaryName.clone(), null, target),
        Node.createBinary(.ASSIGN, dot, createBinaryInt(kind, dot.clone(), right)).withType(cache.intType)).withType(cache.intType);
    }

    bool hasCompoundName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      return enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace() && (
        !symbol.kind.isConstructor() || hasCompoundName(enclosingSymbol));
    }

    static StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result.set("arguments", true);
      result.set("call", true);
      result.set("apply", true);
      result.set("constructor", true);
      result.set("function", true);
      result.set("throw", true);
      result.set("this", true);
      return result;
    }

    static var isKeyword = createIsKeyword();

    string mangleName(Symbol symbol) {
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (symbol.kind.isConstructor()) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (isKeyword.has(symbol.name)) {
        return "$".append(symbol.name);
      }
      return symbol.name;
    }

    string fullName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      if (enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace()) {
        var enclosingName = fullName(enclosingSymbol);
        if (symbol.kind.isConstructor()) {
          return enclosingName;
        }
        if (symbol.kind.isInstance()) {
          enclosingName = enclosingName.append(".prototype");
        }
        return enclosingName.append(".").append(mangleName(symbol));
      }
      return mangleName(symbol);
    }
  }
}
