namespace js {
  enum ClusterState {
    NONE,
    VAR_CHAIN,
    COMPOUND_NAME,
  }

  enum BlockMode {
    MUST_KEEP_BRACES,
    CAN_OMIT_BRACES,
  }

  class Emitter : IEmitter {
    static StringMap<bool> isKeyword;
    var newline = "\n";
    var space = " ";
    var indent = "";
    var currentLine = 0;
    var currentColumn = 0;
    var needsSemicolon = false;
    var isStartOfExpression = false;
    var generator = SourceMapGenerator();
    Source currentSource = null;
    Patcher patcher = null;
    CompilerOptions options;
    TypeCache cache;

    // Numbers normally need to be wrapped in parentheses when toString() is
    // called on them because "1.toString()" is a syntax error in JavaScript.
    // However, toString() can be called implicitly as part of a string binary
    // + operation. This variable prevents wrapping in parentheses when the
    // toString() call has been elided.
    Node toStringTarget = null;

    override void patchProgram(Node program) {
      if (options.jsMinify) {
        newline = "";
        space = "";
      }

      patcher = Patcher(options, cache);
      patcher.patchNode(program);
    }

    override List<Source> emitProgram(Node program) {
      // Ensure static variables exist
      if (isKeyword == null) {
        isKeyword = createIsKeyword();
      }

      // Collect all interesting nodes for easy access
      var collector = Collector(program, .SORT_BY_INHERITANCE_AND_CONTAINMENT);
      currentSource = Source(options.outputFile, "");

      // Prepend inputs
      for (var i = 0; i < options.prepend.length; i++) {
        appendSource(options.prepend.get(i));
      }

      // Emit helper functions
      if (patcher.needMathImul) {
        emit(
"var $imul = Math.imul || function(a, b) {
  var ah = a >>> 16, al = a & 0xFFFF;
  var bh = b >>> 16, bl = b & 0xFFFF;
  return al * bl + (ah * bl + al * bh << 16) | 0;
};
");
      }
      if (patcher.needExtends) {
        emit(
"function $extends(derived, base) {
  derived.prototype = Object.create(base.prototype);
  derived.prototype.constructor = derived;
}
");
      }

      // Emit types
      for (var i = 0; i < collector.typeSymbols.length; i++) {
        var type = collector.typeSymbols.get(i).type;
        if (type.isNamespace()) {
          if (!type.symbol.isImport()) {
            maybeEmitMinifedNewline();
            emitNode(type.symbol.node.firstNonExtensionSibling());
          }
          continue;
        }
        if (!type.symbol.isImport()) {
          if (type.isEnum()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          } else {
            var constructor = type.constructor();
            if (constructor != null) {
              emitNode(constructor.symbol.node);
            }
          }
        }
        var members = type.members.values();
        for (var j = 0; j < members.length; j++) {
          var symbol = members.get(j).symbol;
          if (symbol.enclosingSymbol == type.symbol && symbol.node != null && symbol.kind.isFunction() && !symbol.kind.isConstructor()) {
            emitNode(symbol.node);
          }
        }
      }

      // Emit free functions
      for (var i = 0; i < collector.freeFunctionSymbols.length; i++) {
        emitNode(collector.freeFunctionSymbols.get(i).node);
      }

      // Emit free variables
      for (var i = 0; i < collector.freeVariableSymbols.length; i++) {
        emitNode(collector.freeVariableSymbols.get(i));
      }

      // Make sure the file ends with a newline for ease of use with external
      // tools even when minifying (the "cat" terminal command, for example)
      if (currentColumn > 0) {
        emit("\n");
      }

      // Append inputs
      for (var i = 0; i < options.append.length; i++) {
        appendSource(options.append.get(i));
      }

      // Create the source map
      if (options.jsSourceMap) {
        // Obfuscate the sourceMappingURL so it's not incorrectly picked up as
        // the sourceMappingURL for the compiled JavaScript compiler file
        currentSource.contents = currentSource.contents + "/";

        // Append the source map inline with the compiled output
        if (options.outputFile == "") {
          currentSource.contents = currentSource.contents +
            "/# sourceMappingURL=data:application/json;base64," +
            encodeBase64(generator.toString()) + "\n";
        }

        // Create the source map as another file alongside the output
        else {
          string name = options.outputFile + ".map";
          currentSource.contents = currentSource.contents +
            "/# sourceMappingURL=" + splitPath(name).entry + "\n";
          return [currentSource, Source(name, generator.toString())];
        }
      }

      return [currentSource];
    }

    void appendSource(Source source) {
      if (currentColumn > 0) {
        emit("\n");
      }
      currentSource.contents += source.contents;
      if (options.jsSourceMap) {
        for (var i = 0, n = source.lineCount(); i < n; i++) {
          generator.addMapping(source, i, 0, currentLine++, 0);
        }
      }
      if (source.contents.codeUnitAt(source.contents.length - 1) != '\n') {
        emit("\n");
      }
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        var range = node.range;
        if (range.source != null) {
          var location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      if (!options.jsMinify) {
        indent += "  ";
      }
    }

    void decreaseIndent() {
      if (!options.jsMinify) {
        indent = indent.slice(2, indent.length);
      }
    }

    void emit(string text) {
      if (options.jsMinify || options.jsSourceMap) {
        for (var i = 0; i < text.length; i++) {
          var c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents += text;
    }

    // Lots of text editors choke up on long lines, so add a newline every now
    // and then for usability's sake
    void maybeEmitMinifedNewline() {
      if (newline == "" && currentColumn > 1024) {
        emit("\n");
      }
    }

    void emitSemicolonAfterStatement() {
      if (!options.jsMinify) {
        emit(";\n");
      } else {
        needsSemicolon = true;
      }
    }

    void emitSemicolonIfNeeded() {
      if (needsSemicolon) {
        emit(";");
        needsSemicolon = false;
      }
    }

    void emitStatements(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        emitSemicolonIfNeeded();
        maybeEmitMinifedNewline();
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (i > 0) emit("," + space);
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (i > 0) {
          emit("," + space);
          maybeEmitMinifedNewline();
        }
        emitExpression(nodes.get(i), .COMMA);
      }
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void recursiveEmitIfStatement(Node node) {
      var trueBlock = node.ifTrue();
      var falseBlock = node.ifFalse();
      var trueStatement = trueBlock.singleStatement();
      emit("if" + space + "(");
      emitExpression(node.ifTest(), .LOWEST);
      emit(")" + space);

      // Make sure to always keep braces to avoid the dangling "else" case
      emitBlock(trueBlock, falseBlock != null && trueStatement != null && trueStatement.kind == .IF ? .MUST_KEEP_BRACES : .CAN_OMIT_BRACES);

      if (falseBlock != null) {
        emitSemicolonIfNeeded();
        emit(space + "else ");
        var falseStatement = falseBlock.singleStatement();
        if (falseStatement != null && falseStatement.kind == .IF) {
          addMapping(falseStatement);
          recursiveEmitIfStatement(falseStatement);
        } else {
          emitBlock(falseBlock, .CAN_OMIT_BRACES);
        }
      }
    }

    void emitNode(Node node) {
      isStartOfExpression = false;
      addMapping(node);

      // Separating the case bodies into separate functions makes the JavaScript JIT go faster
      switch (node.kind) {
        case .CASE { emitCase(node); }
        case .VARIABLE_CLUSTER { emitVariableCluster(node); }
        case .NAMESPACE { emitNamespace(node); }
        case .ENUM, .ENUM_FLAGS { emitEnum(node); }
        case .CONSTRUCTOR, .FUNCTION { emitFunction(node); }
        case .VARIABLE { emitVariable(node); }
        case .IF { emitIf(node); }
        case .FOR { emitFor(node); }
        case .WHILE { emitWhile(node); }
        case .DO_WHILE { emitDoWhile(node); }
        case .RETURN, .IMPLICIT_RETURN { emitReturn(node); }
        case .BREAK { emitBreak(node); }
        case .CONTINUE { emitContinue(node); }
        case .ASSERT { emitAssert(node); }
        case .EXPRESSION { emitExpressionStatement(node); }
        case .SWITCH { emitSwitch(node); }
        case .MODIFIER { emitModifier(node); }
        case .PARAMETER, .ALIAS, .USING {}
        default { assert false; }
      }
    }

    void emitBlock(Node node, BlockMode mode) {
      var shouldMinify = mode == .CAN_OMIT_BRACES && options.jsMinify;
      addMapping(node);
      if (shouldMinify && !node.hasChildren()) {
        emit(";");
      } else if (shouldMinify && node.children.length == 1) {
        emitNode(node.children.get(0));
      } else {
        emit("{" + newline);
        if (node.hasChildren()) {
          increaseIndent();
          emitStatements(node.children);
          decreaseIndent();
        }
        emit(indent + "}");
        needsSemicolon = false;
      }
    }

    void emitCase(Node node) {
      var values = node.caseValues();
      var block = node.caseBlock();
      emitSemicolonIfNeeded();
      for (var i = 0; i < values.length; i++) {
        emit(indent + "case ");
        emitExpression(values.get(i), .LOWEST);
        emit(":" + newline);
        maybeEmitMinifedNewline();
      }
      if (values.length == 0) {
        emit(indent + "default:" + newline);
      }
      increaseIndent();
      if (block.hasChildren()) {
        emitStatements(block.children);
      }
      if (!block.blockAlwaysEndsWithReturn() && (!options.jsMinify || !node.isLastChild())) {
        emitSemicolonIfNeeded();
        emit(indent + "break");
        emitSemicolonAfterStatement();
      }
      decreaseIndent();
    }

    void emitVariableCluster(Node node) {
      var variables = node.clusterVariables();
      var state = ClusterState.NONE;
      for (var i = 0; i < variables.length; i++) {
        var variable = variables.get(i);
        var symbol = variable.symbol;
        var isCompoundName = symbol != null && hasCompoundName(symbol);
        if (symbol != null && (symbol.kind.isInstance() || symbol.isImport()) || isCompoundName && variable.variableValue() == null) {
          continue;
        }
        emitSemicolonIfNeeded();
        if (isCompoundName) {
          if (state == .VAR_CHAIN) {
            emit(";" + newline);
          }
          state = .COMPOUND_NAME;
          emit(indent);
        } else {
          if (state != .VAR_CHAIN) {
            if (state == .COMPOUND_NAME) {
              emit(";" + newline);
            }
            emit(indent + "var ");
            state = .VAR_CHAIN;
          } else {
            emit("," + space);
            maybeEmitMinifedNewline();
          }
        }
        emitNode(variable);
      }
      if (state != .NONE) {
        emit(";" + newline);
      }
    }

    void emitNamespace(Node node) {
      emitSemicolonIfNeeded();
      if (!hasCompoundName(node.symbol)) {
        emit("var ");
      }
      emit(indent + fullName(node.symbol) + space + "=" + space + "{}");
      emitSemicolonAfterStatement();
    }

    void emitEnum(Node node) {
      var block = node.declarationBlock();
      if (options.foldAllConstants && !node.symbol.isImportOrExport()) {
        return;
      }
      emitSemicolonIfNeeded();
      if (!hasCompoundName(node.symbol)) {
        emit("var ");
      }
      emit(indent + fullName(node.symbol) + space + "=" + space + "{" + newline);
      increaseIndent();
      for (var i = 0; i < block.children.length; i++) {
        var symbol = block.children.get(i).symbol;
        emit(indent + mangleName(symbol) + ":" + space + symbol.constant.asInt());
        if (i != block.children.length - 1) {
          emit("," + newline);
          maybeEmitMinifedNewline();
        } else {
          emit(newline);
        }
      }
      decreaseIndent();
      emit(indent + "}");
      emitSemicolonAfterStatement();
    }

    void emitFunction(Node node) {
      var block = node.functionBlock();
      var symbol = node.symbol;
      if (block == null) {
        return;
      }
      var isCompoundName = hasCompoundName(symbol);
      emitSemicolonIfNeeded();
      if (!isCompoundName) {
        emit(indent + "function " + fullName(symbol));
      } else {
        emit(indent + fullName(symbol) + space + "=" + space + "function");
      }
      emitArgumentVariables(node.functionArguments().children);
      emit(space);
      emitBlock(block, .MUST_KEEP_BRACES);
      if (isCompoundName) emitSemicolonAfterStatement();
      else emit(newline);
      if (node.kind == .CONSTRUCTOR) {
        var type = symbol.enclosingSymbol.type;
        if (type.isClass() && type.baseClass() != null) {
          emitSemicolonIfNeeded();
          emit(indent + "$extends(" + fullName(type.symbol) + "," + space + fullName(type.baseClass().symbol) + ")");
          emitSemicolonAfterStatement();
        }
      }
    }

    void emitVariable(Node node) {
      var value = node.variableValue();
      emit(node.symbol == null ? node.declarationName().asString() : fullName(node.symbol));
      if (value != null) {
        emit(space + "=" + space);
        emitExpression(value, .COMMA);
      }
    }

    void emitIf(Node node) {
      emit(indent);
      recursiveEmitIfStatement(node);
      emit(newline);
    }

    void emitFor(Node node) {
      var setup = node.forSetup();
      var test = node.forTest();
      var update = node.forUpdate();
      emit(indent + "for" + space + "(");
      if (setup != null) {
        if (setup.kind == .VARIABLE_CLUSTER) {
          emit("var ");
          emitCommaSeparatedNodes(setup.clusterVariables());
        } else {
          emitExpression(setup, .LOWEST);
        }
      }
      if (test != null) {
        emit(";" + space);
        emitExpression(test, .LOWEST);
      } else {
        emit(";");
      }
      if (update != null) {
        emit(";" + space);
        emitExpression(update, .LOWEST);
      } else {
        emit(";");
      }
      emit(")" + space);
      emitBlock(node.forBlock(), .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitWhile(Node node) {
      emit(indent + "while" + space + "(");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")" + space);
      emitBlock(node.whileBlock(), .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitDoWhile(Node node) {
      emit(indent + "do ");
      emitBlock(node.whileBlock(), .CAN_OMIT_BRACES);
      emit(space + "while" + space + "(");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")");
      emitSemicolonAfterStatement();
    }

    void emitReturn(Node node) {
      var value = node.returnValue();
      emit(indent);
      if (value != null) {
        emit("return ");
        emitExpression(value, .LOWEST);
      } else {
        emit("return");
      }
      emitSemicolonAfterStatement();
    }

    void emitBreak(Node node) {
      emit(indent + "break");
      emitSemicolonAfterStatement();
    }

    void emitContinue(Node node) {
      emit(indent + "continue");
      emitSemicolonAfterStatement();
    }

    void emitAssert(Node node) {
      var value = node.assertValue();
      value.invertBooleanCondition(cache);
      if (!value.isFalse()) {
        var couldBeFalse = !value.isTrue();
        if (couldBeFalse) {
          emit(indent + "if" + space + "(");
          emitExpression(value, .LOWEST);
          emit(")");
          if (!options.jsMinify) {
            emit(" {\n");
            increaseIndent();
          }
        }
        var text = node.range + " (" + node.range.locationString() + ")";
        emit(indent + "throw new Error(" + quoteString(text, '"') + ")");
        emitSemicolonAfterStatement();
        if (couldBeFalse && !options.jsMinify) {
          decreaseIndent();
          emit(indent + "}\n");
        }
      }
    }

    void emitExpressionStatement(Node node) {
      emit(indent);
      isStartOfExpression = true;
      emitExpression(node.expressionValue(), .LOWEST);
      emitSemicolonAfterStatement();
    }

    void emitSwitch(Node node) {
      emit(indent + "switch" + space + "(");
      emitExpression(node.switchValue(), .LOWEST);
      emit(")" + space + "{" + newline);
      emitStatements(node.switchCases());
      emit(indent + "}" + newline);
      needsSemicolon = false;
    }

    void emitModifier(Node node) {
      emitStatements(node.modifierStatements());
    }

    void emitExpression(Node node, Precedence precedence) {
      var wasStartOfExpression = isStartOfExpression;
      isStartOfExpression = false;
      addMapping(node);

      switch (node.kind) {
        case .NAME { emit(node.symbol == null ? node.asString() : fullName(node.symbol)); }
        case .TYPE { emit(fullName(node.type.symbol)); }
        case .THIS { emit("this"); }
        case .HOOK { emitHook(node, precedence); }
        case .NULL { emit("null"); }
        case .BOOL { emitBool(node); }
        case .INT { emitInt(node); }
        case .FLOAT, .DOUBLE { emitDouble(node); }
        case .STRING { emit(quoteString(node.asString(), '"')); }
        case .LIST { emitList(node); }
        case .DOT { emitDot(node); }
        case .CALL { isStartOfExpression = wasStartOfExpression; emitCall(node); }
        case .SUPER_CALL { emitSuperCall(node); }
        case .SEQUENCE { isStartOfExpression = wasStartOfExpression; emitSequence(node, precedence); }
        case .LAMBDA { emitLambda(node, wasStartOfExpression); }
        case .UNTYPED { emitExpression(node.untypedValue(), precedence); }
        case .INDEX { emitIndex(node, precedence); }
        case .ASSIGN_INDEX { emitTertiary(node, precedence); }
        case .CAST, .IMPLICIT_CAST { isStartOfExpression = wasStartOfExpression; emitExpression(node.castValue(), precedence); }

        case
          .NOT, .POSITIVE, .NEGATIVE, .COMPLEMENT,
          .PREFIX_INCREMENT, .PREFIX_DECREMENT,
          .POSTFIX_INCREMENT, .POSTFIX_DECREMENT {
          emitUnary(node, precedence);
        }

        case
          .ADD, .ASSIGN, .ASSIGN_ADD, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR, .ASSIGN_DIVIDE,
          .ASSIGN_MULTIPLY, .ASSIGN_REMAINDER, .ASSIGN_SHIFT_LEFT,
          .ASSIGN_SHIFT_RIGHT, .ASSIGN_SUBTRACT, .BITWISE_AND,
          .BITWISE_OR, .BITWISE_XOR, .DIVIDE, .EQUAL, .GREATER_THAN,
          .GREATER_THAN_OR_EQUAL, .IN, .LESS_THAN, .LESS_THAN_OR_EQUAL,
          .LOGICAL_AND, .LOGICAL_OR, .MULTIPLY, .NOT_EQUAL, .REMAINDER,
          .SHIFT_LEFT, .SHIFT_RIGHT, .SUBTRACT {
          emitBinary(node, precedence);
        }

        default {
          assert false;
        }
      }
    }

    void emitHook(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.hookTest(), .LOGICAL_OR);
      emit(space + "?" + space);
      emitExpression(node.hookTrue(), .ASSIGN);
      emit(space + ":" + space);
      emitExpression(node.hookFalse(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    void emitBool(Node node) {
      if (options.jsMangle) {
        emit(node.asBool() ? "!0" : "!1");
      } else {
        emit(node.asBool() ? "true" : "false");
      }
    }

    void emitInt(Node node) {
      var wrap = node.parent.kind == .DOT && node != toStringTarget;
      if (wrap) emit("(");
      emit(node.asInt().toString());
      if (wrap) emit(")");
    }

    void emitDouble(Node node) {
      var wrap = node.parent.kind == .DOT && node != toStringTarget;
      if (wrap) emit("(");
      emit(node.asDouble().toString());
      if (wrap) emit(")");
    }

    void emitList(Node node) {
      emit("[");
      emitCommaSeparatedExpressions(node.listValues());
      emit("]");
    }

    void emitDot(Node node) {
      emitExpression(node.dotTarget(), .MEMBER);
      emit(".");
      var name = node.dotName();
      emit(
        name.symbol == null ? name.asString() :
        name.symbol.kind.isInstance() ? mangleName(name.symbol) :
        fullName(name.symbol));
    }

    void emitCall(Node node) {
      var value = node.callValue();
      if (value.kind.isType()) emit("new ");
      emitExpression(value, .UNARY_POSTFIX);
      emit("(");
      emitCommaSeparatedExpressions(node.callArguments());
      emit(")");
    }

    void emitSuperCall(Node node) {
      var arguments = node.superCallArguments();
      emit(fullName(node.symbol));
      emit(".call(this");
      for (var i = 0; i < arguments.length; i++) {
        emit(", ");
        emitExpression(arguments.get(i), .COMMA);
      }
      emit(")");
    }

    void emitSequence(Node node, Precedence precedence) {
      if (.COMMA <= precedence) emit("(");
      emitCommaSeparatedExpressions(node.children);
      if (.COMMA <= precedence) emit(")");
    }

    void emitLambda(Node node, bool wasStartOfExpression) {
      if (wasStartOfExpression) emit("(");
      emit("function");
      emitArgumentVariables(node.lambdaArguments());
      emit(space);
      emitBlock(node.lambdaBlock(), .MUST_KEEP_BRACES);
      if (wasStartOfExpression) emit(")");
    }

    void emitUnary(Node node, Precedence precedence) {
      var value = node.unaryValue();
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var isPostfix = info.precedence == .UNARY_POSTFIX;
      if (!isPostfix) {
        emit(info.text);

        // Prevent "- -1" from becoming "--1"
        if (node.kind == .POSITIVE && (value.kind == .POSITIVE || value.kind == .PREFIX_INCREMENT) ||
            node.kind == .NEGATIVE && (value.kind == .NEGATIVE || value.kind == .PREFIX_DECREMENT || value.kind == .INT && value.asInt() < 0)) {
          emit(" ");
        }
      }
      emitExpression(value, info.precedence);
      if (isPostfix) emit(info.text);
      if (info.precedence < precedence) emit(")");
    }

    bool isToStringCall(Node node) {
      if (node.kind == .CALL) {
        var value = node.callValue();
        return value.kind == .DOT && value.symbol != null && value.symbol.name == "toString" && node.callArguments().length == 0;
      }
      return false;
    }

    void emitBinary(Node node, Precedence precedence) {
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var left = node.binaryLeft();
      var right = node.binaryRight();
      var kind = node.kind;

      // Special case adding a string with the result of calling toString()
      // since the JavaScript runtime will automatically call toString()
      if (kind == .ADD) {
        if (left.type != null && left.type.isString(cache) && isToStringCall(right)) {
          right = right.callValue().dotTarget();
        } else if (right.type != null && right.type.isString(cache) && isToStringCall(left)) {
          left = left.callValue().dotTarget();
        }
      }

      toStringTarget = left;
      emitExpression(left, info.precedence.incrementIfRightAssociative(info.associativity));
      emit(kind == .IN ? " in " : space + (kind == .EQUAL ? "===" : kind == .NOT_EQUAL ? "!==" : info.text) + space);

      // Prevent "x - -1" from becoming "x--1"
      if (space == "" && (
          kind == .ADD && (right.kind == .POSITIVE || right.kind == .PREFIX_INCREMENT) ||
          kind == .SUBTRACT && (right.kind == .NEGATIVE || right.kind == .PREFIX_DECREMENT || right.kind == .INT && right.asInt() < 0))) {
        emit(" ");
      }

      toStringTarget = right;
      emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity));
      if (info.precedence < precedence) emit(")");
    }

    void emitIndex(Node node, Precedence precedence) {
      emitExpression(node.binaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.binaryRight(), .LOWEST);
      emit("]");
    }

    void emitTertiary(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.tertiaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.tertiaryMiddle(), .LOWEST);
      emit("]" + space + "=" + space);
      emitExpression(node.tertiaryRight(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    static bool hasCompoundName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      return enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace() && (
        !symbol.kind.isConstructor() || hasCompoundName(enclosingSymbol));
    }

    static StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result.set("apply", true);
      result.set("arguments", true);
      result.set("call", true);
      result.set("constructor", true);
      result.set("double", true);
      result.set("float", true);
      result.set("function", true);
      result.set("in", true);
      result.set("int", true);
      result.set("this", true);
      result.set("throw", true);
      return result;
    }

    static string mangleName(Symbol symbol) {
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (symbol.kind.isConstructor()) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (isKeyword.has(symbol.name)) {
        return "$" + symbol.name;
      }
      return symbol.name;
    }

    static string fullName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      if (enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace()) {
        var enclosingName = fullName(enclosingSymbol);
        if (symbol.kind.isConstructor()) {
          return enclosingName;
        }
        if (symbol.kind.isInstance()) {
          enclosingName += ".prototype";
        }
        return enclosingName + "." + mangleName(symbol);
      }
      return mangleName(symbol);
    }
  }
}
