namespace js {
  enum BlockMode {
    MUST_KEEP_BRACES,
    CAN_OMIT_BRACES,
  }

  class PatchContext {
    var lambdaCount = 0;
    var createdThisAlias = false;
    Node function = null;

    void setFunction(Node node) {
      function = node;
      createdThisAlias = false;
    }

    Node thisAlias() {
      if (!createdThisAlias) {
        createdThisAlias = true;
        function.functionBlock().insertChild(0, Node.createVariableCluster(Node.createError(),
          [Node.createVariable(Node.createName("$this"), null, Node.createThis())]));
      }
      return Node.createName("$this");
    }
  }

  class Emitter : IEmitter {
    static StringMap<bool> isKeyword;
    var newline = "\n";
    var space = " ";
    var indent = "";
    var currentLine = 0;
    var currentColumn = 0;
    var needExtends = false;
    var needMathImul = false;
    var isStartOfExpression = false;
    var generator = SourceMapGenerator();
    Source currentSource = null;
    CompilerOptions options;
    TypeCache cache;

    // Numbers normally need to be wrapped in parentheses when toString() is
    // called on them because "1.toString()" is a syntax error in JavaScript.
    // However, toString() can be called implicitly as part of a string binary
    // + operation. This variable prevents wrapping in parentheses when the
    // toString() call has been elided.
    Node toStringTarget = null;

    override void patchProgram(Node program) {
      patchNode(program, PatchContext());
    }

    override List<Source> emitProgram(Node program) {
      if (isKeyword == null) {
        isKeyword = createIsKeyword();
      }
      if (options.jsMinify) {
        newline = "";
        space = "";
      }

      currentSource = Source(options.outputFile, "");
      var collector = Collector(program, .SORT_BY_INHERITANCE_AND_CONTAINMENT);

      // Prepend inputs
      for (var i = 0; i < options.prepend.length; i++) {
        appendSource(options.prepend.get(i));
      }

      // Emit helper functions
      if (needMathImul) {
        emit(
"var $imul = Math.imul || function(a, b) {
  var ah = a >>> 16, al = a & 0xFFFF;
  var bh = b >>> 16, bl = b & 0xFFFF;
  return al * bl + (ah * bl + al * bh << 16) | 0;
};
");
      }
      if (needExtends) {
        emit(
"function $extends(derived, base) {
  derived.prototype = Object.create(base.prototype);
  derived.prototype.constructor = derived;
}
");
      }

      // Emit types
      for (var i = 0; i < collector.typeSymbols.length; i++) {
        var type = collector.typeSymbols.get(i).type;
        if (type.isNamespace()) {
          if (!type.symbol.isImport()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          }
          continue;
        }
        if (!type.symbol.isImport()) {
          if (type.isEnum()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          } else {
            var constructor = type.constructor();
            if (constructor != null) {
              emitNode(constructor.symbol.node);
            }
          }
        }
        var members = type.members.values();
        for (var j = 0; j < members.length; j++) {
          var symbol = members.get(j).symbol;
          if (symbol.enclosingSymbol == type.symbol && symbol.node != null && symbol.kind.isFunction() && !symbol.kind.isConstructor()) {
            emitNode(symbol.node);
          }
        }
      }

      // Emit free functions
      for (var i = 0; i < collector.freeFunctionSymbols.length; i++) {
        emitNode(collector.freeFunctionSymbols.get(i).node);
      }

      // Emit top-level statements
      for (var i = 0; i < collector.topLevelStatements.length; i++) {
        emitNode(collector.topLevelStatements.get(i));
      }

      // Append inputs
      for (var i = 0; i < options.append.length; i++) {
        appendSource(options.append.get(i));
      }

      // Create the source map
      if (options.jsSourceMap) {
        // Obfuscate the sourceMappingURL so it's not incorrectly picked up as
        // the sourceMappingURL for the compiled JavaScript compiler file
        currentSource.contents = currentSource.contents + "/";

        // Append the source map inline with the compiled output
        if (options.outputFile == "") {
          currentSource.contents = currentSource.contents +
            "/# sourceMappingURL=data:application/json;base64," +
            encodeBase64(generator.toString()) + "\n";
        }

        // Create the source map as another file alongside the output
        else {
          string name = options.outputFile + ".map";
          currentSource.contents = currentSource.contents +
            "/# sourceMappingURL=" + splitPath(name).entry + "\n";
          return [currentSource, Source(name, generator.toString())];
        }
      }

      return [currentSource];
    }

    void appendSource(Source source) {
      if (currentColumn > 0) {
        emit("\n");
      }
      currentSource.contents += source.contents;
      if (options.jsSourceMap) {
        for (var i = 0, n = source.lineCount(); i < n; i++) {
          generator.addMapping(source, i, 0, currentLine++, 0);
        }
      }
      if (source.contents.codeUnitAt(source.contents.length - 1) != '\n') {
        emit("\n");
      }
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        var range = node.range;
        if (range.source != null) {
          var location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      if (!options.jsMinify) {
        indent += "  ";
      }
    }

    void decreaseIndent() {
      if (!options.jsMinify) {
        indent = indent.slice(2, indent.length);
      }
    }

    void emit(string text) {
      if (options.jsMinify || options.jsSourceMap) {
        for (var i = 0; i < text.length; i++) {
          var c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents += text;
    }

    void emitNodes(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (newline == "" && currentColumn > 1024) {
          emit("\n");
        }
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (i > 0) emit("," + space);
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (i > 0) emit("," + space);
        emitExpression(nodes.get(i), .COMMA);
      }
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void emitChildren(Node node) {
      if (node.hasChildren()) {
        emitNodes(node.children);
      }
    }

    Node singleStatement(Node node) {
      assert node.kind == .BLOCK;
      return node.hasChildren() && node.children.length == 1 ? node.children.get(0) : null;
    }

    void recursiveEmitIfStatement(Node node) {
      var trueBlock = node.ifTrue();
      var falseBlock = node.ifFalse();
      var trueStatement = singleStatement(trueBlock);
      emit("if" + space + "(");
      emitExpression(node.ifTest(), .LOWEST);
      emit(")" + space);

      // Make sure to always keep braces to avoid the dangling "else" case
      emitBlock(trueBlock, falseBlock != null && trueStatement != null && trueStatement.kind == .IF ? .MUST_KEEP_BRACES : .CAN_OMIT_BRACES);

      if (falseBlock != null) {
        emit(space + "else ");
        var falseStatement = singleStatement(falseBlock);
        if (falseStatement != null && falseStatement.kind == .IF) {
          addMapping(falseStatement);
          recursiveEmitIfStatement(falseStatement);
        } else {
          emitBlock(falseBlock, .CAN_OMIT_BRACES);
        }
      }
    }

    void emitNode(Node node) {
      isStartOfExpression = false;
      addMapping(node);

      // Separating the case bodies into separate functions makes the JavaScript JIT go faster
      switch (node.kind) {
        case .CASE { emitCase(node); }
        case .VARIABLE_CLUSTER { emitVariableCluster(node); }
        case .NAMESPACE { emitNamespace(node); }
        case .ENUM, .ENUM_FLAGS { emitEnum(node); }
        case .CONSTRUCTOR, .FUNCTION { emitFunction(node); }
        case .VARIABLE { emitVariable(node); }
        case .IF { emitIf(node); }
        case .FOR { emitFor(node); }
        case .WHILE { emitWhile(node); }
        case .DO_WHILE { emitDoWhile(node); }
        case .RETURN, .IMPLICIT_RETURN { emitReturn(node); }
        case .BREAK { emitBreak(node); }
        case .CONTINUE { emitContinue(node); }
        case .ASSERT { emitAssert(node); }
        case .EXPRESSION { emitExpressionStatement(node); }
        case .SWITCH { emitSwitch(node); }
        case .MODIFIER { emitModifier(node); }
        case .PARAMETER, .ALIAS, .USING {}
        default { assert false; }
      }
    }

    void emitBlock(Node node, BlockMode mode) {
      var shouldMinify = mode == .CAN_OMIT_BRACES && options.jsMinify;
      addMapping(node);
      if (shouldMinify && !node.hasChildren()) {
        emit(";");
      } else if (shouldMinify && node.children.length == 1) {
        emitNode(node.children.get(0));
      } else {
        emit("{" + newline);
        increaseIndent();
        emitChildren(node);
        decreaseIndent();
        emit(indent + "}");
      }
    }

    void emitCase(Node node) {
      var values = node.caseValues();
      var block = node.caseBlock();
      for (var i = 0; i < values.length; i++) {
        emit(indent + "case ");
        emitExpression(values.get(i), .LOWEST);
        emit(":" + newline);
      }
      if (values.length == 0) {
        emit(indent + "default:" + newline);
      }
      increaseIndent();
      emitChildren(block);
      if (!block.blockAlwaysEndsWithReturn()) {
        emit(indent + "break;" + newline);
      }
      decreaseIndent();
    }

    void emitVariableCluster(Node node) {
      var variables = node.clusterVariables();
      for (var i = 0; i < variables.length; i++) {
        var variable = variables.get(i);
        var symbol = variable.symbol;
        var isCompoundName = symbol != null && hasCompoundName(symbol);
        if ((symbol == null || !symbol.kind.isInstance() && !symbol.isImport()) && (!isCompoundName || variable.variableValue() != null)) {
          emit(indent);
          if (!isCompoundName) {
            emit("var ");
          }
          emitNode(variable);
          emit(";" + newline);
        }
      }
    }

    void emitNamespace(Node node) {
      if (!hasCompoundName(node.symbol)) {
        emit("var ");
      }
      emit(indent + fullName(node.symbol) + space + "=" + space + "{};" + newline);
    }

    void emitEnum(Node node) {
      var block = node.declarationBlock();
      if (!options.foldAllConstants || node.symbol.isImportOrExport()) {
        if (!hasCompoundName(node.symbol)) {
          emit("var ");
        }
        emit(indent + fullName(node.symbol) + space + "=" + space + "{" + newline);
        increaseIndent();
        for (var i = 0; i < block.children.length; i++) {
          var symbol = block.children.get(i).symbol;
          emit(indent + mangleName(symbol) + ":" + space + symbol.constant.asInt() + (i == block.children.length - 1 ? "" : ",") + newline);
        }
        decreaseIndent();
        emit(indent + "};" + newline);
      }
    }

    void emitFunction(Node node) {
      var block = node.functionBlock();
      var symbol = node.symbol;
      if (block == null) {
        return;
      }
      var isCompoundName = hasCompoundName(symbol);
      if (!isCompoundName) {
        emit(indent + "function " + fullName(symbol));
      } else {
        emit(indent + fullName(symbol) + space + "=" + space + "function");
      }
      emitArgumentVariables(node.functionArguments().children);
      emit(space);
      emitBlock(block, .MUST_KEEP_BRACES);
      emit(isCompoundName ? ";" + newline : newline);
      if (node.kind == .CONSTRUCTOR) {
        var type = symbol.enclosingSymbol.type;
        if (type.isClass() && type.baseClass() != null) {
          emit(indent + "$extends(" + fullName(type.symbol) + "," + space + fullName(type.baseClass().symbol) + ");" + newline);
        }
      }
    }

    void emitVariable(Node node) {
      var value = node.variableValue();
      emit(node.symbol == null ? node.declarationName().asString() : fullName(node.symbol));
      if (value != null) {
        emit(space + "=" + space);
        emitExpression(value, .COMMA);
      }
    }

    void emitIf(Node node) {
      emit(indent);
      recursiveEmitIfStatement(node);
      emit(newline);
    }

    void emitFor(Node node) {
      var setup = node.forSetup();
      var test = node.forTest();
      var update = node.forUpdate();
      emit(indent + "for" + space + "(");
      if (setup != null) {
        if (setup.kind == .VARIABLE_CLUSTER) {
          emit("var ");
          emitCommaSeparatedNodes(setup.clusterVariables());
        } else {
          emitExpression(setup, .LOWEST);
        }
      }
      if (test != null) {
        emit(";" + space);
        emitExpression(test, .LOWEST);
      } else {
        emit(";");
      }
      if (update != null) {
        emit(";" + space);
        emitExpression(update, .LOWEST);
      } else {
        emit(";");
      }
      emit(")" + space);
      emitBlock(node.forBlock(), .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitWhile(Node node) {
      emit(indent + "while" + space + "(");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")" + space);
      emitBlock(node.whileBlock(), .CAN_OMIT_BRACES);
      emit(newline);
    }

    void emitDoWhile(Node node) {
      emit(indent + "do ");
      emitBlock(node.whileBlock(), .CAN_OMIT_BRACES);
      emit(space + "while" + space + "(");
      emitExpression(node.whileTest(), .LOWEST);
      emit(");" + newline);
    }

    void emitReturn(Node node) {
      var value = node.returnValue();
      emit(indent);
      if (value != null) {
        emit("return ");
        emitExpression(value, .LOWEST);
        emit(";" + newline);
      } else {
        emit("return;" + newline);
      }
    }

    void emitBreak(Node node) {
      emit(indent + "break;" + newline);
    }

    void emitContinue(Node node) {
      emit(indent + "continue;" + newline);
    }

    void emitAssert(Node node) {
      var value = node.assertValue();
      value.invertBooleanCondition(cache);
      if (!value.isFalse()) {
        var couldBeFalse = !value.isTrue();
        if (couldBeFalse) {
          emit(indent + "if" + space + "(");
          emitExpression(value, .LOWEST);
          emit(")");
          if (!options.jsMinify) {
            emit(" {\n");
            increaseIndent();
          }
        }
        var text = node.range + " (" + node.range.locationString() + ")";
        emit(indent + "throw new Error(" + quoteString(text, '"') + ");" + newline);
        if (!options.jsMinify && couldBeFalse) {
          decreaseIndent();
          emit(indent + "}\n");
        }
      }
    }

    void emitExpressionStatement(Node node) {
      emit(indent);
      isStartOfExpression = true;
      emitExpression(node.expressionValue(), .LOWEST);
      emit(";" + newline);
    }

    void emitSwitch(Node node) {
      emit(indent + "switch" + space + "(");
      emitExpression(node.switchValue(), .LOWEST);
      emit(")" + space + "{" + newline);
      emitNodes(node.switchCases());
      emit(indent + "}" + newline);
    }

    void emitModifier(Node node) {
      emitNodes(node.modifierStatements());
    }

    void emitExpression(Node node, Precedence precedence) {
      var wasStartOfExpression = isStartOfExpression;
      isStartOfExpression = false;
      addMapping(node);

      switch (node.kind) {
        case .NAME { emit(node.symbol == null ? node.asString() : fullName(node.symbol)); }
        case .TYPE { emit(fullName(node.type.symbol)); }
        case .THIS { emit("this"); }
        case .HOOK { emitHook(node, precedence); }
        case .NULL { emit("null"); }
        case .BOOL { emit(node.asBool() ? "true" : "false"); }
        case .INT { emitInt(node); }
        case .FLOAT, .DOUBLE { emitDouble(node); }
        case .STRING { emit(quoteString(node.asString(), '"')); }
        case .LIST { emitList(node); }
        case .DOT { emitDot(node); }
        case .CALL { isStartOfExpression = wasStartOfExpression; emitCall(node); }
        case .SUPER_CALL { emitSuperCall(node); }
        case .SEQUENCE { isStartOfExpression = wasStartOfExpression; emitSequence(node, precedence); }
        case .LAMBDA { emitLambda(node, wasStartOfExpression); }
        case .UNTYPED { emitExpression(node.untypedValue(), precedence); }
        case .INDEX { emitIndex(node, precedence); }
        case .ASSIGN_INDEX { emitTertiary(node, precedence); }
        case .CAST, .IMPLICIT_CAST { isStartOfExpression = wasStartOfExpression; emitExpression(node.castValue(), precedence); }

        case
          .NOT, .POSITIVE, .NEGATIVE, .COMPLEMENT,
          .PREFIX_INCREMENT, .PREFIX_DECREMENT,
          .POSTFIX_INCREMENT, .POSTFIX_DECREMENT {
          emitUnary(node, precedence);
        }

        case
          .ADD, .ASSIGN, .ASSIGN_ADD, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR, .ASSIGN_DIVIDE,
          .ASSIGN_MULTIPLY, .ASSIGN_REMAINDER, .ASSIGN_SHIFT_LEFT,
          .ASSIGN_SHIFT_RIGHT, .ASSIGN_SUBTRACT, .BITWISE_AND,
          .BITWISE_OR, .BITWISE_XOR, .DIVIDE, .EQUAL, .GREATER_THAN,
          .GREATER_THAN_OR_EQUAL, .IN, .LESS_THAN, .LESS_THAN_OR_EQUAL,
          .LOGICAL_AND, .LOGICAL_OR, .MULTIPLY, .NOT_EQUAL, .REMAINDER,
          .SHIFT_LEFT, .SHIFT_RIGHT, .SUBTRACT {
          emitBinary(node, precedence);
        }

        default {
          assert false;
        }
      }
    }

    void emitHook(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.hookTest(), .LOGICAL_OR);
      emit(space + "?" + space);
      emitExpression(node.hookTrue(), .ASSIGN);
      emit(space + ":" + space);
      emitExpression(node.hookFalse(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    void emitInt(Node node) {
      var wrap = node.parent.kind == .DOT && node != toStringTarget;
      if (wrap) emit("(");
      emit(node.asInt().toString());
      if (wrap) emit(")");
    }

    void emitDouble(Node node) {
      var wrap = node.parent.kind == .DOT && node != toStringTarget;
      if (wrap) emit("(");
      emit(node.asDouble().toString());
      if (wrap) emit(")");
    }

    void emitList(Node node) {
      emit("[");
      emitCommaSeparatedExpressions(node.listValues());
      emit("]");
    }

    void emitDot(Node node) {
      emitExpression(node.dotTarget(), .MEMBER);
      emit(".");
      var name = node.dotName();
      emit(
        name.symbol == null ? name.asString() :
        name.symbol.kind.isInstance() ? mangleName(name.symbol) :
        fullName(name.symbol));
    }

    void emitCall(Node node) {
      var value = node.callValue();
      if (value.kind.isType()) emit("new ");
      emitExpression(value, .UNARY_POSTFIX);
      emit("(");
      emitCommaSeparatedExpressions(node.callArguments());
      emit(")");
    }

    void emitSuperCall(Node node) {
      var arguments = node.superCallArguments();
      emit(fullName(node.symbol));
      emit(".call(this");
      for (var i = 0; i < arguments.length; i++) {
        emit(", ");
        emitExpression(arguments.get(i), .COMMA);
      }
      emit(")");
    }

    void emitSequence(Node node, Precedence precedence) {
      if (.COMMA <= precedence) emit("(");
      emitCommaSeparatedExpressions(node.children);
      if (.COMMA <= precedence) emit(")");
    }

    void emitLambda(Node node, bool wasStartOfExpression) {
      if (wasStartOfExpression) emit("(");
      emit("function");
      emitArgumentVariables(node.lambdaArguments());
      emit(space);
      emitBlock(node.lambdaBlock(), .MUST_KEEP_BRACES);
      if (wasStartOfExpression) emit(")");
    }

    void emitUnary(Node node, Precedence precedence) {
      var value = node.unaryValue();
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var isPostfix = info.precedence == .UNARY_POSTFIX;
      if (!isPostfix) {
        emit(info.text);

        // Prevent "- -1" from becoming "--1"
        if (node.kind == .POSITIVE && (value.kind == .POSITIVE || value.kind == .PREFIX_INCREMENT) ||
            node.kind == .NEGATIVE && (value.kind == .NEGATIVE || value.kind == .PREFIX_DECREMENT || value.kind == .INT && value.asInt() < 0)) {
          emit(" ");
        }
      }
      emitExpression(value, info.precedence);
      if (isPostfix) emit(info.text);
      if (info.precedence < precedence) emit(")");
    }

    bool isToStringCall(Node node) {
      if (node.kind == .CALL) {
        var value = node.callValue();
        return value.kind == .DOT && value.symbol != null && value.symbol.name == "toString" && node.callArguments().length == 0;
      }
      return false;
    }

    void emitBinary(Node node, Precedence precedence) {
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var left = node.binaryLeft();
      var right = node.binaryRight();

      // Special case adding a string with the result of calling toString()
      // since the JavaScript runtime will automatically call toString()
      if (node.kind == .ADD) {
        if (left.type != null && left.type.isString(cache) && isToStringCall(right)) {
          right = right.callValue().dotTarget();
        } else if (right.type != null && right.type.isString(cache) && isToStringCall(left)) {
          left = left.callValue().dotTarget();
        }
      }

      toStringTarget = left;
      emitExpression(left, info.precedence.incrementIfRightAssociative(info.associativity));
      emit(space + (node.kind == .EQUAL ? "===" : node.kind == .NOT_EQUAL ? "!==" : info.text) + space);
      toStringTarget = right;
      emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity));
      if (info.precedence < precedence) emit(")");
    }

    void emitIndex(Node node, Precedence precedence) {
      emitExpression(node.binaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.binaryRight(), .LOWEST);
      emit("]");
    }

    void emitTertiary(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.tertiaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.tertiaryMiddle(), .LOWEST);
      emit("]" + space + "=" + space);
      emitExpression(node.tertiaryRight(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    bool alwaysConvertsOperandsToInt(NodeKind kind) {
      switch (kind) {
        case
          .BITWISE_OR, .BITWISE_AND, .BITWISE_XOR, .SHIFT_LEFT,
          .SHIFT_RIGHT, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_XOR, .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT {

          return true;
        }

        default {
          return false;
        }
      }
    }

    static bool isExpressionUsed(Node node) {
      assert node.kind.isExpression();
      var parent = node.parent;
      if (!parent.kind.isExpression()) {
        return false;
      }
      if (parent.kind == .SEQUENCE && (!isExpressionUsed(parent) || parent.children.indexOf(node) < parent.children.length - 1)) {
        return false;
      }
      return true;
    }

    void patchNode(Node node, PatchContext context) {
      switch (node.kind) {
        case .LAMBDA { context.lambdaCount++; }
        case .CONSTRUCTOR { patchConstructor(node, context); context.setFunction(node); }
        case .FUNCTION { context.setFunction(node); }
        case .CAST { patchCast(node, context); }
        case .CLASS { patchClass(node); }
        case .THIS { patchThis(node, context); }
        case .NAME { patchName(node); }
        case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER { patchBinary(node); }
        case .PREFIX_INCREMENT, .PREFIX_DECREMENT, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT { patchUnary(node, context); }
        case .ASSIGN_ADD, .ASSIGN_SUBTRACT, .ASSIGN_MULTIPLY, .ASSIGN_DIVIDE, .ASSIGN_REMAINDER { patchAssign(node, context); }
      }

      // This is not inside the switch statement above because one of the other
      // case clauses may have introduced a let statement
      if (node.kind == .LET) {
        patchLet(node);
      }

      if (node.hasChildren()) {
        for (var i = 0; i < node.children.length; i++) {
          var child = node.children.get(i);
          if (child != null) {
            patchNode(child, context);
          }
        }
      }

      switch (node.kind) {
        case .LAMBDA { context.lambdaCount--; }
        case .CONSTRUCTOR, .FUNCTION { context.setFunction(null); }
      }
    }

    void patchThis(Node node, PatchContext context) {
      if (context.lambdaCount > 0) {
        node.become(context.thisAlias());
      }
    }

    void patchClass(Node node) {
      if (!node.symbol.isImport() && node.symbol.type.baseClass() != null) {
        needExtends = true;
      }
    }

    void patchName(Node node) {
      if (node.symbol != null && node.symbol.kind.isInstance() && node.isNameExpression()) {
        node.become(Node.createDot(Node.createThis(), node.clone()));
      }
    }

    void patchBinary(Node node) {
      if (node.type.isInt(cache) && (node.kind == .MULTIPLY || !alwaysConvertsOperandsToInt(node.parent.kind))) {
        node.become(createBinaryInt(node.kind, node.binaryLeft().replaceWith(null), node.binaryRight().replaceWith(null)).withRange(node.range));
      }
    }

    void patchLet(Node node) {
      var value = node.letValue().replaceWith(null);
      var variable = node.letVariable().replaceWith(null);
      node.become(Node.createCall(Node.createLambda([variable], Node.createBlock([Node.createReturn(value)])), [variable.variableValue().replaceWith(null)]));
    }

    void patchAssign(Node node, PatchContext context) {
      if (node.type.isInt(cache)) {
        var isPostfix = node.kind == .POSTFIX_INCREMENT || node.kind == .POSTFIX_DECREMENT;
        var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
        var left = node.binaryLeft();
        var right = node.binaryRight();
        NodeKind kind =
          node.kind == .ASSIGN_ADD ? .ADD :
          node.kind == .ASSIGN_SUBTRACT ? .SUBTRACT :
          node.kind == .ASSIGN_MULTIPLY ? .MULTIPLY :
          node.kind == .ASSIGN_DIVIDE ? .DIVIDE :
          .REMAINDER;
        node.become(createBinaryIntAssignment(context, kind, left.remove(), right.remove()).withRange(node.range));
      }
    }

    void patchUnary(Node node, PatchContext context) {
      if (node.type.isInt(cache)) {
        var isPostfix = node.kind == .POSTFIX_INCREMENT || node.kind == .POSTFIX_DECREMENT;
        var isIncrement = node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT;
        var result = createBinaryIntAssignment(context, isIncrement ? .ADD : .SUBTRACT, node.unaryValue().remove(), Node.createInt(1));
        if (isPostfix && isExpressionUsed(node)) {
          result = createBinaryInt(isIncrement ? .SUBTRACT : .ADD, result, Node.createInt(1));
        }
        node.become(result.withRange(node.range).withType(node.type));
      }
    }

    void patchCast(Node node, PatchContext context) {
      var value = node.castValue();

      // Cast to bool
      if (node.type.isBool(cache) && !value.type.isBool(cache)) {
        value = Node.createUnary(.NOT, value.remove()).withRange(node.range).withType(node.type);
        node.become(Node.createUnary(.NOT, value).withRange(node.range).withType(node.type));
      }

      // Cast to int
      else if (node.type.isInt(cache) && !value.type.isInteger(cache) && !alwaysConvertsOperandsToInt(node.parent.kind)) {
        node.become(Node.createBinary(.BITWISE_OR, value.remove(), Node.createInt(0)).withRange(node.range).withType(node.type));
      }

      // Cast to float/double
      else if (node.type.isReal(cache) && !value.type.isNumeric(cache)) {
        node.become(Node.createUnary(.POSITIVE, value.remove()).withRange(node.range).withType(node.type));
      }
    }

    void patchConstructor(Node node, PatchContext context) {
      var block = node.functionBlock();
      if (block == null) {
        return;
      }
      var superInitializer = node.superInitializer();
      var memberInitializers = node.memberInitializers();
      var index = 0;
      if (superInitializer != null) {
        block.insertChild(index++, Node.createExpression(superInitializer.replaceWith(null)));
      }
      if (memberInitializers != null) {
        for (var i = 0; i < memberInitializers.children.length; i++) {
          var child = memberInitializers.children.get(i);
          var name = child.memberInitializerName();
          var value = child.memberInitializerValue();
          block.insertChild(index++, Node.createExpression(Node.createBinary(.ASSIGN, name.remove(), value.remove())));
        }
      }
    }

    Node createBinaryInt(NodeKind kind, Node left, Node right) {
      if (kind == .MULTIPLY) {
        needMathImul = true;
        return Node.createCall(Node.createName("$imul"), [left, right]).withType(cache.intType);
      }
      return Node.createBinary(.BITWISE_OR, Node.createBinary(kind, left, right).withType(cache.intType), Node.createInt(0).withType(cache.intType)).withType(cache.intType);
    }

    static bool isSimpleNameAccess(Node node) {
      return node.kind == .NAME || node.kind == .THIS || node.kind == .DOT && isSimpleNameAccess(node.dotTarget());
    }

    Node createBinaryIntAssignment(PatchContext context, NodeKind kind, Node left, Node right) {
      if (isSimpleNameAccess(left)) {
        return Node.createBinary(.ASSIGN, left.clone(), createBinaryInt(kind, left, right));
      }
      assert left.kind == .DOT;
      var target = left.dotTarget();
      var name = left.dotName();
      var temporaryName = Node.createName("$temp");
      var dot = Node.createDot(temporaryName, name.remove());
      return Node.createLet(
        Node.createVariable(temporaryName.clone(), null, target.remove()),
        Node.createBinary(.ASSIGN, dot, createBinaryInt(kind, dot.clone(), right)).withType(cache.intType)).withType(cache.intType);
    }

    static bool hasCompoundName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      return enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace() && (
        !symbol.kind.isConstructor() || hasCompoundName(enclosingSymbol));
    }

    static StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result.set("apply", true);
      result.set("arguments", true);
      result.set("call", true);
      result.set("constructor", true);
      result.set("double", true);
      result.set("float", true);
      result.set("function", true);
      result.set("in", true);
      result.set("int", true);
      result.set("this", true);
      result.set("throw", true);
      return result;
    }

    static string mangleName(Symbol symbol) {
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (symbol.kind.isConstructor()) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (isKeyword.has(symbol.name)) {
        return "$" + symbol.name;
      }
      return symbol.name;
    }

    static string fullName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      if (enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace()) {
        var enclosingName = fullName(enclosingSymbol);
        if (symbol.kind.isConstructor()) {
          return enclosingName;
        }
        if (symbol.kind.isInstance()) {
          enclosingName += ".prototype";
        }
        return enclosingName + "." + mangleName(symbol);
      }
      return mangleName(symbol);
    }
  }
}
