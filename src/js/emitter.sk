namespace js {
  class Emitter : IEmitter {
    int currentLine = 0;
    int currentColumn = 0;
    Source currentSource = null;
    SourceMapGenerator generator = new SourceMapGenerator();
    CompilerOptions options;
    TypeCache cache;
    string indent = "";

    override List<Source> emitProgram(Node program) {
      currentSource = new Source(options.outputFile, "");
      Collector collector = new Collector(cache, program, SortTypes.BY_INHERITANCE_AND_CONTAINMENT);

      // Emit types
      int i;
      for (i = 0; i < collector.typeSymbols.length; i++) {
        Type type = collector.typeSymbols.get(i).type;
        if (type.isNamespace()) {
          emitNode(type.symbol.node.firstNonExtensionSibling());
          continue;
        }
        if (type.isEnum()) {
          emitNode(type.symbol.node.firstNonExtensionSibling());
        } else {
          Member constructor = type.constructor();
          if (constructor != null) {
            emitNode(constructor.symbol.node);
          }
        }
        List<Member> members = type.members.values();
        int j;
        for (j = 0; j < members.length; j++) {
          Symbol symbol = members.get(j).symbol;
          if (symbol.node != null && symbol.kind.isFunction() && !symbol.kind.isConstructor()) {
            emitNode(symbol.node);
          }
        }
      }

      // Emit free functions
      for (i = 0; i < collector.freeFunctionSymbols.length; i++) {
        emitNode(collector.freeFunctionSymbols.get(i).node);
      }

      // Emit top-level statements
      for (i = 0; i < collector.topLevelStatements.length; i++) {
        emitNode(collector.topLevelStatements.get(i));
      }

      // Append the source map inline with the compiled output
      if (options.jsSourceMap) {
        currentSource.contents = currentSource.contents.append("/").append(
          "/# sourceMappingURL=data:application/json;base64,").append(
          encodeBase64(generator.toString()));
      }

      return { currentSource };
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        Range range = node.range;
        if (range.source != null) {
          LineColumn location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      indent = indent.append("  ");
    }

    void decreaseIndent() {
      indent = indent.slice(2, indent.length);
    }

    void emit(string text) {
      if (options.jsSourceMap) {
        int i;
        for (i = 0; i < text.length; i++) {
          int c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents = currentSource.contents.append(text);
    }

    void emitNodes(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitExpression(nodes.get(i), Precedence.COMMA);
      }
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void emitChildren(Node node) {
      if (node.hasChildren()) {
        emitNodes(node.children);
      }
    }

    void recursiveEmitIfStatement(Node node) {
      emit("if (");
      emitExpression(node.ifTest(), Precedence.LOWEST);
      emit(") ");
      emitNode(node.ifTrue());
      Node block = node.ifFalse();
      if (block != null) {
        emit(" else ");
        Node statement = block.hasChildren() && block.children.length == 1 ? block.children.get(0) : null;
        if (statement != null && statement.kind == NodeKind.IF) {
          addMapping(statement);
          recursiveEmitIfStatement(statement);
        } else {
          emitNode(block);
        }
      }
    }

    void emitNode(Node node) {
      addMapping(node);
      switch (node.kind) {
        case NodeKind.PROGRAM {
          emitChildren(node);
        }

        case NodeKind.FILE {
          emitChildren(node.fileBlock());
        }

        case NodeKind.BLOCK {
          emit("{\n");
          increaseIndent();
          emitChildren(node);
          decreaseIndent();
          emit(indent.append("}"));
        }

        case NodeKind.CASE {
          List<Node> values = node.caseValues();
          int i;
          for (i = 0; i < values.length; i++) {
            emit(indent.append("case "));
            emitExpression(values.get(i), Precedence.LOWEST);
            emit(":\n");
          }
          if (values.length == 0) {
            emit(indent.append("default:\n"));
          }
          increaseIndent();
          emitChildren(node.caseBlock());
          emit(indent.append("break;\n"));
          decreaseIndent();
        }

        case NodeKind.VARIABLE_CLUSTER {
          List<Node> variables = node.clusterVariables();
          int i;
          for (i = 0; i < variables.length; i++) {
            Node variable = variables.get(i);
            bool isCompoundName = hasCompoundName(variable.symbol);
            if (!variable.symbol.kind.isInstance() && (!isCompoundName || variable.variableValue() != null)) {
              emit(indent);
              if (!isCompoundName) {
                emit("var ");
              }
              emitNode(variable);
              emit(";\n");
            }
          }
        }

        case NodeKind.NAMESPACE {
          if (!hasCompoundName(node.symbol)) {
            emit("var ");
          }
          emit(indent.append(fullName(node.symbol)).append(" = {};\n"));
        }

        case NodeKind.ENUM, NodeKind.ENUM_FLAGS {
          Node block = node.declarationBlock();
          if (!hasCompoundName(node.symbol)) {
            emit("var ");
          }
          emit(indent.append(fullName(node.symbol)).append(" = {\n"));
          increaseIndent();
          int i;
          for (i = 0; i < block.children.length; i++) {
            Symbol symbol = block.children.get(i).symbol;
            emit(indent.append(mangleName(symbol)).append(": ").append(symbol.enumValue.toString()).append(i == block.children.length - 1 ? "\n" : ",\n"));
          }
          decreaseIndent();
          emit(indent.append("};\n"));
        }

        case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION {
          Node block = node.functionBlock();
          if (block != null) {
            if (!hasCompoundName(node.symbol)) {
              emit("var ");
            }
            emit(indent.append(fullName(node.symbol)).append(" = function"));
            emitArgumentVariables(node.functionArguments().children);
            emit(" ");
            emit("{\n");
            increaseIndent();
            if (node.kind == NodeKind.CONSTRUCTOR) {
              Node superInitializer = node.superInitializer();
              Node memberInitializers = node.memberInitializers();
              if (superInitializer != null) {
                emit(indent);
                emitExpression(superInitializer, Precedence.LOWEST);
                emit(";\n");
              }
              if (memberInitializers != null) {
                int i;
                for (i = 0; i < memberInitializers.children.length; i++) {
                  emit(indent);
                  emitNode(memberInitializers.children.get(i));
                  emit(";\n");
                }
              }
            }
            emitChildren(block);
            decreaseIndent();
            emit(indent.append("}"));
            emit(";\n");
          }
        }

        case NodeKind.MEMBER_INITIALIZER {
          emitExpression(node.memberInitializerName(), Precedence.MEMBER);
          emit(" = ");
          emitExpression(node.memberInitializerValue(), Precedence.COMMA);
        }

        case NodeKind.VARIABLE {
          Node value = node.variableValue();
          emit(fullName(node.symbol));
          if (value != null) {
            emit(" = ");
            emitExpression(value, Precedence.COMMA);
          }
        }

        case NodeKind.PARAMETER {
        }

        case NodeKind.USING_ALIAS {
        }

        case NodeKind.IF {
          emit(indent);
          recursiveEmitIfStatement(node);
          emit("\n");
        }

        case NodeKind.FOR {
          Node setup = node.forSetup();
          Node test = node.forTest();
          Node update = node.forUpdate();
          emit(indent.append("for ("));
          if (setup != null) {
            if (setup.kind == NodeKind.VARIABLE_CLUSTER) {
              emit("var ");
              emitCommaSeparatedNodes(setup.clusterVariables());
            } else {
              emitExpression(setup, Precedence.LOWEST);
            }
          }
          if (test != null) {
            emit("; ");
            emitExpression(test, Precedence.LOWEST);
          } else {
            emit(";");
          }
          if (update != null) {
            emit("; ");
            emitExpression(update, Precedence.LOWEST);
          } else {
            emit(";");
          }
          emit(") ");
          emitNode(node.forBlock());
          emit("\n");
        }

        case NodeKind.FOR_EACH {
        }

        case NodeKind.WHILE {
          emit(indent.append("while ("));
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(") ");
          emitNode(node.whileBlock());
          emit("\n");
        }

        case NodeKind.DO_WHILE {
          emit(indent.append("do "));
          emitNode(node.whileBlock());
          emit(" while (");
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(");\n");
        }

        case NodeKind.RETURN {
          Node value = node.returnValue();
          emit(indent);
          if (value != null) {
            emit("return ");
            emitExpression(value, Precedence.LOWEST);
            emit(";\n");
          } else {
            emit("return;\n");
          }
        }

        case NodeKind.BREAK {
          emit(indent.append("break;\n"));
        }

        case NodeKind.CONTINUE {
          emit(indent.append("continue;\n"));
        }

        case NodeKind.ASSERT {
        }

        case NodeKind.EXPRESSION {
          emit(indent);
          emitExpression(node.expressionValue(), Precedence.LOWEST);
          emit(";\n");
        }

        case NodeKind.SWITCH {
          emit(indent.append("switch ("));
          emitExpression(node.switchValue(), Precedence.LOWEST);
          emit(") {\n");
          emitNodes(node.switchCases());
          emit(indent.append("}"));
        }

        case NodeKind.MODIFIER {
          emitNodes(node.modifierStatements());
        }

        case NodeKind.USING_NAMESPACE {
        }

        default {
          assert false;
        }
      }
    }

    void emitExpression(Node node, Precedence precedence) {
      addMapping(node);
      switch (node.kind) {
        case NodeKind.NAME {
          if (node.symbol == null) {
            emit(node.asString());
          } else if (!node.symbol.kind.isInstance()) {
            emit(fullName(node.symbol));
          } else {
            emit("this.".append(mangleName(node.symbol)));
          }
        }

        case NodeKind.TYPE {
          emit(fullName(node.type.symbol));
        }

        case NodeKind.THIS {
          emit("this");
        }

        case NodeKind.HOOK {
          if (Precedence.ASSIGN < precedence) emit("(");
          emitExpression(node.hookTest(), Precedence.LOGICAL_OR);
          emit(" ? ");
          emitExpression(node.hookTrue(), Precedence.ASSIGN);
          emit(" : ");
          emitExpression(node.hookFalse(), Precedence.ASSIGN);
          if (Precedence.ASSIGN < precedence) emit(")");
        }

        case NodeKind.NULL {
          emit("null");
        }

        case NodeKind.TRUE {
          emit("true");
        }

        case NodeKind.FALSE {
          emit("false");
        }

        case NodeKind.INT {
          emit(node.asInt().toString());
        }

        case NodeKind.FLOAT, NodeKind.DOUBLE {
          emit(node.asDouble().toString());
        }

        case NodeKind.STRING {
          emit(quoteString(node.asString(), '"'));
        }

        case NodeKind.INITIALIZER {
          emit("[");
          emitCommaSeparatedExpressions(node.initializerValues());
          emit("]");
        }

        case NodeKind.DOT {
          emitExpression(node.dotTarget(), Precedence.MEMBER);
          emit(".");
          emitExpression(node.dotName(), Precedence.MEMBER);
        }

        case NodeKind.CALL {
          Node value = node.callValue();
          if (value.kind.isType()) emit("new ");
          emitExpression(value, Precedence.UNARY_POSTFIX);
          emit("(");
          emitCommaSeparatedExpressions(node.callArguments());
          emit(")");
        }

        case NodeKind.SUPER_CALL {
          List<Node> arguments = node.superCallArguments();
          emit(fullName(node.symbol));
          emit(".call(this");
          int i;
          for (i = 0; i < arguments.length; i++) {
            emit(", ");
            emitExpression(arguments.get(i), Precedence.COMMA);
          }
          emit(")");
        }

        case NodeKind.SEQUENCE {
          emitCommaSeparatedExpressions(node.children);
        }

        case NodeKind.CAST {
          emitExpression(node.castValue(), precedence);
        }

        case NodeKind.IMPLICIT_CAST {
          emitExpression(node.castValue(), precedence);
        }

        case NodeKind.LAMBDA {
          emit("function ");
          emitArgumentVariables(node.lambdaArguments());
          emit(" ");
          emitNode(node.lambdaBlock());
        }

        case NodeKind.DEFAULT {
        }

        case
          NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
          NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
          NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {

          Node value = node.unaryValue();
          OperatorInfo info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          bool isPostfix = info.precedence == Precedence.UNARY_POSTFIX;
          if (!isPostfix) {
            emit(info.text);

            // Prevent "- -1" from becoming "--1"
            if (node.kind == NodeKind.POSITIVE && (value.kind == NodeKind.POSITIVE || value.kind == NodeKind.PREFIX_INCREMENT) ||
                node.kind == NodeKind.NEGATIVE && (value.kind == NodeKind.NEGATIVE || value.kind == NodeKind.PREFIX_DECREMENT)) {
              emit(" ");
            }
          }
          emitExpression(value, info.precedence);
          if (isPostfix) emit(info.text);
          if (info.precedence < precedence) emit(")");
        }

        case
          NodeKind.ADD, NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND,
          NodeKind.ASSIGN_BITWISE_OR, NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE,
          NodeKind.ASSIGN_MULTIPLY, NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT,
          NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT, NodeKind.BITWISE_AND,
          NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR, NodeKind.DIVIDE, NodeKind.EQUAL,
          NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL, NodeKind.IN, NodeKind.LESS_THAN,
          NodeKind.LESS_THAN_OR_EQUAL, NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY,
          NodeKind.NOT_EQUAL, NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT,
          NodeKind.SUBTRACT {

          OperatorInfo info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          emitExpression(node.binaryLeft(), info.precedence);
          emit(" ".append(info.text).append(" "));
          emitExpression(node.binaryRight(), info.precedence);
          if (info.precedence < precedence) emit(")");
        }

        case NodeKind.INDEX {
          emitExpression(node.binaryLeft(), Precedence.MEMBER);
          emit("[");
          emitExpression(node.binaryRight(), Precedence.LOWEST);
          emit("]");
        }

        case NodeKind.ASSIGN_INDEX {
        }

        default {
          assert false;
        }
      }
    }

    bool hasCompoundName(Symbol symbol) {
      Symbol enclosingSymbol = symbol.enclosingSymbol;
      return enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace() && (
        !symbol.kind.isConstructor() || hasCompoundName(enclosingSymbol));
    }

    static StringMap<bool> createIsKeyword() {
      StringMap<bool> result = new StringMap<bool>();
      result.set("arguments", true);
      result.set("call", true);
      result.set("apply", true);
      result.set("constructor", true);
      result.set("function", true);
      result.set("throw", true);
      result.set("this", true);
      return result;
    }

    static StringMap<bool> isKeyword = createIsKeyword();

    string mangleName(Symbol symbol) {
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (symbol.kind.isConstructor()) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (isKeyword.has(symbol.name)) {
        return "$".append(symbol.name);
      }
      return symbol.name;
    }

    string fullName(Symbol symbol) {
      Symbol enclosingSymbol = symbol.enclosingSymbol;
      if (enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace()) {
        string enclosingName = fullName(enclosingSymbol);
        if (symbol.kind.isConstructor()) {
          return enclosingName;
        }
        if (symbol.kind.isInstance()) {
          enclosingName = enclosingName.append(".prototype");
        }
        return enclosingName.append(".").append(mangleName(symbol));
      }
      return mangleName(symbol);
    }
  }
}
