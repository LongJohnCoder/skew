namespace js {
  class PatchContext {
    int lambdaCount = 0;
    Node function = null;
    bool createdThisAlias = false;

    void setFunction(Node node) {
      function = node;
      createdThisAlias = false;
    }

    Node thisAlias() {
      if (!createdThisAlias) {
        createdThisAlias = true;
        function.functionBlock().insertChild(0, Node.createVariableCluster(Node.createError(),
          { Node.createVariable(Node.createName("$this"), null, Node.createThis()) }));
      }
      return Node.createName("$this");
    }
  }

  class Emitter : IEmitter {
    int currentLine = 0;
    int currentColumn = 0;
    Source currentSource = null;
    bool isStartOfExpression = false;
    SourceMapGenerator generator = new SourceMapGenerator();
    CompilerOptions options;
    TypeCache cache;
    string indent = "";

    override List<Source> emitProgram(Node program) {
      patchNode(program, new PatchContext());
      currentSource = new Source(options.outputFile, "");
      Collector collector = new Collector(program, SortTypes.BY_INHERITANCE_AND_CONTAINMENT);

      // Emit helper functions
      for (i = 0; i < collector.typeSymbols.length; i++) {
        Type type = collector.typeSymbols.get(i).type;
        if (type.isClass() && type.baseClass() != null) {
          emit(
"function $extends(derived, base) {
  derived.prototype = Object.create(base.prototype);
  derived.prototype.constructor = derived;
}
");
          break;
        }
      }

      // Emit types
      int i;
      for (i = 0; i < collector.typeSymbols.length; i++) {
        Type type = collector.typeSymbols.get(i).type;
        if (type.isNamespace()) {
          if (!type.symbol.isImport()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          }
          continue;
        }
        if (!type.symbol.isImport()) {
          if (type.isEnum()) {
            emitNode(type.symbol.node.firstNonExtensionSibling());
          } else {
            Member constructor = type.constructor();
            if (constructor != null) {
              emitNode(constructor.symbol.node);
            }
          }
        }
        List<Member> members = type.members.values();
        int j;
        for (j = 0; j < members.length; j++) {
          Symbol symbol = members.get(j).symbol;
          if (symbol.enclosingSymbol == type.symbol && symbol.node != null && symbol.kind.isFunction() && !symbol.kind.isConstructor()) {
            emitNode(symbol.node);
          }
        }
      }

      // Emit free functions
      for (i = 0; i < collector.freeFunctionSymbols.length; i++) {
        emitNode(collector.freeFunctionSymbols.get(i).node);
      }

      // Emit top-level statements
      for (i = 0; i < collector.topLevelStatements.length; i++) {
        emitNode(collector.topLevelStatements.get(i));
      }

      // Append the source map inline with the compiled output
      if (options.jsSourceMap) {
        currentSource.contents = currentSource.contents.append("/").append(
          "/# sourceMappingURL=data:application/json;base64,").append(
          encodeBase64(generator.toString()));
      }

      return { currentSource };
    }

    void addMapping(Node node) {
      if (options.jsSourceMap) {
        Range range = node.range;
        if (range.source != null) {
          LineColumn location = range.source.indexToLineColumn(range.start);
          generator.addMapping(range.source, location.line, location.column, currentLine, currentColumn);
        }
      }
    }

    void increaseIndent() {
      indent = indent.append("  ");
    }

    void decreaseIndent() {
      indent = indent.slice(2, indent.length);
    }

    void emit(string text) {
      if (options.jsSourceMap) {
        int i;
        for (i = 0; i < text.length; i++) {
          int c = text.codeUnitAt(i);
          if (c == '\n') {
            currentColumn = 0;
            currentLine++;
          } else {
            currentColumn++;
          }
        }
      }
      currentSource.contents = currentSource.contents.append(text);
    }

    void emitNodes(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedNodes(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitNode(nodes.get(i));
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      int i;
      for (i = 0; i < nodes.length; i++) {
        if (i > 0) emit(", ");
        emitExpression(nodes.get(i), Precedence.COMMA);
      }
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      emitCommaSeparatedNodes(nodes);
      emit(")");
    }

    void emitChildren(Node node) {
      if (node.hasChildren()) {
        emitNodes(node.children);
      }
    }

    void recursiveEmitIfStatement(Node node) {
      emit("if (");
      emitExpression(node.ifTest(), Precedence.LOWEST);
      emit(") ");
      emitNode(node.ifTrue());
      Node block = node.ifFalse();
      if (block != null) {
        emit(" else ");
        Node statement = block.hasChildren() && block.children.length == 1 ? block.children.get(0) : null;
        if (statement != null && statement.kind == NodeKind.IF) {
          addMapping(statement);
          recursiveEmitIfStatement(statement);
        } else {
          emitNode(block);
        }
      }
    }

    void emitNode(Node node) {
      isStartOfExpression = false;
      addMapping(node);

      switch (node.kind) {
        case NodeKind.PROGRAM {
          emitChildren(node);
        }

        case NodeKind.FILE {
          emitChildren(node.fileBlock());
        }

        case NodeKind.BLOCK {
          emit("{\n");
          increaseIndent();
          emitChildren(node);
          decreaseIndent();
          emit(indent.append("}"));
        }

        case NodeKind.CASE {
          List<Node> values = node.caseValues();
          Node block = node.caseBlock();
          int i;
          for (i = 0; i < values.length; i++) {
            emit(indent.append("case "));
            emitExpression(values.get(i), Precedence.LOWEST);
            emit(":\n");
          }
          if (values.length == 0) {
            emit(indent.append("default:\n"));
          }
          increaseIndent();
          emitChildren(block);
          if (!block.blockAlwaysEndsWithReturn()) {
            emit(indent.append("break;\n"));
          }
          decreaseIndent();
        }

        case NodeKind.VARIABLE_CLUSTER {
          List<Node> variables = node.clusterVariables();
          int i;
          for (i = 0; i < variables.length; i++) {
            Node variable = variables.get(i);
            bool isCompoundName = variable.symbol != null && hasCompoundName(variable.symbol);
            if ((variable.symbol == null || !variable.symbol.kind.isInstance()) && (!isCompoundName || variable.variableValue() != null)) {
              emit(indent);
              if (!isCompoundName) {
                emit("var ");
              }
              emitNode(variable);
              emit(";\n");
            }
          }
        }

        case NodeKind.NAMESPACE {
          if (!hasCompoundName(node.symbol)) {
            emit("var ");
          }
          emit(indent.append(fullName(node.symbol)).append(" = {};\n"));
        }

        case NodeKind.ENUM, NodeKind.ENUM_FLAGS {
          Node block = node.declarationBlock();
          if (!hasCompoundName(node.symbol)) {
            emit("var ");
          }
          emit(indent.append(fullName(node.symbol)).append(" = {\n"));
          increaseIndent();
          int i;
          for (i = 0; i < block.children.length; i++) {
            Symbol symbol = block.children.get(i).symbol;
            emit(indent.append(mangleName(symbol)).append(": ").append(symbol.enumValue.toString()).append(i == block.children.length - 1 ? "\n" : ",\n"));
          }
          decreaseIndent();
          emit(indent.append("};\n"));
        }

        case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION {
          Node block = node.functionBlock();
          if (block == null) {
            return;
          }
          bool isCompoundName = hasCompoundName(node.symbol);
          if (!isCompoundName) {
            emit(indent.append("function ").append(fullName(node.symbol)));
          } else {
            emit(indent.append(fullName(node.symbol)).append(" = function"));
          }
          emitArgumentVariables(node.functionArguments().children);
          emit(" ");
          emit("{\n");
          increaseIndent();
          if (node.kind == NodeKind.CONSTRUCTOR) {
            Node superInitializer = node.superInitializer();
            Node memberInitializers = node.memberInitializers();
            if (superInitializer != null) {
              emit(indent);
              emitExpression(superInitializer, Precedence.LOWEST);
              emit(";\n");
            }
            if (memberInitializers != null) {
              int i;
              for (i = 0; i < memberInitializers.children.length; i++) {
                emit(indent);
                emitNode(memberInitializers.children.get(i));
                emit(";\n");
              }
            }
          }
          emitChildren(block);
          decreaseIndent();
          emit(indent.append(isCompoundName ? "};\n" : "}\n"));
          if (node.kind == NodeKind.CONSTRUCTOR) {
            Type type = node.symbol.enclosingSymbol.type;
            if (type.isClass() && type.baseClass() != null) {
              emit(indent.append("$extends(").append(fullName(type.symbol)).append(", ").append(fullName(type.baseClass().symbol)).append(");\n"));
            }
          }
        }

        case NodeKind.MEMBER_INITIALIZER {
          emitExpression(node.memberInitializerName(), Precedence.MEMBER);
          emit(" = ");
          emitExpression(node.memberInitializerValue(), Precedence.COMMA);
        }

        case NodeKind.VARIABLE {
          Node value = node.variableValue();
          emit(node.symbol == null ? node.declarationName().asString() : fullName(node.symbol));
          if (value != null) {
            emit(" = ");
            emitExpression(value, Precedence.COMMA);
          }
        }

        case NodeKind.IF {
          emit(indent);
          recursiveEmitIfStatement(node);
          emit("\n");
        }

        case NodeKind.FOR {
          Node setup = node.forSetup();
          Node test = node.forTest();
          Node update = node.forUpdate();
          emit(indent.append("for ("));
          if (setup != null) {
            if (setup.kind == NodeKind.VARIABLE_CLUSTER) {
              emit("var ");
              emitCommaSeparatedNodes(setup.clusterVariables());
            } else {
              emitExpression(setup, Precedence.LOWEST);
            }
          }
          if (test != null) {
            emit("; ");
            emitExpression(test, Precedence.LOWEST);
          } else {
            emit(";");
          }
          if (update != null) {
            emit("; ");
            emitExpression(update, Precedence.LOWEST);
          } else {
            emit(";");
          }
          emit(") ");
          emitNode(node.forBlock());
          emit("\n");
        }

        case NodeKind.FOR_EACH {
        }

        case NodeKind.WHILE {
          emit(indent.append("while ("));
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(") ");
          emitNode(node.whileBlock());
          emit("\n");
        }

        case NodeKind.DO_WHILE {
          emit(indent.append("do "));
          emitNode(node.whileBlock());
          emit(" while (");
          emitExpression(node.whileTest(), Precedence.LOWEST);
          emit(");\n");
        }

        case NodeKind.RETURN {
          Node value = node.returnValue();
          emit(indent);
          if (value != null) {
            emit("return ");
            emitExpression(value, Precedence.LOWEST);
            emit(";\n");
          } else {
            emit("return;\n");
          }
        }

        case NodeKind.BREAK {
          emit(indent.append("break;\n"));
        }

        case NodeKind.CONTINUE {
          emit(indent.append("continue;\n"));
        }

        case NodeKind.ASSERT {
          Node value = node.assertValue();
          value.invertBooleanCondition(cache);
          bool couldBeFalse = value.kind != NodeKind.TRUE;
          if (couldBeFalse) {
            emit(indent.append("if ("));
            emitExpression(value, Precedence.LOWEST);
            emit(") {\n");
            increaseIndent();
          }
          string text = node.range.toString().append(" (").append(node.range.locationString()).append(")");
          emit(indent.append("throw new Error(").append(quoteString(text, '"')).append(");\n"));
          if (couldBeFalse) {
            decreaseIndent();
            emit(indent.append("}\n"));
          }
        }

        case NodeKind.EXPRESSION {
          emit(indent);
          isStartOfExpression = true;
          emitExpression(node.expressionValue(), Precedence.LOWEST);
          emit(";\n");
        }

        case NodeKind.SWITCH {
          emit(indent.append("switch ("));
          emitExpression(node.switchValue(), Precedence.LOWEST);
          emit(") {\n");
          emitNodes(node.switchCases());
          emit(indent.append("}\n"));
        }

        case NodeKind.MODIFIER {
          emitNodes(node.modifierStatements());
        }

        case NodeKind.PARAMETER, NodeKind.USING_ALIAS, NodeKind.USING_NAMESPACE {
        }

        default {
          assert false;
        }
      }
    }

    void emitExpression(Node node, Precedence precedence) {
      bool wasStartOfExpression = isStartOfExpression;
      isStartOfExpression = false;
      addMapping(node);

      switch (node.kind) {
        case NodeKind.NAME {
          emit(node.symbol == null ? node.asString() : fullName(node.symbol));
        }

        case NodeKind.TYPE {
          emit(fullName(node.type.symbol));
        }

        case NodeKind.THIS {
          emit("this");
        }

        case NodeKind.HOOK {
          if (Precedence.ASSIGN < precedence) emit("(");
          emitExpression(node.hookTest(), Precedence.LOGICAL_OR);
          emit(" ? ");
          emitExpression(node.hookTrue(), Precedence.ASSIGN);
          emit(" : ");
          emitExpression(node.hookFalse(), Precedence.ASSIGN);
          if (Precedence.ASSIGN < precedence) emit(")");
        }

        case NodeKind.NULL {
          emit("null");
        }

        case NodeKind.TRUE {
          emit("true");
        }

        case NodeKind.FALSE {
          emit("false");
        }

        case NodeKind.INT {
          emit(node.asInt().toString());
        }

        case NodeKind.FLOAT, NodeKind.DOUBLE {
          emit(node.asDouble().toString());
        }

        case NodeKind.STRING {
          emit(quoteString(node.asString(), '"'));
        }

        case NodeKind.INITIALIZER {
          emit("[");
          emitCommaSeparatedExpressions(node.initializerValues());
          emit("]");
        }

        case NodeKind.DOT {
          emitExpression(node.dotTarget(), Precedence.MEMBER);
          emit(".");
          Node name = node.dotName();
          emit(
            name.symbol == null ? name.asString() :
            name.symbol.kind.isInstance() ? mangleName(name.symbol) :
            fullName(name.symbol));
        }

        case NodeKind.CALL {
          Node value = node.callValue();
          if (value.kind.isType()) emit("new ");
          isStartOfExpression = wasStartOfExpression;
          emitExpression(value, Precedence.UNARY_POSTFIX);
          emit("(");
          emitCommaSeparatedExpressions(node.callArguments());
          emit(")");
        }

        case NodeKind.SUPER_CALL {
          List<Node> arguments = node.superCallArguments();
          emit(fullName(node.symbol));
          emit(".call(this");
          int i;
          for (i = 0; i < arguments.length; i++) {
            emit(", ");
            emitExpression(arguments.get(i), Precedence.COMMA);
          }
          emit(")");
        }

        case NodeKind.BIND {
          emitExpression(node.bindValue(), precedence);
        }

        case NodeKind.SEQUENCE {
          if (Precedence.COMMA <= precedence) emit("(");
          isStartOfExpression = wasStartOfExpression;
          emitCommaSeparatedExpressions(node.children);
          if (Precedence.COMMA <= precedence) emit(")");
        }

        case NodeKind.CAST, NodeKind.IMPLICIT_CAST {
          isStartOfExpression = wasStartOfExpression;
          emitExpression(node.castValue(), precedence);
        }

        case NodeKind.LAMBDA {
          if (wasStartOfExpression) emit("(");
          emit("function");
          emitArgumentVariables(node.lambdaArguments());
          emit(" ");
          emitNode(node.lambdaBlock());
          if (wasStartOfExpression) emit(")");
        }

        case NodeKind.DEFAULT {
          if (node.type.isNumeric(cache)) emit("0");
          else if (node.type.isBool(cache)) emit("false");
          else if (node.type.isReference()) emit("null");
          else assert false; // TODO: Handle structs
        }

        case
          NodeKind.NOT, NodeKind.POSITIVE, NodeKind.NEGATIVE, NodeKind.COMPLEMENT,
          NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT,
          NodeKind.POSTFIX_INCREMENT, NodeKind.POSTFIX_DECREMENT {

          Node value = node.unaryValue();
          OperatorInfo info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          bool isPostfix = info.precedence == Precedence.UNARY_POSTFIX;
          if (!isPostfix) {
            emit(info.text);

            // Prevent "- -1" from becoming "--1"
            if (node.kind == NodeKind.POSITIVE && (value.kind == NodeKind.POSITIVE || value.kind == NodeKind.PREFIX_INCREMENT) ||
                node.kind == NodeKind.NEGATIVE && (value.kind == NodeKind.NEGATIVE || value.kind == NodeKind.PREFIX_DECREMENT)) {
              emit(" ");
            }
          }
          emitExpression(value, info.precedence);
          if (isPostfix) emit(info.text);
          if (info.precedence < precedence) emit(")");
        }

        case
          NodeKind.ADD, NodeKind.ASSIGN, NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_BITWISE_AND,
          NodeKind.ASSIGN_BITWISE_OR, NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_DIVIDE,
          NodeKind.ASSIGN_MULTIPLY, NodeKind.ASSIGN_REMAINDER, NodeKind.ASSIGN_SHIFT_LEFT,
          NodeKind.ASSIGN_SHIFT_RIGHT, NodeKind.ASSIGN_SUBTRACT, NodeKind.BITWISE_AND,
          NodeKind.BITWISE_OR, NodeKind.BITWISE_XOR, NodeKind.DIVIDE, NodeKind.EQUAL,
          NodeKind.GREATER_THAN, NodeKind.GREATER_THAN_OR_EQUAL, NodeKind.IN, NodeKind.LESS_THAN,
          NodeKind.LESS_THAN_OR_EQUAL, NodeKind.LOGICAL_AND, NodeKind.LOGICAL_OR, NodeKind.MULTIPLY,
          NodeKind.NOT_EQUAL, NodeKind.REMAINDER, NodeKind.SHIFT_LEFT, NodeKind.SHIFT_RIGHT,
          NodeKind.SUBTRACT {

          OperatorInfo info = operatorInfo.get(node.kind);
          if (info.precedence < precedence) emit("(");
          emitExpression(node.binaryLeft(), (Precedence)(info.precedence + (int)(info.associativity == Associativity.RIGHT)));
          emit(node.kind == NodeKind.EQUAL ? " === " : node.kind == NodeKind.NOT_EQUAL ? " !== " : " ".append(info.text).append(" "));
          emitExpression(node.binaryRight(), (Precedence)(info.precedence + (int)(info.associativity == Associativity.LEFT)));
          if (info.precedence < precedence) emit(")");
        }

        case NodeKind.INDEX {
          emitExpression(node.binaryLeft(), Precedence.MEMBER);
          emit("[");
          emitExpression(node.binaryRight(), Precedence.LOWEST);
          emit("]");
        }

        case NodeKind.ASSIGN_INDEX {
        }

        default {
          assert false;
        }
      }
    }

    static bool alwaysConvertsOperandsToInt(NodeKind kind) {
      switch (kind) {
        case
          NodeKind.BITWISE_OR, NodeKind.BITWISE_AND, NodeKind.BITWISE_XOR, NodeKind.SHIFT_LEFT,
          NodeKind.SHIFT_RIGHT, NodeKind.ASSIGN_BITWISE_OR, NodeKind.ASSIGN_BITWISE_AND,
          NodeKind.ASSIGN_BITWISE_XOR, NodeKind.ASSIGN_SHIFT_LEFT, NodeKind.ASSIGN_SHIFT_RIGHT {

          return true;
        }

        default {
          return false;
        }
      }
    }

    static bool isSimpleNameAccess(Node node) {
      return node.kind == NodeKind.NAME || node.kind == NodeKind.THIS || node.kind == NodeKind.DOT && isSimpleNameAccess(node.dotTarget());
    }

    static bool isExpressionUsed(Node node) {
      assert node.kind.isExpression();
      Node parent = node.parent;
      if (!parent.kind.isExpression()) {
        return false;
      }
      if (parent.kind == NodeKind.SEQUENCE && (!isExpressionUsed(parent) || parent.children.indexOf(node) < parent.children.length - 1)) {
        return false;
      }
      return true;
    }

    void patchNode(Node node, PatchContext context) {
      switch (node.kind) {
        case NodeKind.LET {
          Node value = node.letValue();
          Node variable = node.letVariable();
          node.become(Node.createCall(Node.createLambda({ variable.remove() }, Node.createBlock({ Node.createReturn(value.remove()) })), { variable.variableValue().remove() }));
          variable.appendChild(null);
        }

        case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION {
          context.setFunction(node);
        }

        case NodeKind.LAMBDA {
          context.lambdaCount++;
        }

        case NodeKind.THIS {
          if (context.lambdaCount > 0) {
            node.become(context.thisAlias());
          }
        }

        case NodeKind.NAME {
          if (node.symbol != null && node.symbol.kind.isInstance() && node.parent.kind != NodeKind.DOT) {
            node.become(Node.createDot(Node.createThis(), node.clone()));
          }
        }
      }

      if (node.hasChildren()) {
        int i;
        for (i = 0; i < node.children.length; i++) {
          Node child = node.children.get(i);
          if (child != null) {
            patchNode(child, context);
          }
        }
      }

      switch (node.kind) {
        case NodeKind.CONSTRUCTOR, NodeKind.FUNCTION {
          context.setFunction(null);
        }

        case NodeKind.LAMBDA {
          context.lambdaCount--;
        }

        case NodeKind.CAST {
          Node value = node.castValue();

          // Cast to bool
          if (node.type.isBool(cache) && !value.type.isBool(cache)) {
            node.become(Node.createUnary(NodeKind.NOT, value.remove()).withRange(node.range).withType(node.type));
          }

          // Cast to int
          else if (node.type.isInt(cache) && !value.type.isInteger(cache) && !alwaysConvertsOperandsToInt(node.parent.kind)) {
            node.become(Node.createBinary(NodeKind.BITWISE_OR, value.remove(), Node.createInt(0)).withRange(node.range).withType(node.type));
          }

          // Cast to float/double
          else if (node.type.isReal(cache) && !value.type.isNumeric(cache)) {
            node.become(Node.createUnary(NodeKind.POSITIVE, value.remove()).withRange(node.range).withType(node.type));
          }
        }

        case NodeKind.PREFIX_INCREMENT, NodeKind.PREFIX_DECREMENT, NodeKind.POSTFIX_DECREMENT, NodeKind.POSTFIX_INCREMENT {
          if (node.type.isInt(cache)) {
            bool isPostfix = node.kind == NodeKind.POSTFIX_INCREMENT || node.kind == NodeKind.POSTFIX_DECREMENT;
            bool isIncrement = node.kind == NodeKind.PREFIX_INCREMENT || node.kind == NodeKind.POSTFIX_INCREMENT;
            Node value = node.unaryValue();
            if (isSimpleNameAccess(value)) {
              Node result =
                Node.createBinary(NodeKind.ASSIGN,
                  value.clone(),
                  Node.createBinary(NodeKind.BITWISE_OR,
                    Node.createBinary(isIncrement ? NodeKind.ADD : NodeKind.SUBTRACT, value.remove(), Node.createInt(1)),
                    Node.createInt(0)));
              if (isPostfix && isExpressionUsed(node)) {
                result = Node.createBinary(NodeKind.BITWISE_OR,
                  Node.createBinary(isIncrement ? NodeKind.SUBTRACT : NodeKind.ADD, result, Node.createInt(1)),
                  Node.createInt(0));
              }
              node.become(result.withRange(node.range).withType(node.type));
            }
          }
        }

        case NodeKind.ADD, NodeKind.SUBTRACT, NodeKind.MULTIPLY, NodeKind.DIVIDE, NodeKind.REMAINDER {
          if (node.type.isInt(cache) && !alwaysConvertsOperandsToInt(node.parent.kind)) {
            List<Node> children = node.removeChildren();
            node.become(Node.createBinary(NodeKind.BITWISE_OR, node.clone().withChildren(children), Node.createInt(0)).withRange(node.range).withType(node.type));
          }
        }

        case NodeKind.ASSIGN_ADD, NodeKind.ASSIGN_SUBTRACT, NodeKind.ASSIGN_MULTIPLY, NodeKind.ASSIGN_DIVIDE, NodeKind.ASSIGN_REMAINDER {
          if (node.type.isInt(cache)) {
            bool isPostfix = node.kind == NodeKind.POSTFIX_INCREMENT || node.kind == NodeKind.POSTFIX_DECREMENT;
            bool isIncrement = node.kind == NodeKind.PREFIX_INCREMENT || node.kind == NodeKind.POSTFIX_INCREMENT;
            Node left = node.binaryLeft();
            Node right = node.binaryRight();
            if (isSimpleNameAccess(left)) {
              NodeKind kind =
                node.kind == NodeKind.ASSIGN_ADD ? NodeKind.ADD :
                node.kind == NodeKind.ASSIGN_SUBTRACT ? NodeKind.SUBTRACT :
                node.kind == NodeKind.ASSIGN_MULTIPLY ? NodeKind.MULTIPLY :
                node.kind == NodeKind.ASSIGN_DIVIDE ? NodeKind.DIVIDE :
                NodeKind.REMAINDER;
              Node result =
                Node.createBinary(NodeKind.ASSIGN,
                  left.clone(),
                  Node.createBinary(NodeKind.BITWISE_OR,
                    Node.createBinary(kind, left.remove(), right.remove()),
                    Node.createInt(0)));
              node.become(result.withRange(node.range).withType(node.type));
            }
          }
        }
      }
    }

    bool hasCompoundName(Symbol symbol) {
      Symbol enclosingSymbol = symbol.enclosingSymbol;
      return enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace() && (
        !symbol.kind.isConstructor() || hasCompoundName(enclosingSymbol));
    }

    static StringMap<bool> createIsKeyword() {
      StringMap<bool> result = new StringMap<bool>();
      result.set("arguments", true);
      result.set("call", true);
      result.set("apply", true);
      result.set("constructor", true);
      result.set("function", true);
      result.set("throw", true);
      result.set("this", true);
      return result;
    }

    static StringMap<bool> isKeyword = createIsKeyword();

    string mangleName(Symbol symbol) {
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (symbol.kind.isConstructor()) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (isKeyword.has(symbol.name)) {
        return "$".append(symbol.name);
      }
      return symbol.name;
    }

    string fullName(Symbol symbol) {
      Symbol enclosingSymbol = symbol.enclosingSymbol;
      if (enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace()) {
        string enclosingName = fullName(enclosingSymbol);
        if (symbol.kind.isConstructor()) {
          return enclosingName;
        }
        if (symbol.kind.isInstance()) {
          enclosingName = enclosingName.append(".prototype");
        }
        return enclosingName.append(".").append(mangleName(symbol));
      }
      return mangleName(symbol);
    }
  }
}
