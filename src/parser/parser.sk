// The same operator precedence as C for the most part
enum Precedence {
  LOWEST,
  COMMA,
  ASSIGN,
  LOGICAL_OR,
  LOGICAL_AND,
  BITWISE_OR,
  BITWISE_XOR,
  BITWISE_AND,
  EQUAL,
  COMPARE,
  SHIFT,
  ADD,
  MULTIPLY,
  UNARY_PREFIX,
  UNARY_POSTFIX,
  MEMBER,
}

enum AllowEmpty {
  NO,
  YES,
}

enum StatementHint {
  NORMAL,
  IN_ENUM,
  IN_OBJECT,
  IN_SWITCH,
}

enum TokenScan {
  NORMAL,
  STOP_BEFORE_NEXT_STATEMENT,
}

// Parser recovery is done by skipping to the next closing token after an error
bool scanForToken(ParserContext context, TokenKind kind, TokenScan tokenScan) {
  if (context.expect(kind)) {
    return true;
  }

  while (!context.peek(TokenKind.END_OF_FILE)) {
    if (context.peek(TokenKind.RIGHT_PARENTHESIS) ||
        context.peek(TokenKind.RIGHT_BRACKET) ||
        context.peek(TokenKind.RIGHT_BRACE) ||
        tokenScan == TokenScan.STOP_BEFORE_NEXT_STATEMENT && context.peek(TokenKind.SEMICOLON)) {
      return context.eat(kind);
    }

    if (tokenScan == TokenScan.STOP_BEFORE_NEXT_STATEMENT && (
        context.peek(TokenKind.ASSERT) ||
        context.peek(TokenKind.BREAK) ||
        context.peek(TokenKind.CASE) ||
        context.peek(TokenKind.CLASS) ||
        context.peek(TokenKind.CONTINUE) ||
        context.peek(TokenKind.DO) ||
        context.peek(TokenKind.ELSE) ||
        context.peek(TokenKind.EXPORT) ||
        context.peek(TokenKind.FINAL) ||
        context.peek(TokenKind.FOR) ||
        context.peek(TokenKind.IF) ||
        context.peek(TokenKind.IMPORT) ||
        context.peek(TokenKind.INLINE) ||
        context.peek(TokenKind.INTERFACE) ||
        context.peek(TokenKind.OVERRIDE) ||
        context.peek(TokenKind.PRIVATE) ||
        context.peek(TokenKind.PROTECTED) ||
        context.peek(TokenKind.PUBLIC) ||
        context.peek(TokenKind.RETURN) ||
        context.peek(TokenKind.STATIC) ||
        context.peek(TokenKind.STRUCT) ||
        context.peek(TokenKind.SWITCH) ||
        context.peek(TokenKind.VIRTUAL) ||
        context.peek(TokenKind.WHILE))) {
      return true;
    }

    context.next();
  }

  return false;
}

Node parseGroup(ParserContext context) {
  if (!context.expect(TokenKind.LEFT_PARENTHESIS)) return null;
  Node value = pratt.parse(context, Precedence.LOWEST);
  scanForToken(context, TokenKind.RIGHT_PARENTHESIS, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return value;
}

Node parseName(ParserContext context) {
  Token token = context.current(); if (!context.expect(TokenKind.IDENTIFIER)) return null;
  return Node.createName(token.text).withRange(token.range);
}

Node parseBlock(ParserContext context, StatementHint hint) {
  Token token = context.current();
  if (!context.expect(TokenKind.LEFT_BRACE)) return null;
  List<Node> statements = parseStatements(context, hint);
  scanForToken(context, TokenKind.RIGHT_BRACE, TokenScan.NORMAL);
  return Node.createBlock(statements).withRange(context.spanSince(token.range));
}

Node parseBlockOrStatement(ParserContext context) {
  if (context.peek(TokenKind.LEFT_BRACE)) return parseBlock(context, StatementHint.NORMAL);
  Node statement = parseStatement(context, StatementHint.NORMAL); if (statement == null) return null;
  return Node.createBlock({ statement }).withRange(statement.range);
}

Node parseCaseStatement(ParserContext context) {
  Token token = context.current();
  List<Node> values = null;
  if (!context.eat(TokenKind.DEFAULT)) {
    if (!context.expect(TokenKind.CASE)) return null;
    values = {};
    do {
      values.push(pratt.parse(context, Precedence.COMMA));
    } while (context.eat(TokenKind.COMMA));
  }
  Node block = parseBlock(context, StatementHint.NORMAL); if (block == null) return null;
  return (values != null ? Node.createCase(values, block) : Node.createDefault(block)).withRange(context.spanSince(token.range));
}

List<Node> parseStatements(ParserContext context, StatementHint hint) {
  List<Node> statements = {};
  while (!context.peek(TokenKind.RIGHT_BRACE) && !context.peek(TokenKind.END_OF_FILE)) {
    if (hint == StatementHint.IN_ENUM) {
      Node declaration = parseEnumValueDeclaration(context); if (declaration == null) break;
      statements.push(declaration);
      if (!context.eat(TokenKind.COMMA)) break;
    } else {
      Node statement = hint == StatementHint.IN_SWITCH ? parseCaseStatement(context) : parseStatement(context, hint); if (statement == null) break;
      statements.push(statement);
    }
  }
  return statements;
}

Node parseArgumentVariables(ParserContext context) {
  Token token = context.current();
  List<Node> arguments = {};
  if (!context.expect(TokenKind.LEFT_PARENTHESIS)) return null;
  while (!context.peek(TokenKind.RIGHT_PARENTHESIS)) {
    if (arguments.length > 0 && !context.expect(TokenKind.COMMA)) break;
    // TODO: Parse modifiers here
    Node type = parseType(context);
    Node name = parseName(context); if (name == null) break;
    arguments.push(Node.createVariable(name, type, null).withRange(Range.span(type.range, name.range)));
  }
  scanForToken(context, TokenKind.RIGHT_PARENTHESIS, TokenScan.NORMAL);
  return Node.createNodeList(arguments).withRange(context.spanSince(token.range));
}

Node parseType(ParserContext context) {
  return pratt.parse(context, Precedence.MEMBER - 1);
}

Node parseEnumValueDeclaration(ParserContext context) {
  Node name = parseName(context); if (name == null) return null;
  Node value = context.eat(TokenKind.ASSIGN) ? pratt.parse(context, Precedence.COMMA) : null;
  return Node.createVariable(name, null, value).withRange(context.spanSince(name.range));
}

Node parseObject(ParserContext context, NodeKind kind) {
  Token token = context.next();
  Node name = parseName(context); if (name == null) return null;
  Node parameters = null;
  Node bases = null;
  Node block = parseBlock(context, StatementHint.IN_OBJECT); if (block == null) return null;
  return Node.createObject(kind, name, parameters, bases, block).withRange(context.spanSince(token.range));
}

Node parseNestedNamespaceBlock(ParserContext context) {
  if (!context.eat(TokenKind.DOT)) {
    return parseBlock(context, StatementHint.NORMAL);
  }
  Node name = parseName(context); if (name == null) return null;
  Node block = parseNestedNamespaceBlock(context); if (block == null) return null;
  Range range = context.spanSince(name.range);
  return Node.createBlock({ Node.createNamespace(name, block).withRange(range) }).withRange(range);
}

Node parseNamespace(ParserContext context) {
  Token token = context.next();
  Node name = parseName(context); if (name == null) return null;
  Node block = parseNestedNamespaceBlock(context); if (block == null) return null;
  return Node.createNamespace(name, block).withRange(context.spanSince(token.range));
}

Node parseExpression(ParserContext context) {
  // Make sure we don't parse an initializer expression. The user is likely
  // trying to type a C-style block statement, which is not supported. An
  // initializer expression wouldn't make sense here anyway since there's no
  // type context yet at the start of an expression statement.
  if (context.peek(TokenKind.LEFT_BRACE)) {
    context.unexpectedToken();
    return null;
  }

  // Parse an expression
  Token token = context.current();
  Node value = pratt.parse(context, Precedence.LOWEST);
  if (!scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT) && context.current().range.start == token.range.start) {
    context.next(); // This is necessary to prevent an infinite loop when the first token of the expression is a syntax error
  }

  assert context.current().range.start >= token.range.end;
  return Node.createExpression(value);
}

Node parseModifier(ParserContext context, SymbolFlag flag) {
  Token token = context.next();
  Node name = Node.createName(token.text).withRange(token.range);
  Node block = parseBlockOrStatement(context); if (block == null) return null;
  List<Node> statements = block.children;
  block.removeChildren();
  return Node.createModifier(name, statements).withRange(context.spanSince(token.range));
}

Node parseStatement(ParserContext context, StatementHint hint) {
  switch (context.current().kind) {
    case TokenKind.CLASS { return parseObject(context, NodeKind.CLASS); }
    case TokenKind.EXPORT { return parseModifier(context, SymbolFlag.EXPORT); }
    case TokenKind.FINAL { return parseModifier(context, SymbolFlag.FINAL); }
    case TokenKind.IMPORT { return parseModifier(context, SymbolFlag.IMPORT); }
    case TokenKind.INLINE { return parseModifier(context, SymbolFlag.INLINE); }
    case TokenKind.INTERFACE { return parseObject(context, NodeKind.INTERFACE); }
    case TokenKind.NAMESPACE { return parseNamespace(context); }
    case TokenKind.OVERRIDE { return parseModifier(context, SymbolFlag.OVERRIDE); }
    case TokenKind.PRIVATE { return parseModifier(context, SymbolFlag.PRIVATE); }
    case TokenKind.PROTECTED { return parseModifier(context, SymbolFlag.PROTECTED); }
    case TokenKind.PUBLIC { return parseModifier(context, SymbolFlag.PUBLIC); }
    case TokenKind.STATIC { return parseModifier(context, SymbolFlag.STATIC); }
    case TokenKind.STRUCT { return parseObject(context, NodeKind.STRUCT); }
    case TokenKind.VIRTUAL { return parseModifier(context, SymbolFlag.VIRTUAL); }
    default { return parseExpression(context); }
  }
}

Pratt createParser() {
  Pratt pratt = new Pratt();
  return pratt;
}

final Pratt pratt = createParser();

Node parseFile(Log log, List<Token> tokens) {
  ParserContext context = new ParserContext(log, tokens);
  Token token = context.current();
  List<Node> statements = parseStatements(context, StatementHint.NORMAL); if (statements == null) return null;
  if (!context.expect(TokenKind.END_OF_FILE)) return null;
  Range range = context.spanSince(token.range);
  return Node.createFile(Node.createBlock(statements).withRange(range)).withRange(range);
}
