// The same operator precedence as C for the most part
enum Precedence {
  LOWEST,
  COMMA,
  ASSIGN,
  LOGICAL_OR,
  LOGICAL_AND,
  BITWISE_OR,
  BITWISE_XOR,
  BITWISE_AND,
  EQUAL,
  COMPARE,
  SHIFT,
  ADD,
  MULTIPLY,
  UNARY_PREFIX,
  UNARY_POSTFIX,
  MEMBER,
}

enum AllowEmpty {
  NO,
  YES,
}

enum StatementHint {
  NORMAL,
  IN_ENUM,
  IN_OBJECT,
  IN_SWITCH,
}

enum TokenScan {
  NORMAL,
  STOP_BEFORE_NEXT_STATEMENT,
}

// Parser recovery is done by skipping to the next closing token after an error
bool scanForToken(ParserContext context, TokenKind kind, TokenScan tokenScan) {
  if (context.expect(kind)) {
    return true;
  }

  while (!context.peek(TokenKind.END_OF_FILE)) {
    if (context.peek(TokenKind.RIGHT_PARENTHESIS) ||
        context.peek(TokenKind.RIGHT_BRACKET) ||
        context.peek(TokenKind.RIGHT_BRACE) ||
        tokenScan == TokenScan.STOP_BEFORE_NEXT_STATEMENT && context.peek(TokenKind.SEMICOLON)) {
      return context.eat(kind);
    }

    if (tokenScan == TokenScan.STOP_BEFORE_NEXT_STATEMENT && (
        context.peek(TokenKind.ASSERT) ||
        context.peek(TokenKind.BREAK) ||
        context.peek(TokenKind.CASE) ||
        context.peek(TokenKind.CLASS) ||
        context.peek(TokenKind.CONTINUE) ||
        context.peek(TokenKind.DO) ||
        context.peek(TokenKind.ELSE) ||
        context.peek(TokenKind.EXPORT) ||
        context.peek(TokenKind.FINAL) ||
        context.peek(TokenKind.FOR) ||
        context.peek(TokenKind.IF) ||
        context.peek(TokenKind.IMPORT) ||
        context.peek(TokenKind.INLINE) ||
        context.peek(TokenKind.INTERFACE) ||
        context.peek(TokenKind.OVERRIDE) ||
        context.peek(TokenKind.PRIVATE) ||
        context.peek(TokenKind.PROTECTED) ||
        context.peek(TokenKind.PUBLIC) ||
        context.peek(TokenKind.RETURN) ||
        context.peek(TokenKind.STATIC) ||
        context.peek(TokenKind.STRUCT) ||
        context.peek(TokenKind.SWITCH) ||
        context.peek(TokenKind.VIRTUAL) ||
        context.peek(TokenKind.WHILE))) {
      return true;
    }

    context.next();
  }

  return false;
}

Node parseGroup(ParserContext context) {
  if (!context.expect(TokenKind.LEFT_PARENTHESIS)) return null;
  Node value = pratt.parse(context, Precedence.LOWEST);
  scanForToken(context, TokenKind.RIGHT_PARENTHESIS, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return value;
}

Node parseName(ParserContext context) {
  Token token = context.current(); if (!context.expect(TokenKind.IDENTIFIER)) return null;
  return Node.createName(token.text).withRange(token.range);
}

Node parseBlock(ParserContext context, StatementHint hint) {
  Token token = context.current();
  if (!context.expect(TokenKind.LEFT_BRACE)) return null;
  List<Node> statements = parseStatements(context, hint);
  scanForToken(context, TokenKind.RIGHT_BRACE, TokenScan.NORMAL);
  return Node.createBlock(statements).withRange(context.spanSince(token.range));
}

Node parseBlockOrStatement(ParserContext context) {
  if (context.peek(TokenKind.LEFT_BRACE)) return parseBlock(context, StatementHint.NORMAL);
  Node statement = parseStatement(context, StatementHint.NORMAL); if (statement == null) return null;
  return Node.createBlock({ statement }).withRange(statement.range);
}

Node parseCaseStatement(ParserContext context) {
  Token token = context.current();
  List<Node> values = null;
  if (!context.eat(TokenKind.DEFAULT)) {
    if (!context.expect(TokenKind.CASE)) return null;
    values = {};
    do {
      values.push(pratt.parse(context, Precedence.COMMA));
    } while (context.eat(TokenKind.COMMA));
  }
  Node block = parseBlock(context, StatementHint.NORMAL); if (block == null) return null;
  return (values != null ? Node.createCase(values, block) : Node.createDefault(block)).withRange(context.spanSince(token.range));
}

List<Node> parseStatements(ParserContext context, StatementHint hint) {
  List<Node> statements = {};
  while (!context.peek(TokenKind.RIGHT_BRACE) && !context.peek(TokenKind.END_OF_FILE)) {
    if (hint == StatementHint.IN_ENUM) {
      Node declaration = parseEnumValueDeclaration(context); if (declaration == null) break;
      statements.push(declaration);
      if (!context.eat(TokenKind.COMMA)) break;
    } else {
      Node statement = hint == StatementHint.IN_SWITCH ? parseCaseStatement(context) : parseStatement(context, hint); if (statement == null) break;
      statements.push(statement);
    }
  }
  return statements;
}

Node parseArgumentVariables(ParserContext context) {
  Token token = context.current();
  List<Node> arguments = {};
  if (!context.expect(TokenKind.LEFT_PARENTHESIS)) return null;
  while (!context.peek(TokenKind.RIGHT_PARENTHESIS)) {
    if (arguments.length > 0 && !context.expect(TokenKind.COMMA)) break;
    Node type = parseType(context);
    Node name = parseName(context); if (name == null) break;
    arguments.push(Node.createVariable(name, type, null).withRange(Range.span(type.range, name.range)));
  }
  scanForToken(context, TokenKind.RIGHT_PARENTHESIS, TokenScan.NORMAL);
  return Node.createNodeList(arguments).withRange(context.spanSince(token.range));
}

Node parseType(ParserContext context) {
  return pratt.parse(context, Precedence.MEMBER - 1);
}

Node parseEnumValueDeclaration(ParserContext context) {
  Node name = parseName(context); if (name == null) return null;
  Node value = context.eat(TokenKind.ASSIGN) ? pratt.parse(context, Precedence.COMMA) : null;
  return Node.createVariable(name, null, value).withRange(context.spanSince(name.range));
}

Node parseParameter(ParserContext context) {
  Token token = context.current();
  Node name = parseName(context); if (name == null) return null;
  Node bound = context.eat(TokenKind.IS) ? pratt.parse(context, Precedence.COMMA) : null;
  return Node.createParameter(name, bound).withRange(context.spanSince(token.range));
}

Node parseParameters(ParserContext context) {
  Token token = context.current();
  List<Node> parameters = {};
  if (!context.eat(TokenKind.START_PARAMETER_LIST)) return null;
  while (parameters.length == 0 || !context.peek(TokenKind.END_PARAMETER_LIST)) {
    if (parameters.length > 0 && !context.expect(TokenKind.COMMA)) break;
    Node parameter = parseParameter(context); if (parameter == null) break;
    parameters.push(parameter);
  }
  scanForToken(context, TokenKind.END_PARAMETER_LIST, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return Node.createNodeList(parameters).withRange(context.spanSince(token.range));
}

enum AllowTrailingComma {
  NO,
  YES,
}

List<Node> parseArgumentList(ParserContext context, TokenKind left, TokenKind right, AllowTrailingComma comma) {
  List<Node> values = {};
  if (!context.expect(left)) return values;
  while (!context.peek(right)) {
    if (comma == AllowTrailingComma.NO && values.length > 0 && !context.expect(TokenKind.COMMA)) break;
    Node value = pratt.parse(context, Precedence.COMMA);
    values.push(value);
    if (value.kind == NodeKind.ERROR || comma == AllowTrailingComma.YES && !context.peek(right) && !context.expect(TokenKind.COMMA)) break;
  }
  scanForToken(context, right, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return values;
}

Node parseTypeList(ParserContext context) {
  Token token = context.current();
  List<Node> types = {};
  while (types.length == 0 || !context.peek(TokenKind.END_PARAMETER_LIST) && !context.peek(TokenKind.LEFT_BRACE)) {
    if (types.length > 0 && !context.expect(TokenKind.COMMA)) break;
    types.push(parseType(context));
  }
  return Node.createNodeList(types);
}

Node parseObject(ParserContext context, NodeKind kind) {
  Token token = context.next();
  Node name = parseName(context); if (name == null) return null;
  Node parameters = parseParameters(context);
  Node bases = context.eat(TokenKind.COLON) ? parseTypeList(context) : null;
  Node block = parseBlock(context, StatementHint.IN_OBJECT); if (block == null) return null;
  return Node.createObject(kind, name, parameters, bases, block).withRange(context.spanSince(token.range));
}

Node parseNestedNamespaceBlock(ParserContext context) {
  if (!context.eat(TokenKind.DOT)) {
    return parseBlock(context, StatementHint.NORMAL);
  }
  Node name = parseName(context); if (name == null) return null;
  Node block = parseNestedNamespaceBlock(context); if (block == null) return null;
  Range range = context.spanSince(name.range);
  return Node.createBlock({ Node.createNamespace(name, block).withRange(range) }).withRange(range);
}

Node parseNamespace(ParserContext context) {
  Token token = context.next();
  Node name = parseName(context); if (name == null) return null;
  Node block = parseNestedNamespaceBlock(context); if (block == null) return null;
  return Node.createNamespace(name, block).withRange(context.spanSince(token.range));
}

Node parseExpression(ParserContext context) {
  // Make sure we don't parse an initializer expression. The user is likely
  // trying to type a C-style block statement, which is not supported. An
  // initializer expression wouldn't make sense here anyway since there's no
  // type context yet at the start of an expression statement.
  if (context.peek(TokenKind.LEFT_BRACE)) {
    context.unexpectedToken();
    return null;
  }

  // Parse an expression
  Token token = context.current();
  Node value = pratt.parse(context, Precedence.LOWEST);
  if (!scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT) && context.current().range.start == token.range.start) {
    context.next(); // This is necessary to prevent an infinite loop when the first token of the expression is a syntax error
  }

  assert context.current().range.start >= token.range.end; // Make sure the context was advanced
  return Node.createExpression(value);
}

Node parseModifier(ParserContext context, SymbolFlag flag) {
  Token token = context.next();
  Node name = Node.createName(token.text).withRange(token.range);
  Node block = parseBlockOrStatement(context); if (block == null) return null;
  return Node.createModifier(name, block.removeChildren()).withRange(context.spanSince(token.range));
}

Node parseReturn(ParserContext context) {
  Token token = context.next();
  Node value = null;
  if (!context.eat(TokenKind.SEMICOLON)) {
    value = pratt.parse(context, Precedence.LOWEST);
    scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  }
  return Node.createReturn(value).withRange(context.spanSince(token.range));
}

Node parseBreak(ParserContext context) {
  Token token = context.next();
  context.expect(TokenKind.SEMICOLON); // No need to use scanForToken() here
  return Node.createBreak().withRange(context.spanSince(token.range));
}

Node parseContinue(ParserContext context) {
  Token token = context.next();
  context.expect(TokenKind.SEMICOLON); // No need to use scanForToken() here
  return Node.createContinue().withRange(context.spanSince(token.range));
}

Node parseAssert(ParserContext context) {
  Token token = context.next();
  Node value = pratt.parse(context, Precedence.LOWEST);
  scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return Node.createAssert(value).withRange(context.spanSince(token.range));
}

Node parseSwitch(ParserContext context) {
  Token token = context.next();
  Node value = parseGroup(context);
  Node block = parseBlock(context, StatementHint.IN_SWITCH); if (block == null) return null;
  return Node.createSwitch(value, block.removeChildren()).withRange(context.spanSince(token.range));
}

Node parseWhile(ParserContext context) {
  Token token = context.next();
  Node value = parseGroup(context);
  Node block = parseBlockOrStatement(context); if (block == null) return null;
  return Node.createWhile(value, block).withRange(context.spanSince(token.range));
}

Node parseDoWhile(ParserContext context) {
  Token token = context.next();
  Node block = parseBlockOrStatement(context); if (block == null) return null;
  if (!context.expect(TokenKind.WHILE)) return null;
  Node value = parseGroup(context);
  scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return Node.createDoWhile(block, value).withRange(context.spanSince(token.range));
}

Node parseIf(ParserContext context) {
  Token token = context.next();
  Node value = parseGroup(context);
  Node trueBlock = parseBlockOrStatement(context); if (trueBlock == null) return null;
  Node falseBlock = null;
  if (context.eat(TokenKind.ELSE)) {
    falseBlock = parseBlockOrStatement(context); if (falseBlock == null) return null;
  }
  return Node.createIf(value, trueBlock, falseBlock).withRange(context.spanSince(token.range));
}

Node parseExtension(ParserContext context) {
  Token token = context.next();
  Node name = parseName(context); if (name == null) return null;
  Node block = parseBlock(context, StatementHint.IN_OBJECT); if (block == null) return null;
  return Node.createExtension(name, block).withRange(context.spanSince(token.range));
}

Node parseEnum(ParserContext context) {
  Token token = context.next();
  NodeKind kind = NodeKind.ENUM;
  if (context.peek(TokenKind.IDENTIFIER) && context.current().text == "flags") {
    kind = NodeKind.ENUM_FLAGS;
    context.next();
  }
  Node name = parseName(context); if (name == null) return null;
  Node block = parseBlock(context, StatementHint.IN_ENUM); if (block == null) return null;
  return new Node(kind).withChildren({ name, block }).withRange(context.spanSince(token.range));
}

Node parseVariableCluster(ParserContext context, Node type, Node name) {
  Token token = context.current();
  List<Node> variables = {};
  while (variables.length == 0 || !context.peek(TokenKind.SEMICOLON)) {
    if (variables.length > 0 && !context.expect(TokenKind.COMMA)) break;
    if (name == null) name = parseName(context); if (name == null) break;
    Node value = context.eat(TokenKind.ASSIGN) ? pratt.parse(context, TokenKind.COMMA) : null;
    variables.push(Node.createVariable(name, null, value).withRange(context.spanSince(name.range)));
    name = null;
  }
  return Node.createVariableCluster(type, variables).withRange(context.spanSince(token.range));
}

Node parseFor(ParserContext context) {
  Token token = context.next();
  if (!context.expect(TokenKind.LEFT_PARENTHESIS)) return null;
  Node setup = null;
  Node test = null;
  Node update = null;
  do {
    if (!context.peek(TokenKind.SEMICOLON)) {
      setup = parseType(context);
      if (context.peek(TokenKind.IDENTIFIER)) {
        Node name = parseName(context);
        setup = name != null ? parseVariableCluster(context, setup, name) : null;
      } else if (!context.peek(TokenKind.SEMICOLON)) {
        setup = pratt.resume(context, Precedence.LOWEST, setup);
      }
    }
    if (!context.expect(TokenKind.SEMICOLON)) break;
    if (!context.peek(TokenKind.SEMICOLON)) test = pratt.parse(context, Precedence.LOWEST);
    if (!context.expect(TokenKind.SEMICOLON)) break;
    if (!context.peek(TokenKind.RIGHT_PARENTHESIS)) update = pratt.parse(context, Precedence.LOWEST);
  } while (false);
  scanForToken(context, TokenKind.RIGHT_PARENTHESIS, TokenScan.NORMAL);
  Node block = parseBlockOrStatement(context); if (block == null) return null;
  return Node.createFor(setup, test, update, block).withRange(context.spanSince(token.range));
}

Node parsePossibleTypedDeclaration(ParserContext context, StatementHint hint) {
  Node type = parseType(context);

  // Parse a constructor
  if (hint == StatementHint.IN_OBJECT && type.kind == NodeKind.NAME && context.peek(TokenKind.LEFT_PARENTHESIS)) {
    Node arguments = parseArgumentVariables(context); if (arguments == null) return null;
    Node block = null;
    if (!context.eat(TokenKind.SEMICOLON)) {
      block = parseBlock(context, StatementHint.NORMAL); if (block == null) return null;
    }
    return Node.createConstructor(type, arguments, block, null, null).withRange(context.spanSince(type.range));
  }

  // If this isn't a typed declaration, just parse an expression statement
  if (!context.peek(TokenKind.IDENTIFIER)) {
    Node value = pratt.resume(context, Precedence.LOWEST, type);
    scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
    return Node.createExpression(value).withRange(context.spanSince(type.range));
  }

  // Parse a typed declaration
  Node name = parseName(context); if (name == null) return null;

  // Function declaration
  if (context.peek(TokenKind.LEFT_PARENTHESIS)) {
    Node arguments = parseArgumentVariables(context); if (arguments == null) return null;
    Node block = null;
    if (!context.eat(TokenKind.SEMICOLON)) {
      block = parseBlock(context, StatementHint.NORMAL); if (block == null) return null;
    }
    return Node.createFunction(name, arguments, block, type).withRange(context.spanSince(type.range));
  }

  // Variable declaration
  Node cluster = parseVariableCluster(context, type, name);
  scanForToken(context, TokenKind.SEMICOLON, TokenScan.STOP_BEFORE_NEXT_STATEMENT);
  return cluster;
}

Node parseStatement(ParserContext context, StatementHint hint) {
  switch (context.current().kind) {
    case TokenKind.ASSERT { return parseAssert(context); }
    case TokenKind.BREAK { return parseBreak(context); }
    case TokenKind.CLASS { return parseObject(context, NodeKind.CLASS); }
    case TokenKind.CONTINUE { return parseContinue(context); }
    case TokenKind.DO { return parseDoWhile(context); }
    case TokenKind.ENUM { return parseEnum(context); }
    case TokenKind.EXPORT { return parseModifier(context, SymbolFlag.EXPORT); }
    case TokenKind.FINAL { return parseModifier(context, SymbolFlag.FINAL); }
    case TokenKind.FOR { return parseFor(context); }
    case TokenKind.IDENTIFIER { return parsePossibleTypedDeclaration(context, hint); }
    case TokenKind.IF { return parseIf(context); }
    case TokenKind.IMPORT { return parseModifier(context, SymbolFlag.IMPORT); }
    case TokenKind.IN { return parseExtension(context); }
    case TokenKind.INLINE { return parseModifier(context, SymbolFlag.INLINE); }
    case TokenKind.INTERFACE { return parseObject(context, NodeKind.INTERFACE); }
    case TokenKind.NAMESPACE { return parseNamespace(context); }
    case TokenKind.OVERRIDE { return parseModifier(context, SymbolFlag.OVERRIDE); }
    case TokenKind.PRIVATE { return parseModifier(context, SymbolFlag.PRIVATE); }
    case TokenKind.PROTECTED { return parseModifier(context, SymbolFlag.PROTECTED); }
    case TokenKind.PUBLIC { return parseModifier(context, SymbolFlag.PUBLIC); }
    case TokenKind.RETURN { return parseReturn(context); }
    case TokenKind.STATIC { return parseModifier(context, SymbolFlag.STATIC); }
    case TokenKind.STRUCT { return parseObject(context, NodeKind.STRUCT); }
    case TokenKind.SWITCH { return parseSwitch(context); }
    case TokenKind.VIRTUAL { return parseModifier(context, SymbolFlag.VIRTUAL); }
    case TokenKind.WHILE { return parseWhile(context); }
    default { return parseExpression(context); }
  }
}

Node parseFile(Log log, List<Token> tokens) {
  ParserContext context = new ParserContext(log, tokens);
  Token token = context.current();
  List<Node> statements = parseStatements(context, StatementHint.NORMAL); if (statements == null) return null;
  if (!context.expect(TokenKind.END_OF_FILE)) return null;
  Range range = context.spanSince(token.range);
  return Node.createFile(Node.createBlock(statements).withRange(range)).withRange(range);
}

class NameLiteral : ILiteralCallback {
  override Node run(ParserContext context, Token token) {
    return Node.createName(token.text).withRange(token.range);
  }
}

class TokenLiteral : ILiteralCallback {
  NodeKind kind;

  override Node run(ParserContext context, Token token) {
    return new Node(kind).withRange(token.range);
  }
}

class IntLiteral : ILiteralCallback {
  int base;

  override Node run(ParserContext context, Token token) {
    double value = parseIntLiteral(token.text, base);
    if (value != value) syntaxErrorInvalidInteger(context.log, token.range, token.text);
    return Node.createInt((int)value).withRange(token.range);
  }
}

class FloatLiteral : ILiteralCallback {
  override Node run(ParserContext context, Token token) {
    return Node.createFloat(parseDoubleLiteral(token.text.slice(0, token.text.length - 1))).withRange(token.range);
  }
}

class DoubleLiteral : ILiteralCallback {
  override Node run(ParserContext context, Token token) {
    return Node.createDouble(parseDoubleLiteral(token.text)).withRange(token.range);
  }
}

class StringLiteral : ILiteralCallback {
  override Node run(ParserContext context, Token token) {
    StringContent result = parseStringLiteral(context.log, token.range, token.text);

    // Don't return null on failure because this doesn't affect the rest of the compilation
    return Node.createString(result != null ? result.value : "").withRange(token.range);
  }
}

class CharacterLiteral : ILiteralCallback {
  override Node run(ParserContext context, Token token) {
    StringContent result = parseStringLiteral(context.log, token.range, token.text);

    // TODO: Do true unicode code point parsing
    if (result != null && result.value.length != 1) {
      syntaxErrorInvalidCharacter(context.log, token.range, token.text);
      result = null;
    }

    // Don't return null on failure because this doesn't affect the rest of the compilation
    return Node.createInt(result != null ? result.value.codeUnitAt(0) : 0).withRange(token.range);
  }
}

class InitializerParselet : IPrefixParselet {
  override Node run(ParserContext context) {
    Token token = context.current();
    List<Node> arguments = parseArgumentList(context, TokenKind.LEFT_BRACE, TokenKind.RIGHT_BRACE, AllowTrailingComma.YES);
    return Node.createInitializer(arguments).withRange(context.spanSince(token.range));
  }
}

bool looksLikeType(Node node) {
  switch (node.kind) {
    case NodeKind.DOT { return looksLikeType(node.dotTarget()); }
    case NodeKind.NAME { return true; }
    case NodeKind.PARAMETERIZE { return true; }
    default { return false; }
  }
}

class GroupParselet : IPrefixParselet {
  override Node run(ParserContext context) {
    Token token = context.current();
    Node type = parseGroup(context);
    if (looksLikeType(type)) {
      Node value = pratt.parse(context, Precedence.UNARY_PREFIX);
      return Node.createCast(type, value).withRange(context.spanSince(token.range));
    }
    return type;
  }
}

class HookInfix : IInfixParselet {
  override Node run(ParserContext context, Node left) {
    context.next();
    Node middle = pratt.parse(context, Precedence.ASSIGN - 1);
    Node right = context.expect(TokenKind.COLON) ? pratt.parse(context, Precedence.ASSIGN - 1) : Node.createError().withRange(context.spanSince(context.current().range));
    return Node.createHook(left, middle, right).withRange(context.spanSince(left.range));
  }
}

class SequenceInfix : IInfixParselet {
  override Node run(ParserContext context, Node left) {
    List<Node> values = { left };
    while (context.eat(TokenKind.COMMA)) {
      values.push(pratt.parse(context, Precedence.COMMA));
    }
    return Node.createSequence(values).withRange(context.spanSince(left.range));
  }
}

Pratt createParser() {
  Pratt pratt = new Pratt();

  // Literals
  pratt.literal(TokenKind.IDENTIFIER, new NameLiteral());
  pratt.literal(TokenKind.NULL, new TokenLiteral(NodeKind.NULL));
  pratt.literal(TokenKind.THIS, new TokenLiteral(NodeKind.THIS));
  pratt.literal(TokenKind.TRUE, new TokenLiteral(NodeKind.TRUE));
  pratt.literal(TokenKind.FALSE, new TokenLiteral(NodeKind.FALSE));
  pratt.literal(TokenKind.INT_DECIMAL, new IntLiteral(10));
  pratt.literal(TokenKind.INT_BINARY, new IntLiteral(2));
  pratt.literal(TokenKind.INT_OCTAL, new IntLiteral(8));
  pratt.literal(TokenKind.INT_HEX, new IntLiteral(16));
  pratt.literal(TokenKind.FLOAT, new FloatLiteral());
  pratt.literal(TokenKind.DOUBLE, new DoubleLiteral());
  pratt.literal(TokenKind.STRING, new StringLiteral());
  pratt.literal(TokenKind.CHARACTER, new CharacterLiteral());

  // Other expressions
  pratt.parselet(TokenKind.LEFT_BRACE, Precedence.LOWEST).prefix = new InitializerParselet();
  pratt.parselet(TokenKind.LEFT_PARENTHESIS, Precedence.LOWEST).prefix = new GroupParselet();
  pratt.parselet(TokenKind.QUESTION_MARK, Precedence.ASSIGN).infix = new HookInfix();
  pratt.parselet(TokenKind.COMMA, Precedence.COMMA).infix = new SequenceInfix();

  return pratt;
}

final Pratt pratt = createParser();
