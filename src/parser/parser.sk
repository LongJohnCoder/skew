// The same operator precedence as C for the most part
enum Precedence {
  LOWEST,
  COMMA,
  ASSIGN,
  LOGICAL_OR,
  LOGICAL_AND,
  BITWISE_OR,
  BITWISE_XOR,
  BITWISE_AND,
  EQUAL,
  COMPARE,
  SHIFT,
  ADD,
  MULTIPLY,
  UNARY_PREFIX,
  UNARY_POSTFIX,
  MEMBER,
}

in Precedence {
  Precedence incrementIfLeftAssociative(Associativity associativity) {
    return (Precedence)(this + (int)(associativity == .LEFT));
  }

  Precedence incrementIfRightAssociative(Associativity associativity) {
    return (Precedence)(this + (int)(associativity == .RIGHT));
  }
}

enum StatementHint {
  NORMAL,
  IN_ENUM,
  IN_OBJECT,
  IN_SWITCH,
}

enum TokenScan {
  NORMAL,
  STOP_BEFORE_NEXT_STATEMENT,
}

enum AllowLambda {
  LAMBDA_NOT_ALLOWED,
  LAMBDA_ALLOWED,
}

// Parser recovery is done by skipping to the next closing token after an error
bool scanForToken(ParserContext context, TokenKind kind, TokenScan tokenScan) {
  if (context.expect(kind)) {
    return true;
  }

  // Scan until the next closing token
  while (!context.peek(.END_OF_FILE)) {
    switch (context.current().kind) {
      case .RIGHT_PARENTHESIS, .RIGHT_BRACKET, .RIGHT_BRACE {
        return context.eat(kind);
      }

      case .SEMICOLON {
        if (tokenScan == .STOP_BEFORE_NEXT_STATEMENT) {
          return context.eat(kind);
        }
      }

      case
        .ALIAS, .ASSERT, .BREAK, .CLASS, .CONTINUE, .DO, .ENUM, .EXPORT, .FINAL, .FOR,
        .IF, .IMPORT, .INLINE, .INTERFACE, .NAMESPACE, .OVERRIDE, .PRIVATE, .PROTECTED,
        .PUBLIC, .RETURN, .STATIC, .STRUCT, .SWITCH, .USING, .VIRTUAL, .WHILE {

        // Optionally recover parsing before the next statement if it's unambiguous
        if (tokenScan == .STOP_BEFORE_NEXT_STATEMENT) {
          return true;
        }
      }
    }
    context.next();
  }

  return false;
}

Node parseGroup(ParserContext context, AllowLambda allowLambda) {
  var token = context.current();
  if (!context.expect(.LEFT_PARENTHESIS)) return null;
  if (allowLambda == .LAMBDA_NOT_ALLOWED || !context.eat(.RIGHT_PARENTHESIS)) {
    var value = pratt.parse(context, Precedence.LOWEST);
    scanForToken(context, .RIGHT_PARENTHESIS, .STOP_BEFORE_NEXT_STATEMENT);
    return value;
  }
  if (!context.peek(.LAMBDA)) {
    context.expect(.LAMBDA);
    return Node.createError().withRange(context.spanSince(token.range));
  }
  return Node.createSequence([]).withRange(context.spanSince(token.range));
}

Node parseName(ParserContext context) {
  var token = context.current(); if (!context.expect(.IDENTIFIER)) return null;
  return Node.createName(token.text).withRange(token.range);
}

Node parseBlock(ParserContext context, StatementHint hint) {
  var token = context.current();
  if (!context.expect(.LEFT_BRACE)) return null;
  var statements = parseStatements(context, hint);
  scanForToken(context, .RIGHT_BRACE, .NORMAL);
  return Node.createBlock(statements).withRange(context.spanSince(token.range));
}

Node parseBlockOrStatement(ParserContext context, StatementHint hint) {
  if (context.peek(.LEFT_BRACE)) return parseBlock(context, hint);
  var statement = parseStatement(context, hint); if (statement == null) return null;
  return Node.createBlock([statement]).withRange(statement.range);
}

Node parseLambdaBlock(ParserContext context) {
  if (context.peek(.LEFT_BRACE)) {
    return parseBlock(context, .NORMAL);
  }
  if (context.peek(.RIGHT_PARENTHESIS) ||
      context.peek(.COMMA) ||
      context.peek(.SEMICOLON)) {
    return Node.createBlock([]);
  }
  var value = pratt.parse(context, Precedence.COMMA);
  return Node.createBlock([Node.createImplicitReturn(value).withRange(value.range)]).withRange(value.range);
}

Node parseCaseStatement(ParserContext context) {
  var token = context.current();
  List<Node> values = [];
  if (!context.eat(.DEFAULT)) {
    if (!context.expect(.CASE)) return null;
    do {
      // Make sure we don't parse an initializer expression here. The user is
      // likely in the middle of typing a case statement and trying to parse an
      // initializer expression will generate many confusing errors as the
      // parser tries to interpret the case block as an initializer expression.
      // An initializer expression here will still work if it's wrapped in
      // parentheses.
      if (context.peek(.LEFT_BRACE)) {
        context.unexpectedToken();
        values.push(Node.createError()); // Make sure this case doesn't look like a default case
        break;
      }

      values.push(pratt.parse(context, Precedence.COMMA));
    } while (context.eat(.COMMA));
  }
  var block = parseBlock(context, .NORMAL); if (block == null) return null;
  return Node.createCase(values, block).withRange(context.spanSince(token.range));
}

List<Node> parseStatements(ParserContext context, StatementHint hint) {
  List<Node> statements = [];
  while (!context.peek(.RIGHT_BRACE) && !context.peek(.END_OF_FILE)) {
    if (hint == .IN_ENUM) {
      var declaration = parseEnumValueDeclaration(context); if (declaration == null) break;
      statements.push(declaration);
      if (!context.eat(.COMMA)) break;
    } else {
      var statement = hint == .IN_SWITCH ? parseCaseStatement(context) : parseStatement(context, hint); if (statement == null) break;
      statements.push(statement);
    }
  }
  return statements;
}

Node parseArgumentVariables(ParserContext context) {
  var token = context.current();
  List<Node> arguments = [];
  if (!context.expect(.LEFT_PARENTHESIS)) return null;
  while (!context.peek(.RIGHT_PARENTHESIS)) {
    if (arguments.length > 0 && !context.expect(.COMMA)) break;
    var type = parseType(context);
    var name = parseName(context); if (name == null) break;
    arguments.push(Node.createVariable(name, type, null).withRange(Range.span(type.range, name.range)));
  }
  scanForToken(context, .RIGHT_PARENTHESIS, .NORMAL);
  return Node.createNodeList(arguments).withRange(context.spanSince(token.range));
}

Node parseType(ParserContext context) {
  return pratt.parse(context, Precedence.MEMBER - 1);
}

Node parseEnumValueDeclaration(ParserContext context) {
  var name = parseName(context); if (name == null) return null;
  var value = context.eat(.ASSIGN) ? pratt.parse(context, Precedence.COMMA) : null;
  return Node.createVariable(name, null, value).withRange(context.spanSince(name.range));
}

Node parseParameter(ParserContext context) {
  var token = context.current();
  var name = parseName(context); if (name == null) return null;
  var bound = context.eat(.IS) ? pratt.parse(context, Precedence.COMMA) : null;
  return Node.createParameter(name, bound).withRange(context.spanSince(token.range));
}

Node parseParameters(ParserContext context) {
  var token = context.current();
  List<Node> parameters = [];
  if (!context.eat(.START_PARAMETER_LIST)) return null;
  while (parameters.length == 0 || !context.peek(.END_PARAMETER_LIST)) {
    if (parameters.length > 0 && !context.expect(.COMMA)) break;
    var parameter = parseParameter(context); if (parameter == null) break;
    parameters.push(parameter);
  }
  scanForToken(context, .END_PARAMETER_LIST, .STOP_BEFORE_NEXT_STATEMENT);
  return Node.createNodeList(parameters).withRange(context.spanSince(token.range));
}

enum AllowTrailingComma {
  NO_TRAILING_COMMA,
  TRAILING_COMMA,
}

List<Node> parseArgumentList(ParserContext context, TokenKind left, TokenKind right, AllowTrailingComma comma) {
  List<Node> values = [];
  if (!context.expect(left)) return values;
  while (!context.peek(right)) {
    if (comma == .NO_TRAILING_COMMA && values.length > 0 && !context.expect(.COMMA)) break;
    var value = pratt.parse(context, Precedence.COMMA);
    values.push(value);
    if (value.kind.isError() || comma == .TRAILING_COMMA && !context.peek(right) && !context.expect(.COMMA)) break;
  }
  scanForToken(context, right, .STOP_BEFORE_NEXT_STATEMENT);
  return values;
}

List<Node> parseTypeList(ParserContext context, TokenKind end) {
  var token = context.current();
  List<Node> types = [];
  while (types.length == 0 || !context.peek(end)) {
    // Make sure we don't parse an initializer expression. The user is likely
    // in the middle of typing an object base type list and trying to parse an
    // initializer expression will generate many confusing errors as the parser
    // tries to interpret the object block as an initializer expression.
    if (context.peek(.LEFT_BRACE)) {
      context.unexpectedToken();
      break;
    }

    // Commas must come between types
    if (types.length > 0 && !context.eat(.COMMA)) {
      context.expect(end); // Expecting the end token here makes more sense than a comma
      break;
    }

    // Also prevent initializer expression parsing after a comma
    if (context.peek(.LEFT_BRACE)) {
      context.unexpectedToken();
      break;
    }

    types.push(parseType(context));
  }
  return types;
}

Node parseObject(ParserContext context, NodeKind kind) {
  var token = context.next();
  var name = parseName(context); if (name == null) return null;
  var parameters = parseParameters(context);
  var bases = context.eat(.COLON) ? Node.createNodeList(parseTypeList(context, .LEFT_BRACE)) : null;
  var block = parseBlock(context, .IN_OBJECT); if (block == null) return null;
  return Node.createObject(kind, name, parameters, bases, block).withRange(context.spanSince(token.range));
}

Node parseNestedNamespaceBlock(ParserContext context) {
  if (!context.eat(.DOT)) {
    return parseBlock(context, .NORMAL);
  }
  var name = parseName(context); // Allow this to be null for autocomplete
  var block = parseNestedNamespaceBlock(context); if (block == null) return null;
  var range = context.spanSince((name != null ? name : block).range);
  return Node.createBlock([Node.createNamespace(name, block).withRange(range)]).withRange(range);
}

Node parseNamespace(ParserContext context) {
  var token = context.next();
  var name = parseName(context); if (name == null) return null;
  var block = parseNestedNamespaceBlock(context); if (block == null) return null;
  return Node.createNamespace(name, block).withRange(context.spanSince(token.range));
}

Node parseConstructor(ParserContext context, StatementHint hint) {
  if (hint != .IN_OBJECT) {
    context.unexpectedToken();
    return null;
  }

  // Parse a constructor
  var token = context.next();
  var name = Node.createName(token.text).withRange(token.range);
  var arguments = parseArgumentVariables(context); if (arguments == null) return null;
  Node superInitializer = null;
  Node memberInitializers = null;

  // Parse the initializer list
  if (context.eat(.COLON)) {

    // The super initializer can have multiple arguments
    if (context.peek(.SUPER)) {
      superInitializer = parseSuperCall(context);
    }

    // Each member initializer has one argument
    if (superInitializer == null || context.eat(.COMMA)) {
      List<Node> values = [];
      var first = context.current();
      do {
        var member = parseName(context); if (member == null) break;
        if (!context.expect(.ASSIGN)) break;
        var value = pratt.parse(context, Precedence.COMMA);
        values.push(Node.createMemberInitializer(member, value).withRange(context.spanSince(member.range)));
      } while (context.eat(.COMMA));
      memberInitializers = Node.createNodeList(values).withRange(context.spanSince(first.range));
    }
  }

  Node block = null;
  if (!context.eat(.SEMICOLON)) {
    block = parseBlock(context, .NORMAL); if (block == null) return null;
  }
  return Node.createConstructor(name, arguments, block, superInitializer, memberInitializers).withRange(context.spanSince(token.range));
}

Node parseExpression(ParserContext context) {
  // Make sure we don't parse an initializer expression. The user is likely
  // trying to type a C-style block statement, which is not supported. An
  // initializer expression wouldn't make sense here anyway since there's no
  // type context yet at the start of an expression statement.
  if (context.peek(.LEFT_BRACE)) {
    context.unexpectedToken();
    return null;
  }

  // Parse an expression
  var token = context.current();
  var value = pratt.parse(context, Precedence.LOWEST);
  if (!scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT) && context.current().range.start == token.range.start) {
    context.next(); // This is necessary to prevent an infinite loop when the first token of the expression is a syntax error
  }

  assert context.current().range.start >= token.range.end; // Make sure the context was advanced
  return Node.createExpression(value).withRange(context.spanSince(token.range));
}

Node parseModifier(ParserContext context, StatementHint hint, SymbolFlag flag) {
  var token = context.next();
  var name = Node.createName(token.text).withRange(token.range);
  var block = parseBlockOrStatement(context, hint); if (block == null) return null;
  return Node.createModifier(name, block.removeChildren()).withRange(context.spanSince(token.range));
}

Node parseReturn(ParserContext context) {
  var token = context.next();
  Node value = null;
  if (!context.eat(.SEMICOLON)) {
    value = pratt.parse(context, Precedence.LOWEST);
    scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
  }
  return Node.createReturn(value).withRange(context.spanSince(token.range));
}

Node parseBreak(ParserContext context) {
  var token = context.next();
  context.expect(.SEMICOLON); // No need to use scanForToken() here
  return Node.createBreak().withRange(context.spanSince(token.range));
}

Node parseContinue(ParserContext context) {
  var token = context.next();
  context.expect(.SEMICOLON); // No need to use scanForToken() here
  return Node.createContinue().withRange(context.spanSince(token.range));
}

Node parseAssert(ParserContext context) {
  var token = context.next();
  var isConst = context.eat(.CONST);
  var value = pratt.parse(context, Precedence.LOWEST);
  scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
  return Node.createAssert(isConst ? .ASSERT_CONST : .ASSERT, value).withRange(context.spanSince(token.range));
}

Node parseSwitch(ParserContext context) {
  var token = context.next();
  var value = parseGroup(context, .LAMBDA_NOT_ALLOWED); if (value == null) return null;
  var block = parseBlock(context, .IN_SWITCH); if (block == null) return null;
  return Node.createSwitch(value, block.removeChildren()).withRange(context.spanSince(token.range));
}

Node parseWhile(ParserContext context) {
  var token = context.next();
  var value = parseGroup(context, .LAMBDA_NOT_ALLOWED); if (value == null) return null;
  var block = parseBlockOrStatement(context, .NORMAL); if (block == null) return null;
  return Node.createWhile(value, block).withRange(context.spanSince(token.range));
}

Node parseDoWhile(ParserContext context) {
  var token = context.next();
  var block = parseBlockOrStatement(context, .NORMAL); if (block == null) return null;
  if (!context.expect(.WHILE)) return null;
  var value = parseGroup(context, .LAMBDA_NOT_ALLOWED);
  scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
  return Node.createDoWhile(block, value).withRange(context.spanSince(token.range));
}

Node parseIf(ParserContext context) {
  var token = context.next();
  var value = parseGroup(context, .LAMBDA_NOT_ALLOWED); if (value == null) return null;
  var trueBlock = parseBlockOrStatement(context, .NORMAL); if (trueBlock == null) return null;
  Node falseBlock = null;
  if (context.eat(.ELSE)) {
    falseBlock = parseBlockOrStatement(context, .NORMAL); if (falseBlock == null) return null;
  }
  return Node.createIf(value, trueBlock, falseBlock).withRange(context.spanSince(token.range));
}

Node parseExtension(ParserContext context) {
  var token = context.next();
  var name = parseName(context); if (name == null) return null;
  var bases = context.eat(.COLON) ? Node.createNodeList(parseTypeList(context, .LEFT_BRACE)) : null;
  var block = parseBlock(context, .IN_OBJECT); if (block == null) return null;
  return Node.createExtension(name, bases, block).withRange(context.spanSince(token.range));
}

Node parseEnum(ParserContext context) {
  var token = context.next();
  var isFlags = false;
  if (context.peek(.IDENTIFIER) && context.current().text == "flags") {
    isFlags = true;
    context.next();
  }
  var name = parseName(context); if (name == null) return null;
  var block = parseBlock(context, .IN_ENUM); if (block == null) return null;
  return (isFlags ? Node.createEnumFlags(name, block) : Node.createEnum(name, block)).withRange(context.spanSince(token.range));
}

Node parseVariableCluster(ParserContext context, Node type, Node name) {
  List<Node> variables = [];
  var start = type;
  while (variables.length == 0 || !context.peek(.SEMICOLON) && !context.peek(.IN)) {
    if (variables.length > 0 && !context.eat(.COMMA)) {
      context.expect(.SEMICOLON); // Expecting a semicolon here makes more sense than a comma
      break;
    }
    if (name == null) name = start = parseName(context); if (name == null) break;
    var value = context.eat(.ASSIGN) ? pratt.parse(context, Precedence.COMMA) : null;
    variables.push(Node.createVariable(name, null, value).withRange(context.spanSince(start.range)));
    name = null;
  }
  return Node.createVariableCluster(type, variables).withRange(context.spanSince(type.range));
}

Node parseFor(ParserContext context) {
  var token = context.next();
  if (!context.expect(.LEFT_PARENTHESIS)) return null;
  Node setup = null;
  Node test = null;
  Node update = null;
  do {
    if (!context.peek(.SEMICOLON) && !context.peek(.RIGHT_PARENTHESIS)) {
      setup = parseType(context);
      if (context.peek(.IDENTIFIER)) {
        var name = parseName(context);
        setup = name != null ? parseVariableCluster(context, setup, name) : null;
        if (setup != null && context.eat(.IN)) {
          var values = pratt.parse(context, Precedence.LOWEST);
          scanForToken(context, .RIGHT_PARENTHESIS, .NORMAL);
          var body = parseBlockOrStatement(context, .NORMAL); if (body == null) return null;
          var variables = setup.clusterVariables();
          if (variables.length > 1) syntaxErrorBadForEach(context.log, setup.range);
          var name = variables.get(0).declarationName().remove();
          var value = Node.createVariable(name, setup.clusterType().remove(), null).withRange(name.range);
          return Node.createForEach(value, values, body).withRange(context.spanSince(token.range));
        }
      } else if (!context.peek(.SEMICOLON)) {
        setup = pratt.resume(context, Precedence.LOWEST, setup);
      }
    }
    if (!context.expect(.SEMICOLON)) break;
    if (!context.peek(.SEMICOLON) && !context.peek(.RIGHT_PARENTHESIS)) test = pratt.parse(context, Precedence.LOWEST);
    if (!context.expect(.SEMICOLON)) break;
    if (!context.peek(.RIGHT_PARENTHESIS)) update = pratt.parse(context, Precedence.LOWEST);
  } while (false);
  scanForToken(context, .RIGHT_PARENTHESIS, .NORMAL);
  var block = parseBlockOrStatement(context, .NORMAL); if (block == null) return null;
  return Node.createFor(setup, test, update, block).withRange(context.spanSince(token.range));
}

Node parseSuperCall(ParserContext context) {
  var token = context.next();
  var values = parseArgumentList(context, .LEFT_PARENTHESIS, .RIGHT_PARENTHESIS, .NO_TRAILING_COMMA);
  return Node.createSuperCall(values).withRange(context.spanSince(token.range));
}

Node parsePossibleTypedDeclaration(ParserContext context, StatementHint hint) {
  var type = parseType(context);

  // If this isn't a typed declaration, just parse an expression statement
  if (!context.peek(.IDENTIFIER)) {
    var value = pratt.resume(context, Precedence.LOWEST, type);
    scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
    return Node.createExpression(value).withRange(context.spanSince(type.range));
  }

  // Parse a typed declaration
  var name = parseName(context); if (name == null) return null;

  // Function declaration
  if (context.peek(.LEFT_PARENTHESIS)) {
    var arguments = parseArgumentVariables(context); if (arguments == null) return null;
    Node block = null;
    if (!context.eat(.SEMICOLON)) {
      block = parseBlock(context, .NORMAL); if (block == null) return null;
    }
    return Node.createFunction(name, arguments, block, type).withRange(context.spanSince(type.range));
  }

  // Variable declaration
  var cluster = parseVariableCluster(context, type, name);
  scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
  var last = cluster.lastChild();
  last.withRange(context.spanSince(last.range));
  return cluster;
}

Node parseUsing(ParserContext context) {
  var token = context.next();
  var value = pratt.parse(context, Precedence.LOWEST);
  scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
  return Node.createUsing(value).withRange(context.spanSince(token.range));
}

Node parseAlias(ParserContext context) {
  var token = context.next();
  var name = parseName(context);
  if (name == null || !context.expect(.ASSIGN)) {
    scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
    var range = context.spanSince(token.range);
    return Node.createExpression(Node.createError().withRange(range)).withRange(range);
  }
  var value = pratt.parse(context, Precedence.LOWEST);
  scanForToken(context, .SEMICOLON, .STOP_BEFORE_NEXT_STATEMENT);
  return Node.createAlias(name, value).withRange(context.spanSince(token.range));
}

bool looksLikeLambdaArguments(Node node) {
  if (node.kind == .SEQUENCE) {
    for (var i = 0; i < node.children.length; i++) {
      if (node.children.get(i).kind != .NAME) {
        return false;
      }
    }
    return true;
  }
  return false;
}

Node createLambdaFromNames(List<Node> names, Node block) {
  for (var i = 0; i < names.length; i++) {
    var name = names.get(i);
    assert name.kind == .NAME;
    names.set(i, Node.createVariable(name, null, null).withRange(name.range));
  }
  return Node.createLambda(names, block);
}

bool looksLikeType(Node node) {
  switch (node.kind) {
    case .DOT {
      var target = node.dotTarget();
      return target != null && looksLikeType(target);
    }
    case .NAME, .PARAMETERIZE, .FUNCTION_TYPE { return true; }
    default { return false; }
  }
}

Node parseStatement(ParserContext context, StatementHint hint) {
  // Separating the case bodies into separate functions makes the JavaScript JIT go faster
  switch (context.current().kind) {
    case .ALIAS { return parseAlias(context); }
    case .ASSERT { return parseAssert(context); }
    case .BREAK { return parseBreak(context); }
    case .CLASS { return parseObject(context, .CLASS); }
    case .CONST { return parseModifier(context, hint, .CONST); }
    case .CONTINUE { return parseContinue(context); }
    case .DO { return parseDoWhile(context); }
    case .ENUM { return parseEnum(context); }
    case .EXPORT { return parseModifier(context, hint, .EXPORT); }
    case .FINAL { return parseModifier(context, hint, .FINAL); }
    case .FOR { return parseFor(context); }
    case .IDENTIFIER, .VAR { return parsePossibleTypedDeclaration(context, hint); }
    case .IF { return parseIf(context); }
    case .IMPORT { return parseModifier(context, hint, .IMPORT); }
    case .IN { return parseExtension(context); }
    case .INLINE { return parseModifier(context, hint, .INLINE); }
    case .INTERFACE { return parseObject(context, .INTERFACE); }
    case .NAMESPACE { return parseNamespace(context); }
    case .NEW { return parseConstructor(context, hint); }
    case .OVERRIDE { return parseModifier(context, hint, .OVERRIDE); }
    case .PRIVATE { return parseModifier(context, hint, .PRIVATE); }
    case .PROTECTED { return parseModifier(context, hint, .PROTECTED); }
    case .PUBLIC { return parseModifier(context, hint, .PUBLIC); }
    case .RETURN { return parseReturn(context); }
    case .STATIC { return parseModifier(context, hint, .STATIC); }
    case .STRUCT { return parseObject(context, .STRUCT); }
    case .SWITCH { return parseSwitch(context); }
    case .USING { return parseUsing(context); }
    case .VIRTUAL { return parseModifier(context, hint, .VIRTUAL); }
    case .WHILE { return parseWhile(context); }
    default { return parseExpression(context); }
  }
}

Node parseFile(Log log, List<Token> tokens) {
  var context = ParserContext(log, tokens);
  var token = context.current();
  var statements = parseStatements(context, .NORMAL); if (statements == null) return null;
  if (!context.expect(.END_OF_FILE)) return null;
  var range = context.spanSince(token.range);
  return Node.createFile(Node.createBlock(statements).withRange(range)).withRange(range);
}

LiteralCallback tokenLiteral(NodeKind kind) {
  return (context, token) => Node(kind).withRange(token.range);
}

LiteralCallback intLiteral(int base) {
  return (context, token) => {
    var value = parseIntLiteral(token.text, base);
    if (value != value) {
      syntaxErrorInvalidInteger(context.log, token.range, token.text);
    } else if (base == 10 && value != 0 && token.text.codeUnitAt(0) == '0') {
      syntaxWarningOctal(context.log, token.range);
    }
    return Node.createInt((int)value).withRange(token.range);
  };
}

PostfixCallback unaryPostfix(NodeKind kind) {
  return (context, value, token) => Node.createUnary(kind, value).withRange(Range.span(value.range, token.range));
}

PrefixCallback unaryPrefix(NodeKind kind) {
  return (context, token, value) => Node.createUnary(kind, value).withRange(Range.span(token.range, value.range));
}

InfixCallback binaryInfix(NodeKind kind) {
  return (context, left, token, right) => Node.createBinary(kind, left, right).withRange(Range.span(left.range, right.range));
}

void createParser() {
  if (pratt != null) return;
  pratt = Pratt();

  ////////////////////////////////////////////////////////////////////////////////
  // Literals
  ////////////////////////////////////////////////////////////////////////////////

  pratt.literal(.NULL, tokenLiteral(.NULL));
  pratt.literal(.THIS, tokenLiteral(.THIS));
  pratt.literal(.TRUE, (context, token) => Node.createBool(true).withRange(token.range));
  pratt.literal(.FALSE, (context, token) => Node.createBool(false).withRange(token.range));
  pratt.literal(.INT_DECIMAL, intLiteral(10));
  pratt.literal(.INT_BINARY, intLiteral(2));
  pratt.literal(.INT_OCTAL, intLiteral(8));
  pratt.literal(.INT_HEX, intLiteral(16));
  pratt.literal(.FLOAT, (context, token) => Node.createFloat(parseDoubleLiteral(token.text.slice(0, token.text.length - 1))).withRange(token.range));
  pratt.literal(.DOUBLE, (context, token) => Node.createDouble(parseDoubleLiteral(token.text)).withRange(token.range));
  pratt.literal(.VAR, (context, token) => Node.createVar().withRange(token.range));
  pratt.literal(.STRING, (context, token) => {
    var result = parseStringLiteral(context.log, token.range, token.text);

    // Don't return null on failure because this doesn't affect the rest of the compilation
    return Node.createString(result != null ? result.value : "").withRange(token.range);
  });
  pratt.literal(.CHARACTER, (context, token) => {
    var result = parseStringLiteral(context.log, token.range, token.text);

    // TODO: Do true unicode code point parsing
    if (result != null && result.value.length != 1) {
      syntaxErrorInvalidCharacter(context.log, token.range, token.text);
      result = null;
    }

    // Don't return null on failure because this doesn't affect the rest of the compilation
    return Node.createInt(result != null ? result.value.codeUnitAt(0) : 0).withRange(token.range);
  });

  ////////////////////////////////////////////////////////////////////////////////
  // Unary expressions
  ////////////////////////////////////////////////////////////////////////////////

  pratt.postfix(.INCREMENT, Precedence.UNARY_POSTFIX, unaryPostfix(.POSTFIX_INCREMENT));
  pratt.postfix(.DECREMENT, Precedence.UNARY_POSTFIX, unaryPostfix(.POSTFIX_DECREMENT));
  pratt.prefix(.INCREMENT, Precedence.UNARY_PREFIX, unaryPrefix(.PREFIX_INCREMENT));
  pratt.prefix(.DECREMENT, Precedence.UNARY_PREFIX, unaryPrefix(.PREFIX_DECREMENT));
  pratt.prefix(.PLUS, Precedence.UNARY_PREFIX, unaryPrefix(.POSITIVE));
  pratt.prefix(.MINUS, Precedence.UNARY_PREFIX, unaryPrefix(.NEGATIVE));
  pratt.prefix(.NOT, Precedence.UNARY_PREFIX, unaryPrefix(.NOT));
  pratt.prefix(.DELETE, Precedence.UNARY_PREFIX, unaryPrefix(.DELETE));
  pratt.prefix(.TILDE, Precedence.UNARY_PREFIX, unaryPrefix(.COMPLEMENT));

  ////////////////////////////////////////////////////////////////////////////////
  // Binary expressions
  ////////////////////////////////////////////////////////////////////////////////

  pratt.infix(.BITWISE_AND, Precedence.BITWISE_AND, binaryInfix(.BITWISE_AND));
  pratt.infix(.BITWISE_OR, Precedence.BITWISE_OR, binaryInfix(.BITWISE_OR));
  pratt.infix(.BITWISE_XOR, Precedence.BITWISE_XOR, binaryInfix(.BITWISE_XOR));
  pratt.infix(.DIVIDE, Precedence.MULTIPLY, binaryInfix(.DIVIDE));
  pratt.infix(.EQUAL, Precedence.EQUAL, binaryInfix(.EQUAL));
  pratt.infix(.GREATER_THAN, Precedence.COMPARE, binaryInfix(.GREATER_THAN));
  pratt.infix(.GREATER_THAN_OR_EQUAL, Precedence.COMPARE, binaryInfix(.GREATER_THAN_OR_EQUAL));
  pratt.infix(.IN, Precedence.COMPARE, binaryInfix(.IN));
  pratt.infix(.LESS_THAN, Precedence.COMPARE, binaryInfix(.LESS_THAN));
  pratt.infix(.LESS_THAN_OR_EQUAL, Precedence.COMPARE, binaryInfix(.LESS_THAN_OR_EQUAL));
  pratt.infix(.LOGICAL_AND, Precedence.LOGICAL_AND, binaryInfix(.LOGICAL_AND));
  pratt.infix(.LOGICAL_OR, Precedence.LOGICAL_OR, binaryInfix(.LOGICAL_OR));
  pratt.infix(.MINUS, Precedence.ADD, binaryInfix(.SUBTRACT));
  pratt.infix(.MULTIPLY, Precedence.MULTIPLY, binaryInfix(.MULTIPLY));
  pratt.infix(.NOT_EQUAL, Precedence.EQUAL, binaryInfix(.NOT_EQUAL));
  pratt.infix(.PLUS, Precedence.ADD, binaryInfix(.ADD));
  pratt.infix(.REMAINDER, Precedence.MULTIPLY, binaryInfix(.REMAINDER));
  pratt.infix(.SHIFT_LEFT, Precedence.SHIFT, binaryInfix(.SHIFT_LEFT));
  pratt.infix(.SHIFT_RIGHT, Precedence.SHIFT, binaryInfix(.SHIFT_RIGHT));

  ////////////////////////////////////////////////////////////////////////////////
  // Assignment expressions
  ////////////////////////////////////////////////////////////////////////////////

  pratt.infixRight(.ASSIGN, Precedence.ASSIGN, binaryInfix(.ASSIGN));
  pratt.infixRight(.ASSIGN_PLUS, Precedence.ASSIGN, binaryInfix(.ASSIGN_ADD));
  pratt.infixRight(.ASSIGN_BITWISE_AND, Precedence.ASSIGN, binaryInfix(.ASSIGN_BITWISE_AND));
  pratt.infixRight(.ASSIGN_BITWISE_OR, Precedence.ASSIGN, binaryInfix(.ASSIGN_BITWISE_OR));
  pratt.infixRight(.ASSIGN_BITWISE_XOR, Precedence.ASSIGN, binaryInfix(.ASSIGN_BITWISE_XOR));
  pratt.infixRight(.ASSIGN_DIVIDE, Precedence.ASSIGN, binaryInfix(.ASSIGN_DIVIDE));
  pratt.infixRight(.ASSIGN_MULTIPLY, Precedence.ASSIGN, binaryInfix(.ASSIGN_MULTIPLY));
  pratt.infixRight(.ASSIGN_REMAINDER, Precedence.ASSIGN, binaryInfix(.ASSIGN_REMAINDER));
  pratt.infixRight(.ASSIGN_SHIFT_LEFT, Precedence.ASSIGN, binaryInfix(.ASSIGN_SHIFT_LEFT));
  pratt.infixRight(.ASSIGN_SHIFT_RIGHT, Precedence.ASSIGN, binaryInfix(.ASSIGN_SHIFT_RIGHT));
  pratt.infixRight(.ASSIGN_MINUS, Precedence.ASSIGN, binaryInfix(.ASSIGN_SUBTRACT));

  ////////////////////////////////////////////////////////////////////////////////
  // Other expressions
  ////////////////////////////////////////////////////////////////////////////////

  // Initializer expressions
  pratt.parselet(.LEFT_BRACKET, Precedence.LOWEST).prefix = context => {
    var token = context.current();
    var arguments = parseArgumentList(context, .LEFT_BRACKET, .RIGHT_BRACKET, .TRAILING_COMMA);
    return Node.createList(arguments).withRange(context.spanSince(token.range));
  };

  // Group, cast, and lambda expressions
  pratt.parselet(.LEFT_PARENTHESIS, Precedence.LOWEST).prefix = context => {
    var token = context.current();
    var type = parseGroup(context, .LAMBDA_ALLOWED);
    if (type.kind == .NAME && context.eat(.LAMBDA)) {
      var block = parseLambdaBlock(context);
      return createLambdaFromNames([type], block).withRange(context.spanSince(token.range));
    }
    if (looksLikeLambdaArguments(type) && context.eat(.LAMBDA)) {
      var block = parseLambdaBlock(context);
      return createLambdaFromNames(type.removeChildren(), block).withRange(context.spanSince(token.range));
    }
    if (looksLikeType(type)) {
      var value = pratt.parse(context, Precedence.UNARY_PREFIX);
      return Node.createCast(type, value).withRange(context.spanSince(token.range));
    }
    return type;
  };

  // Hook expressions
  pratt.parselet(.QUESTION_MARK, Precedence.ASSIGN).infix = (context, left) => {
    context.next();
    var middle = pratt.parse(context, Precedence.ASSIGN - 1);
    var right = context.expect(.COLON) ? pratt.parse(context, Precedence.ASSIGN - 1) : Node.createError().withRange(context.spanSince(context.current().range));
    return Node.createHook(left, middle, right).withRange(context.spanSince(left.range));
  };

  // Sequence expressions
  pratt.parselet(.COMMA, Precedence.COMMA).infix = (context, left) => {
    var values = [left];
    while (context.eat(.COMMA)) {
      values.push(pratt.parse(context, Precedence.COMMA));
    }
    return Node.createSequence(values).withRange(context.spanSince(left.range));
  };

  // Dot expressions
  pratt.parselet(.DOT, Precedence.MEMBER).infix = (context, left) => {
    context.next();
    var name = parseName(context); // Allow this to be null for autocomplete
    return Node.createDot(left, name).withRange(context.spanSince(left.range));
  };
  pratt.parselet(.DOT, Precedence.LOWEST).prefix = context => {
    var token = context.next();
    var name = parseName(context); // Allow this to be null for autocomplete
    return Node.createDot(null, name).withRange(context.spanSince(token.range));
  };

  // Function type expressions
  pratt.parselet(.FN, Precedence.MEMBER).infix = (context, left) => {
    if (!looksLikeType(left)) {
      context.unexpectedToken();
      context.next();
      return Node.createError().withRange(context.spanSince(left.range));
    }
    context.next();
    var arguments = parseArgumentList(context, .LEFT_PARENTHESIS, .RIGHT_PARENTHESIS, .TRAILING_COMMA);
    return Node.createFunctionType(left, arguments).withRange(context.spanSince(left.range));
  };

  // Call expressions
  pratt.parselet(.LEFT_PARENTHESIS, Precedence.UNARY_POSTFIX).infix = (context, left) => {
    var arguments = parseArgumentList(context, .LEFT_PARENTHESIS, .RIGHT_PARENTHESIS, .NO_TRAILING_COMMA);
    return Node.createCall(left, arguments).withRange(context.spanSince(left.range));
  };

  // Index expressions
  pratt.parselet(.LEFT_BRACKET, Precedence.UNARY_POSTFIX).infix = (context, left) => {
    context.next();
    var index = pratt.parse(context, Precedence.LOWEST);
    scanForToken(context, .RIGHT_BRACKET, .STOP_BEFORE_NEXT_STATEMENT);
    return Node.createBinary(.INDEX, left, index).withRange(context.spanSince(left.range));
  };

  // Type parameterization expressions
  pratt.parselet(.START_PARAMETER_LIST, Precedence.MEMBER).infix = (context, left) => {
    var token = context.next();
    var substitutions = parseTypeList(context, .END_PARAMETER_LIST);
    if (!context.expect(.END_PARAMETER_LIST)) {
      scanForToken(context, .END_PARAMETER_LIST, .STOP_BEFORE_NEXT_STATEMENT);
      return Node.createError().withRange(context.spanSince(token.range));
    }
    return Node.createParameterize(left, substitutions).withRange(context.spanSince(left.range));
  };

  // Untyped expressions
  pratt.parselet(.UNTYPED, Precedence.UNARY_PREFIX).prefix = context => {
    var token = context.next();
    var value = parseGroup(context, .LAMBDA_NOT_ALLOWED);
    return (value == null ? Node.createError() : Node.createUntyped(value)).withRange(context.spanSince(token.range));
  };

  // Name and lambda expressions
  pratt.parselet(.IDENTIFIER, Precedence.LOWEST).prefix = context => {
    var token = context.next();
    var name = Node.createName(token.text).withRange(token.range);
    if (context.eat(.LAMBDA)) {
      var block = parseLambdaBlock(context);
      return createLambdaFromNames([name], block).withRange(context.spanSince(token.range));
    }
    return name;
  };

  // Lambda expressions
  pratt.parselet(.LAMBDA, Precedence.LOWEST).prefix = context => {
    var token = context.next();
    var block = parseLambdaBlock(context);
    return Node.createLambda([], block).withRange(context.spanSince(token.range));
  };

  // New expressions
  pratt.parselet(.NEW, Precedence.LOWEST).prefix = context => {
    context.unexpectedToken();
    context.next(); // Provide nicer error messages for Java-style by just ignoring it
    return parseType(context);
  };

  // Let expressions
  var inParselet = pratt.parselet(.IN, 0);
  pratt.parselet(.LET, Precedence.LOWEST).prefix = context => {
    var token = context.next();
    var name = parseName(context);
    if (name == null || !context.expect(.ASSIGN)) {
      return Node.createError().withRange(context.spanSince(token.range));
    }
    var initial = pratt.parseIgnoringParselet(context, Precedence.LOWEST, inParselet);
    var variable = Node.createVariable(name, Node.createVar(), initial).withRange(context.spanSince(token.range));
    if (initial.kind.isError() || !context.expect(.IN)) {
      return Node.createError().withRange(context.spanSince(token.range));
    }
    var value = pratt.parse(context, Precedence.COMMA);
    return Node.createLet(variable, value).withRange(context.spanSince(token.range));
  };

  // Super call expressions
  pratt.parselet(.SUPER, Precedence.LOWEST).prefix = context => parseSuperCall(context);
}

Pratt pratt;
