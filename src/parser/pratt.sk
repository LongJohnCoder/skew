class ParserContext {
  Log log;
  List<Token> tokens;
  var index = 0;

  // Keep track of the previous syntax error so only one syntax error is emitted
  // per token when recovering from a parse error. For example:
  //
  //   int x = (1 + (2 + ;
  //
  // In the code above, the only syntax error should be about an unexpected
  // semicolon and not also about the two missing right parentheses.
  Token previousSyntaxError = null;

  Token current() {
    return tokens.get(index);
  }

  Token next() {
    var token = current();
    if (index + 1 < tokens.length) {
      index++;
    }
    return token;
  }

  Range spanSince(Range range) {
    var previous = tokens.get(index > 0 ? index - 1 : 0);
    return previous.range.end < range.start ? range : Range.span(range, previous.range);
  }

  bool peek(TokenKind kind) {
    return current().kind == kind;
  }

  bool eat(TokenKind kind) {
    if (peek(kind)) {
      next();
      return true;
    }
    return false;
  }

  bool expect(TokenKind kind) {
    if (!eat(kind)) {
      var token = current();
      if (previousSyntaxError != token) {
        syntaxErrorExpectedToken(log, token, kind);
        previousSyntaxError = token;
      }
      return false;
    }
    return true;
  }

  void unexpectedToken() {
    var token = current();
    if (previousSyntaxError != token) {
      syntaxErrorUnexpectedToken(log, token);
      previousSyntaxError = token;
    }
  }
}

class Parselet {
  int precedence;
  PrefixParselet prefix = null;
  InfixParselet infix = null;
}

alias PrefixParselet = Node fn(ParserContext);
alias InfixParselet = Node fn(ParserContext, Node);

// A Pratt parser is a parser that associates up to two operations per token,
// each with its own precedence. Pratt parsers excel at parsing expression
// trees with deeply nested precedence levels. For an excellent writeup, see:
//
//   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
//
class Pratt {
  var table = IntMap<Parselet>();

  Parselet parselet(TokenKind kind, int precedence) {
    var parselet = table.getOrDefault(kind, null);
    if (parselet == null) {
      var created = Parselet(precedence);
      parselet = created;
      table.set(kind, created);
    } else if (precedence > parselet.precedence) {
      parselet.precedence = precedence;
    }
    return parselet;
  }

  Node parse(ParserContext context, int precedence) {
    return parseIgnoringParselet(context, precedence, null);
  }

  Node resume(ParserContext context, int precedence, Node left) {
    return resumeIgnoringParselet(context, precedence, left, null);
  }

  Node parseIgnoringParselet(ParserContext context, int precedence, Parselet parseletToIgnore) {
    var token = context.current();
    var parselet = table.getOrDefault(token.kind, null);
    if (parselet == null || parselet == parseletToIgnore || parselet.prefix == null) {
      context.unexpectedToken();
      return Node.createError().withRange(context.spanSince(token.range));
    }
    var node = resumeIgnoringParselet(context, precedence, parselet.prefix(context), parseletToIgnore);
    assert node != null; // Parselets must return Node.createError() instead of null
    assert !node.range.isEmpty(); // Parselets must set the range of every node
    return node;
  }

  Node resumeIgnoringParselet(ParserContext context, int precedence, Node left, Parselet parseletToIgnore) {
    assert left != null;
    while (!left.kind.isError()) {
      var kind = context.current().kind;
      var parselet = table.getOrDefault(kind, null);
      if (parselet == null || parselet == parseletToIgnore || parselet.infix == null || parselet.precedence <= precedence) {
        break;
      }
      left = parselet.infix(context, left);
      assert left != null; // Parselets must return Node.createError() instead of null
      assert !left.range.isEmpty(); // Parselets must set the range of every node
    }
    return left;
  }

  void literal(TokenKind kind, LiteralCallback callback) {
    parselet(kind, 0).prefix = context => callback(context, context.next());
  }

  void prefix(TokenKind kind, int precedence, PrefixCallback callback) {
    parselet(kind, 0).prefix = context => {
      var token = context.next();
      var value = pratt.parse(context, precedence);
      return value != null ? callback(context, token, value) : null;
    };
  }

  void postfix(TokenKind kind, int precedence, PostfixCallback callback) {
    parselet(kind, precedence).infix = (context, left) => callback(context, left, context.next());
  }

  void infix(TokenKind kind, int precedence, InfixCallback callback) {
    parselet(kind, precedence).infix = (context, left) => {
      var token = context.next();
      var right = pratt.parse(context, precedence);
      return right != null ? callback(context, left, token, right) : null;
    };
  }

  void infixRight(TokenKind kind, int precedence, InfixCallback callback) {
    parselet(kind, precedence).infix = (context, left) => {
      var token = context.next();
      var right = pratt.parse(context, precedence - 1); // Subtract 1 for right-associativity
      return right != null ? callback(context, left, token, right) : null;
    };
  }
}

alias LiteralCallback = Node fn(ParserContext, Token);
alias PrefixCallback = Node fn(ParserContext, Token, Node);
alias PostfixCallback = Node fn(ParserContext, Node, Token);
alias InfixCallback = Node fn(ParserContext, Node, Token, Node);
