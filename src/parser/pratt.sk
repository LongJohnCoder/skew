class ParserContext {
  Log log;
  List<Token> tokens;
  var index = 0;

  // Keep track of the previous syntax error so only one syntax error is emitted
  // per token when recovering from a parse error. For example:
  //
  //   int x = (1 + (2 + ;
  //
  // In the code above, the only syntax error should be about an unexpected
  // semicolon and not also about the two missing right parentheses.
  Token previousSyntaxError = null;

  Token current() {
    return tokens.get(index);
  }

  Token next() {
    var token = current();
    if (index + 1 < tokens.size()) {
      index++;
    }
    return token;
  }

  Range spanSince(Range range) {
    var previous = tokens.get(index > 0 ? index - 1 : 0);
    return previous.range.end < range.start ? range : Range.span(range, previous.range);
  }

  bool peek(TokenKind kind) {
    return current().kind == kind;
  }

  bool eat(TokenKind kind) {
    if (peek(kind)) {
      next();
      return true;
    }
    return false;
  }

  bool expect(TokenKind kind) {
    if (!eat(kind)) {
      var token = current();
      if (previousSyntaxError != token) {
        syntaxErrorExpectedToken(log, token, kind);
        previousSyntaxError = token;
      }
      return false;
    }
    return true;
  }

  void unexpectedToken() {
    var token = current();
    if (previousSyntaxError != token) {
      syntaxErrorUnexpectedToken(log, token);
      previousSyntaxError = token;
    }
  }
}

class Parselet {
  int precedence;
  IPrefixParselet prefix = null;
  IInfixParselet infix = null;
}

interface IPrefixParselet {
  virtual Node parse(ParserContext context);
}

interface IInfixParselet {
  virtual Node parse(ParserContext context, Node left);
}

// A Pratt parser is a parser that associates up to two operations per token,
// each with its own precedence. Pratt parsers excel at parsing expression
// trees with deeply nested precedence levels. For an excellent writeup, see:
//
//   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
//
class Pratt {
  var table = IntMap<Parselet>();

  Parselet parselet(TokenKind kind, int precedence) {
    var parselet = table.getOrDefault(kind, null);
    if (parselet == null) {
      var created = Parselet(precedence);
      parselet = created;
      table.set(kind, created);
    } else if (precedence > parselet.precedence) {
      parselet.precedence = precedence;
    }
    return parselet;
  }

  Node parse(ParserContext context, int precedence) {
    return parseIgnoringParselet(context, precedence, null);
  }

  Node resume(ParserContext context, int precedence, Node left) {
    return resumeIgnoringParselet(context, precedence, left, null);
  }

  Node parseIgnoringParselet(ParserContext context, int precedence, Parselet parseletToIgnore) {
    var token = context.current();
    var parselet = table.getOrDefault(token.kind, null);
    if (parselet == null || parselet == parseletToIgnore || parselet.prefix == null) {
      context.unexpectedToken();
      return Node.createError().withRange(context.spanSince(token.range));
    }
    var node = resumeIgnoringParselet(context, precedence, parselet.prefix.parse(context), parseletToIgnore);
    assert node != null; // Parselets must return Node.createError() instead of null
    assert !node.range.isEmpty(); // Parselets must set the range of every node
    return node;
  }

  Node resumeIgnoringParselet(ParserContext context, int precedence, Node left, Parselet parseletToIgnore) {
    assert left != null;
    while (!left.kind.isError()) {
      var kind = context.current().kind;
      var parselet = table.getOrDefault(kind, null);
      if (parselet == null || parselet == parseletToIgnore || parselet.infix == null || parselet.precedence <= precedence) {
        break;
      }
      left = parselet.infix.parse(context, left);
      assert left != null; // Parselets must return Node.createError() instead of null
      assert !left.range.isEmpty(); // Parselets must set the range of every node
    }
    return left;
  }

  void literal(TokenKind kind, ILiteralCallback callback) {
    parselet(kind, 0).prefix = LiteralParselet(callback);
  }

  void prefix(TokenKind kind, int precedence, IPrefixCallback callback) {
    parselet(kind, 0).prefix = PrefixParselet(callback, precedence);
  }

  void postfix(TokenKind kind, int precedence, IPostfixCallback callback) {
    parselet(kind, precedence).infix = PostfixParselet(callback);
  }

  void infix(TokenKind kind, int precedence, IInfixCallback callback) {
    parselet(kind, precedence).infix = InfixParselet(callback, precedence);
  }

  void infixRight(TokenKind kind, int precedence, IInfixCallback callback) {
    parselet(kind, precedence).infix = InfixParselet(callback, precedence - 1); // Subtract 1 for right-associativity
  }
}

interface ILiteralCallback {
  virtual Node parse(ParserContext context, Token token);
}

class LiteralParselet : IPrefixParselet {
  ILiteralCallback callback;

  override Node parse(ParserContext context) {
    return callback.parse(context, context.next());
  }
}

interface IPrefixCallback {
  virtual Node parse(ParserContext context, Token token, Node value);
}

class PrefixParselet : IPrefixParselet {
  IPrefixCallback callback;
  int precedence;

  override Node parse(ParserContext context) {
    var token = context.next();
    var value = pratt.parse(context, precedence);
    return value != null ? callback.parse(context, token, value) : null;
  }
}

interface IPostfixCallback {
  virtual Node parse(ParserContext context, Node value, Token token);
}

class PostfixParselet : IInfixParselet {
  IPostfixCallback callback;

  override Node parse(ParserContext context, Node left) {
    return callback.parse(context, left, context.next());
  }
}

interface IInfixCallback {
  virtual Node parse(ParserContext context, Node left, Token token, Node right);
}

class InfixParselet : IInfixParselet {
  IInfixCallback callback;
  int precedence;

  override Node parse(ParserContext context, Node left) {
    var token = context.next();
    var right = pratt.parse(context, precedence);
    return right != null ? callback.parse(context, left, token, right) : null;
  }
}
