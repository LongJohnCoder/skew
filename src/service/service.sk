export class LanguageServiceTypeResult {
  export int line;
  export int column;
  export int index;
  export int length;
  export string type;
  export string declaration = "";
}

export class LanguageServiceDiagnostic {
  export string kind;
  export string text;
  export int line;
  export int column;
  export int index;
  export int length;
}

export class LanguageServiceCompletion {
  export string name;
  export string type;
  export string completion; // Uses '$' for where the cursor should be
}

export class LanguageService {
  CompilerResult previousResult = null;
  Source previousSource = null;

  export LanguageServiceTypeResult typeFromPosition(int line, int column) {
    if (previousResult != null && previousResult.program != null && previousSource != null && column >= 0 &&
        column < previousSource.contentsOfLine(line).length && previousResult.program.children.length == 2) {
      var index = previousSource.lineOffsets.get(line) + column;
      var previousFile = previousResult.program.children.get(1);
      assert previousFile.range.source == previousSource;
      return service.typeFromPosition(previousFile, previousSource, index);
    }
    return null;
  }

  export List<LanguageServiceDiagnostic> checkForDiagnostics(string input) {
    // Compile input
    var options = CompilerOptions();
    var compiler = Compiler();
    previousSource = Source("<input>", input);
    options.inputs = [previousSource];
    previousResult = compiler.compile(options);

    // Construct diagnostics
    List<LanguageServiceDiagnostic> diagnostics = [];
    for (var i = 0; i < compiler.log.diagnostics.length; i++) {
      var diagnostic = compiler.log.diagnostics.get(i);
      var range = diagnostic.range;
      if (range.source == previousSource) {
        var start = range.source.indexToLineColumn(range.start);
        string type;
        switch (diagnostic.kind) {
          case .ERROR { type = "error"; }
          case .WARNING { type = "warning"; }
        }
        diagnostics.push(LanguageServiceDiagnostic(type, diagnostic.text, start.line, start.column, range.start, range.singleLineLength()));
      }
    }
    return diagnostics;
  }

  export List<LanguageServiceCompletion> checkForCompletions(string input, int line, int column) {
    // Compile input
    var options = CompilerOptions();
    var compiler = Compiler();
    previousSource = Source("<input>", input);
    options.inputs = [previousSource];
    previousResult = compiler.compile(options);

    // Construct completions
    if (previousResult.program != null && column >= 0 && column <= previousSource.contentsOfLine(line).length && previousResult.program.children.length == 2) {
      var index = previousSource.lineOffsets.get(line) + column;
      var previousFile = previousResult.program.children.get(1);
      assert previousFile.range.source == previousSource;
      return service.completionsFromPosition(previousFile, previousResult.resolver, previousSource, index);
    }

    return null;
  }
}

namespace service {
  Node nodeFromPosition(Node node, Source source, int index) {
    while (node.hasChildren()) {
      // Search in reverse order to handle initializer expressions, which get
      // turned into call expressions where the target of the call spans the
      // entire range of the initializer expression and hides the arguments
      int i;
      for (i = node.children.length - 1; i >= 0; i--) {
        var child = node.children.get(i);
        if (child != null && child.range.source == source && child.range.touches(index)) {
          node = child;
          break;
        }
      }
      if (i < 0) {
        break;
      }
    }
    return node;
  }

  LanguageServiceTypeResult typeFromPosition(Node node, Source source, int index) {
    node = nodeFromPosition(node, source, index);
    var symbol = node.symbol;
    var type = node.type;
    if (type != null && symbol != null) {
      var start = source.indexToLineColumn(node.range.start);
      var result = LanguageServiceTypeResult(start.line, start.column, node.range.start, node.range.singleLineLength(), type.toString());

      // Pretty-print the symbol
      switch (symbol.kind) {
        case .PARAMETER {
          var bound = symbol.type.bound();
          var text = "type " + symbol.name;
          if (bound != null) {
            text += " is " + bound;
          }
          result.declaration = text;
        }

        case .NAMESPACE {
          result.declaration = "namespace " + symbol.fullName();
        }

        case .CLASS, .STRUCT, .INTERFACE {
          var text = symbol.kind.toString().toLowerCase() + " " + type;
          if (type.hasRelevantTypes()) {
            for (var i = 0; i < type.relevantTypes.length; i++) {
              text += (i == 0 ? " : " : ", ") + type.relevantTypes.get(i);
            }
          }
          result.declaration = text;
        }

        case .ENUM {
          result.declaration = "enum " + symbol.fullName();
        }

        case .ENUM_FLAGS {
          result.declaration = "enum flags " + symbol.fullName();
        }

        case .GLOBAL_FUNCTION, .INSTANCE_FUNCTION, .CONSTRUCTOR_FUNCTION {
          var text = type.resultType() + " " + symbol.name + "(";
          var arguments = symbol.node.functionArguments().children;
          var argumentTypes = type.argumentTypes();
          for (var i = 0; i < arguments.length; i++) {
            if (i > 0) text += ", ";
            text += argumentTypes.get(i) + " " + arguments.get(i).symbol.name;
          }
          result.declaration = text + ")";
        }

        case .LOCAL_VARIABLE, .GLOBAL_VARIABLE, .INSTANCE_VARIABLE {
          var text = type + " " + symbol.name;
          if (symbol.isEnumValue()) {
            text += " = " + symbol.constant.asInt();
          }
          result.declaration = text;
        }

        default {
          return null;
        }
      }

      return result;
    }
    return null;
  }

  List<LanguageServiceCompletion> completionsFromPosition(Node node, Resolver resolver, Source source, int index) {
    List<LanguageServiceCompletion> completions = [];
    node = nodeFromPosition(node, source, index);

    // Special-case completions for members
    if (node.kind == .DOT) {
      var target = node.dotTarget();
      if (target.type != null) {
        var isInstance = !target.kind.isType();
        var members = target.type.members.values();
        for (var i = 0; i < members.length; i++) {
          var member = members.get(i);
          resolver.initializeMember(member);
          if (member.symbol.kind.isInstance() == isInstance) {
            addCompletion(completions, member);
          }
        }
        return completions;
      }
    }

    // Return completions from the tightest enclosing scope
    while (node != null) {
      if (node.scope == null) {
        node = node.parent;
        continue;
      }

      // Walk up the scope chain and accumulate all members
      var allMembers = StringMap<Member>();
      collectAllMembers(node.scope, allMembers);
      var members = allMembers.values();

      for (var i = 0; i < members.length; i++) {
        var member = members.get(i);
        resolver.initializeMember(member);
        addCompletion(completions, member);
      }
      break;
    }

    return completions;
  }

  void addCompletion(List<LanguageServiceCompletion> completions, Member member) {
    var name = member.symbol.name;
    var type = member.type;
    if (name != "new" && type != null) {
      var text = name;
      if (type.isFunction()) {
        var semicolon = type.resultType().toString() == "void";
        text += type.argumentTypes().length == 0
          ? semicolon ? "();$" : "()$"
          : semicolon ? "($);" : "($)";
      } else {
        text += "$";
      }
      completions.push(LanguageServiceCompletion(name, type.toString(), text));
    }
  }

  void addAllMembers(StringMap<Member> allMembers, StringMap<Member> membersToAdd) {
    var members = membersToAdd.values();
    for (var i = 0; i < members.length; i++) {
      var member = members.get(i);
      if (!allMembers.has(member.symbol.name)) {
        allMembers.set(member.symbol.name, member);
      }
    }
  }

  void collectAllMembers(Scope scope, StringMap<Member> allMembers) {
    if (scope.locals != null) {
      addAllMembers(allMembers, scope.locals);
    }
    if (scope.type != null) {
      addAllMembers(allMembers, scope.type.members);
    }
    if (scope.lexicalParent != null) {
      collectAllMembers(scope.lexicalParent, allMembers);
    }
  }
}
