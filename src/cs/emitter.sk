namespace cs {
  class Emitter : IEmitter {
    static StringMap<bool> isKeyword;
    var indent = "";
    List<Symbol> namespaceStack = [];
    Source currentSource = null;
    Resolver resolver;

    override void patchProgram(Node program) {
    }

    override List<Source> emitProgram(Node program) {
      if (isKeyword == null) {
        isKeyword = createIsKeyword();
      }

      // Collect all interesting nodes for easy access
      var collector = Collector(program, .DO_NOT_SORT);
      currentSource = Source(resolver.options.outputFile, "");

      // Prepend inputs
      var prepend = resolver.options.prepend;
      for (var i = 0; i < prepend.size(); i++) {
        currentSource.contents += prepend.get(i).contents;
      }

      // TODO: Only emit this when necessary
      emit(indent + "using System;\n"); // For "Func" and "Action"
      emit(indent + "using System.Collections.Generic;\n"); // For "List"

      // Emit types
      for (var i = 0; i < collector.typeSymbols.size(); i++) {
        var type = collector.typeSymbols.get(i).type;
        if (!type.symbol.isImport()) {
          emitNode(type.symbol.node.firstNonExtensionSibling());
        }
      }

      // Emit free symbols on a global object
      var functions = collector.freeFunctionSymbols;
      var variables = collector.freeVariableSymbols;
      if (functions.size() + variables.size() > 0) {
        for (var i = 0; i < functions.size(); i++) {
          emitNode(functions.get(i).node);
        }
        for (var i = 0; i < variables.size(); i++) {
          var symbol = variables.get(i);
          if (!symbol.isObjectMember()) {
            emitVariableStatement(symbol.node);
          }
        }
      }

      // Clear the namespace stack
      adjustNamespace(null);

      // Append inputs
      var append = resolver.options.append;
      for (var i = 0; i < append.size(); i++) {
        currentSource.contents += append.get(i).contents;
      }

      return [currentSource];
    }

    void increaseIndent() {
      indent += "  ";
    }

    void decreaseIndent() {
      indent = indent.slice(2, indent.size());
    }

    void emit(string text) {
      currentSource.contents += text;
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      for (var i = 0; i < nodes.size(); i++) {
        if (i > 0) emit(", ");
        emitExpression(nodes.get(i), .COMMA);
      }
    }

    void adjustNamespace(Symbol symbol) {
      List<Symbol> target = [];

      // Free-floating global symbols must be wrapped in a class because C#
      // doesn't have top-level variable or function declarations. Use null
      // as a sentinel value for this global class. Luckily, C# has partial
      // classes so we don't need to deal with collecting these symbols.
      if (symbol != null && putInGlobalNamespace(symbol)) {
        target.push(null);
      }

      // Compute the namespaces for this symbol
      while (symbol != null) {
        if (symbol.kind == .NAMESPACE) {
          target.unshift(symbol);
        }
        symbol = symbol.enclosingSymbol;
      }

      // Skip past the names that match
      var same = 0;
      while (same < target.size() && same < namespaceStack.size() && target.get(same) == namespaceStack.get(same)) {
        same++;
      }

      // Remove old names
      while (namespaceStack.size() > same) {
        decreaseIndent();
        emit(indent + "}\n");
        namespaceStack.pop();
      }

      // Add new names
      while (namespaceStack.size() < target.size()) {
        symbol = target.get(namespaceStack.size());
        namespaceStack.push(symbol);
        if (symbol != null) {
          emit(indent + "namespace " + mangleName(symbol) + " {\n");
        } else {
          emit(indent + "partial class Global {\n");
        }
        increaseIndent();
      }
    }

    void emitNode(Node node) {
      switch (node.kind) {
        case .ENUM, .ENUM_FLAGS { emitEnum(node); }
        case .CLASS, .STRUCT, .INTERFACE { emitObject(node); }
        case .CONSTRUCTOR, .FUNCTION { emitFunction(node); }
        case .RETURN, .IMPLICIT_RETURN { emitReturn(node); }
        case .EXPRESSION { emitExpressionStatement(node); }
        case .IF { emitIf(node); }
        case .FOR { emitFor(node); }
        case .FOR_EACH { emitForEach(node); }
        case .WHILE { emitWhile(node); }
        case .DO_WHILE { emitDoWhile(node); }
        case .BREAK { emitBreak(node); }
        case .CONTINUE { emitContinue(node); }
        case .ASSERT { emitAssert(node); }
        case .VARIABLE_CLUSTER { emitVariableCluster(node); }
        case .VARIABLE { emitVariableStatement(node); }
      }
    }

    void recursiveEmitIfStatement(Node node) {
      var trueBlock = node.ifTrue();
      var falseBlock = node.ifFalse();
      var trueStatement = trueBlock.singleStatement();
      emit("if (");
      emitExpression(node.ifTest(), .LOWEST);
      emit(") ");
      emitBlock(trueBlock);
      if (falseBlock != null) {
        emit(" else ");
        emitBlock(falseBlock);
      }
    }

    void emitIf(Node node) {
      emit(indent);
      recursiveEmitIfStatement(node);
      emit("\n");
    }

    void emitFor(Node node) {
      var setup = node.forSetup();
      var test = node.forTest();
      var update = node.forUpdate();
      emit(indent + "for (");
      if (setup != null) {
        if (setup.kind == .VARIABLE_CLUSTER) {
          emit("var ");
          var nodes = setup.clusterVariables();
          for (var i = 0; i < nodes.size(); i++) {
            var variable = nodes.get(i);
            if (i > 0) emit(", ");
            emit(mangleName(variable.symbol));
            emit(" = ");
            emitExpression(variable.variableValue(), .COMMA);
          }
        } else {
          emitExpression(setup, .LOWEST);
        }
      }
      if (test != null) {
        emit("; ");
        emitExpression(test, .LOWEST);
      } else {
        emit(";");
      }
      if (update != null) {
        emit("; ");
        emitExpression(update, .LOWEST);
      } else {
        emit(";");
      }
      emit(")");
      emitBlock(node.forBlock());
      emit("\n");
    }

    void emitForEach(Node node) {
      var variable = node.forEachVariable();
      var value = node.forEachValue();
      emit(indent + "for (var ");
      emitNode(variable);
      emit(" in ");
      emitExpression(value, .LOWEST);
      emit(")");
      emitBlock(node.forEachBlock());
      emit("\n");
    }

    void emitWhile(Node node) {
      emit(indent + "while (");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")");
      emitBlock(node.whileBlock());
      emit("\n");
    }

    void emitDoWhile(Node node) {
      emit(indent + "do");
      emitBlock(node.whileBlock());
      emit(" while (");
      emitExpression(node.whileTest(), .LOWEST);
      emit(");\n");
    }

    void emitBreak(Node node) {
      emit(indent + "break;\n");
    }

    void emitContinue(Node node) {
      emit(indent + "continue;\n");
    }

    void emitAssert(Node node) {
      var value = node.assertValue();
      emit(indent + "Debug.Assert(");
      emitExpression(value, .COMMA);
      emit(", " + quoteString(node.range + " (" + node.range.locationString() + ")", '"') + ");\n");
    }

    void emitNameWithParameters(Symbol symbol) {
      emit(mangleName(symbol));
      if (symbol.hasParameters()) {
        emit("<");
        for (var i = 0; i < symbol.parameters.size(); i++) {
          if (i > 0) emit(", ");
          emit(mangleName(symbol.parameters.get(i)));
        }
        emit(">");
      }
    }

    void emitEnum(Node node) {
      var symbol = node.symbol;
      var type = symbol.type;
      adjustNamespace(symbol);
      emit(indent + "public enum " + mangleName(symbol) + " {\n");
      increaseIndent();
      var members = type.members.values();
      for (var i = 0; i < members.size(); i++) {
        var symbol = members.get(i).symbol;
        if (symbol.isEnumValue()) {
          emit(indent + mangleName(symbol) + " = " + symbol.constant.asInt() + ",\n");
        }
      }
      decreaseIndent();
      emit(indent + "}\n");
    }

    void emitObject(Node node) {
      var symbol = node.symbol;
      var type = symbol.type;
      adjustNamespace(symbol);
      emit(indent + "public ");
      if (symbol.isAbstract()) {
        emit("abstract ");
      }
      emit(symbol.kind == .CLASS ? "class " : symbol.kind == .STRUCT ? "struct " : "interface ");
      emitNameWithParameters(symbol);
      if (type.hasRelevantTypes()) {
        for (var i = 0; i < type.relevantTypes.size(); i++) {
          emit(i == 0 ? " : " : ", ");
          emit(mangleName(type.relevantTypes.get(i).symbol));
        }
      }
      emit(" {\n");
      increaseIndent();
      var members = type.members.values();
      for (var i = 0; i < members.size(); i++) {
        var symbol = members.get(i).symbol;
        if (symbol.enclosingSymbol == type.symbol && symbol.node != null) {
          emitNode(symbol.node);
        }
      }
      decreaseIndent();
      emit(indent + "}\n");
    }

    void emitExpressionStatement(Node node) {
      emit(indent);
      emitExpression(node.expressionValue(), .LOWEST);
      emit(";\n");
    }

    void emitReturn(Node node) {
      var value = node.returnValue();
      emit(indent + "return");
      if (value != null) {
        emit(" ");
        emitExpression(value, .LOWEST);
      }
      emit(";\n");
    }

    void emitArgumentVariables(List<Node> nodes) {
      emit("(");
      for (var i = 0; i < nodes.size(); i++) {
        var argument = nodes.get(i).symbol;
        if (i > 0) emit(", ");
        emitType(argument.type);
        emit(" ");
        emit(mangleName(argument));
      }
      emit(")");
    }

    void emitFunction(Node node) {
      var symbol = node.symbol;
      if (symbol.isOperator()) {
        return;
      }
      var block = node.functionBlock();
      var isInterface = symbol.enclosingSymbol.kind == .INTERFACE;
      adjustNamespace(symbol);
      emit(indent);
      if (!isInterface) {
        emit("public ");
      }
      if (symbol.isStatic() || symbol.kind == .GLOBAL_FUNCTION) {
        emit("static ");
      }
      if (symbol.isVirtual() && !isInterface) {
        emit(symbol.isOverride() && symbol.overriddenMember.symbol.enclosingSymbol.kind != .INTERFACE ? "override " : block == null ? "abstract " : "virtual ");
      }
      if (!symbol.kind.isConstructor()) {
        emitType(symbol.type.resultType());
        emit(" ");
      }
      emitNameWithParameters(symbol);
      emitArgumentVariables(node.functionArguments().children);
      if (node.kind == .CONSTRUCTOR) {
        var superInitializer = node.superInitializer();
        if (superInitializer != null) {
          emit(" : ");
          emitExpression(superInitializer, .LOWEST);
        }
      }
      if (block == null) {
        emit(";\n");
      } else {
        emit(" {\n");
        increaseIndent();
        if (node.kind == .CONSTRUCTOR) {
          var memberInitializers = node.memberInitializers();
          if (memberInitializers != null) {
            for (var i = 0; i < memberInitializers.children.size(); i++) {
              var child = memberInitializers.children.get(i);
              emit(indent);
              emit(mangleName(child.memberInitializerName().symbol) + " = ");
              emitExpression(child.memberInitializerValue(), .ASSIGN);
              emit(";\n");
            }
          }
        }
        if (block.hasChildren()) {
          for (var i = 0; i < block.children.size(); i++) {
            emitNode(block.children.get(i));
          }
        }
        decreaseIndent();
        emit(indent + "}\n");
      }
    }

    void emitType(Type type) {
      if (type.isFunction()) {
        var resultType = type.resultType();
        var argumentTypes = type.argumentTypes();
        var returnsVoid = resultType.isVoid(resolver.cache);
        if (returnsVoid && argumentTypes.size() == 0) {
          emit("Action");
        } else {
          emit(returnsVoid ? "Action<" : "Func<");
          for (var i = 0; i < argumentTypes.size(); i++) {
            if (i > 0) emit(", ");
            emitType(argumentTypes.get(i));
          }
          if (!returnsVoid) {
            if (argumentTypes.size() > 0) emit(", ");
            emitType(resultType);
          }
          emit(">");
        }
      } else {
        emit(fullName(type.symbol));
        if (type.isParameterized()) {
          emit("<");
          for (var i = 0; i < type.symbol.parameters.size(); i++) {
            if (i > 0) emit(", ");
            emitType(type.substitutions.get(i));
          }
          emit(">");
        }
      }
    }

    void emitBlock(Node node) {
      emit("{\n");
      if (node.hasChildren()) {
        increaseIndent();
        for (var i = 0; i < node.children.size(); i++) {
          emitNode(node.children.get(i));
        }
        decreaseIndent();
      }
      emit(indent + "}");
    }

    void emitExpression(Node node, Precedence precedence) {
      switch (node.kind) {
        case .NAME { emit(node.symbol == null ? node.asString() : fullName(node.symbol)); }
        case .TYPE { emitType(node.type); }
        case .THIS { emit("this"); }
        case .HOOK { emitHook(node, precedence); }
        case .NULL { emit("null"); }
        case .BOOL { emit(node.asBool().toString()); }
        case .INT { emit(node.asInt().toString()); }
        case .FLOAT, .DOUBLE { emit(node.asDouble().toString()); }
        case .STRING { emit(quoteString(node.asString(), '"')); }
        case .LIST { emitList(node); }
        case .DOT { emitDot(node); }
        case .CALL { emitCall(node); }
        case .SUPER_CALL { emitSuperCall(node); }
        case .SEQUENCE { emitSequence(node, precedence); }
        case .LAMBDA { emitLambda(node); }
        case .UNTYPED { emitExpression(node.untypedValue(), precedence); }
        case .INDEX { emitIndex(node, precedence); }
        case .ASSIGN_INDEX { emitTertiary(node, precedence); }
        case .CAST, .IMPLICIT_CAST { emitCast(node, precedence); }

        case
          .NOT, .POSITIVE, .NEGATIVE, .COMPLEMENT,
          .PREFIX_INCREMENT, .PREFIX_DECREMENT,
          .POSTFIX_INCREMENT, .POSTFIX_DECREMENT {
          emitUnary(node, precedence);
        }

        case
          .ADD, .ASSIGN, .ASSIGN_ADD, .ASSIGN_BITWISE_AND,
          .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR, .ASSIGN_DIVIDE,
          .ASSIGN_MULTIPLY, .ASSIGN_REMAINDER, .ASSIGN_SHIFT_LEFT,
          .ASSIGN_SHIFT_RIGHT, .ASSIGN_SUBTRACT, .BITWISE_AND,
          .BITWISE_OR, .BITWISE_XOR, .DIVIDE, .EQUAL, .GREATER_THAN,
          .GREATER_THAN_OR_EQUAL, .IN, .LESS_THAN, .LESS_THAN_OR_EQUAL,
          .LOGICAL_AND, .LOGICAL_OR, .MULTIPLY, .NOT_EQUAL, .REMAINDER,
          .SHIFT_LEFT, .SHIFT_RIGHT, .SUBTRACT {
          emitBinary(node, precedence);
        }

        default { emit("<" + node.kind + ">"); }
      }
    }

    void emitVariable(Node node) {
      var value = node.variableValue();
      var symbol = node.symbol;
      if (symbol.isStatic() || symbol.kind == .GLOBAL_VARIABLE) {
        emit("static ");
      }
      if (symbol.isObjectMember()) {
        emit("public ");
      }
      emitType(symbol.type);
      emit(" " + mangleName(symbol));
      if (value != null) {
        emit(" = ");
        emitExpression(value, .COMMA);
      }
    }

    void emitVariableStatement(Node node) {
      if (node.symbol.kind.isGlobal()) {
        adjustNamespace(node.symbol);
      }
      emit(indent);
      emitVariable(node);
      emit(";\n");
    }

    void emitVariableCluster(Node node) {
      var variables = node.clusterVariables();
      for (var i = 0; i < variables.size(); i++) {
        emitVariableStatement(variables.get(i));
      }
    }

    void emitSequence(Node node, Precedence precedence) {
      if (.COMMA <= precedence) emit("(");
      emitCommaSeparatedExpressions(node.children);
      if (.COMMA <= precedence) emit(")");
    }

    void emitLambda(Node node) {
      emitArgumentVariables(node.lambdaArguments());
      emit(" => ");
      emitBlock(node.lambdaBlock());
    }

    void emitUnary(Node node, Precedence precedence) {
      var value = node.unaryValue();
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var isPostfix = info.precedence == .UNARY_POSTFIX;
      if (!isPostfix) {
        emit(info.text);

        // Prevent "- -1" from becoming "--1"
        if (node.kind == .POSITIVE && (value.kind == .POSITIVE || value.kind == .PREFIX_INCREMENT) ||
            node.kind == .NEGATIVE && (value.kind == .NEGATIVE || value.kind == .PREFIX_DECREMENT || value.kind == .INT && value.asInt() < 0)) {
          emit(" ");
        }
      }
      emitExpression(value, info.precedence);
      if (isPostfix) emit(info.text);
      if (info.precedence < precedence) emit(")");
    }

    void emitBinary(Node node, Precedence precedence) {
      var kind = node.kind;
      var left = node.binaryLeft();
      var right = node.binaryRight();
      var info = operatorInfo.get(kind);
      if (info.precedence < precedence) emit("(");
      emitExpression(left, info.precedence.incrementIfRightAssociative(info.associativity));
      emit(" " + info.text + " ");
      emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity));
      if (info.precedence < precedence) emit(")");
    }

    void emitIndex(Node node, Precedence precedence) {
      emitExpression(node.binaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.binaryRight(), .LOWEST);
      emit("]");
    }

    void emitTertiary(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.tertiaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.tertiaryMiddle(), .LOWEST);
      emit("] = ");
      emitExpression(node.tertiaryRight(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    void emitList(Node node) {
      var values = node.listValues();
      emit("new ");
      emitType(node.type);
      if (values.size() > 0) {
        emit(" { ");
        emitCommaSeparatedExpressions(values);
        emit(" }");
      } else {
        emit("()");
      }
    }

    void emitDot(Node node) {
      emitExpression(node.dotTarget(), .MEMBER);
      emit(".");
      var name = node.dotName();
      emit(
        name.symbol == null ? name.asString() :
        name.symbol.kind.isInstance() ? mangleName(name.symbol) :
        fullName(name.symbol));
    }

    void emitSuperCall(Node node) {
      emit("base(");
      emitCommaSeparatedExpressions(node.superCallArguments());
      emit(")");
    }

    void emitCall(Node node) {
      var value = node.callValue();
      if (value.kind == .NAME && value.symbol != null && value.symbol.isOperator()) {
        emit(value.asString() + " ");
        emitExpression(node.callArguments().get(0), .UNARY_POSTFIX);
      } else {
        if (value.kind.isType()) emit("new ");
        emitExpression(value, .UNARY_POSTFIX);
        emit("(");
        emitCommaSeparatedExpressions(node.callArguments());
        emit(")");
      }
    }

    void emitCast(Node node, Precedence precedence) {
      // TODO: Some types need a cast
      emitExpression(node.castValue(), precedence);
    }

    void emitHook(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.hookTest(), .LOGICAL_OR);
      emit(" ? ");
      emitExpression(node.hookTrue(), .ASSIGN);
      emit(" : ");
      emitExpression(node.hookFalse(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    static StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result.set("abstract", true);
      result.set("as", true);
      result.set("base", true);
      result.set("bool", true);
      result.set("break", true);
      result.set("byte", true);
      result.set("case", true);
      result.set("catch", true);
      result.set("char", true);
      result.set("checked", true);
      result.set("class", true);
      result.set("const", true);
      result.set("continue", true);
      result.set("decimal", true);
      result.set("default", true);
      result.set("delegate", true);
      result.set("do", true);
      result.set("double", true);
      result.set("else", true);
      result.set("enum", true);
      result.set("event", true);
      result.set("explicit", true);
      result.set("extern", true);
      result.set("false", true);
      result.set("finally", true);
      result.set("fixed", true);
      result.set("float", true);
      result.set("for", true);
      result.set("foreach", true);
      result.set("goto", true);
      result.set("if", true);
      result.set("implicit", true);
      result.set("in", true);
      result.set("int", true);
      result.set("interface", true);
      result.set("internal", true);
      result.set("is", true);
      result.set("lock", true);
      result.set("long", true);
      result.set("namespace", true);
      result.set("new", true);
      result.set("null", true);
      result.set("object", true);
      result.set("operator", true);
      result.set("out", true);
      result.set("override", true);
      result.set("params", true);
      result.set("private", true);
      result.set("protected", true);
      result.set("public", true);
      result.set("readonly", true);
      result.set("ref", true);
      result.set("return", true);
      result.set("sbyte", true);
      result.set("sealed", true);
      result.set("short", true);
      result.set("sizeof", true);
      result.set("stackalloc", true);
      result.set("static", true);
      result.set("string", true);
      result.set("struct", true);
      result.set("switch", true);
      result.set("this", true);
      result.set("throw", true);
      result.set("true", true);
      result.set("try", true);
      result.set("typeof", true);
      result.set("uint", true);
      result.set("ulong", true);
      result.set("unchecked", true);
      result.set("unsafe", true);
      result.set("ushort", true);
      result.set("using", true);
      result.set("virtual", true);
      result.set("void", true);
      result.set("volatile", true);
      result.set("while", true);
      return result;
    }

    static string mangleName(Symbol symbol) {
      if (symbol.kind.isConstructor()) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (symbol.isImportOrExport()) {
        return symbol.name;
      }
      if (isKeyword.has(symbol.name)) {
        return "_" + symbol.name + "_";
      }
      return symbol.name;
    }

    static string fullName(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      var name = mangleName(symbol);
      if (putInGlobalNamespace(symbol)) {
        name = "Global." + name;
      }
      if (!symbol.kind.isInstance() && !symbol.kind.isParameter() && enclosingSymbol != null && !enclosingSymbol.kind.isGlobalNamespace()) {
        return fullName(enclosingSymbol) + "." + name;
      }
      return name;
    }

    static bool putInGlobalNamespace(Symbol symbol) {
      return symbol.kind.isGlobal() && !symbol.isObjectMember();
    }
  }
}
