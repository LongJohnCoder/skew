const var NATIVE_LIBRARY_CS = "
import class int { import string toString(); }
import class bool { import string toString(); }
import class float { import string toString(); }
import class double { import string toString(); }

import class string {
  inline int size() { return untyped(this).Length; }
  import string slice(int start, int end);
  inline int indexOf(string value) { return untyped(this).IndexOf(value); }
  inline int lastIndexOf(string value) { return untyped(this).LastIndexOf(value); }
  inline string toLowerCase() { return untyped(this).ToLower(); }
  inline string toUpperCase() { return untyped(this).ToUpper(); }
  import static string fromCodeUnit(int value);
  inline string get(int index) { return untyped(this)[index]; }
  import string join(List<string> values);
  import int codeUnitAt(int index);
  import bool startsWith(string prefix);
  import bool endsWith(string suffix);
  import string repeat(int count);
}

interface IComparison<T> {
  virtual int compare(T left, T right);
}

import class List<T> {
  new();
  inline int size() { return untyped(this).Count; }
  inline void push(T value) { untyped(this).Add(value); }
  inline void unshift(T value) { insert(0, value); }
  inline List<T> slice(int start, int end) { return untyped(this).Take(end).Skip(start).ToList(); }
  inline int indexOf(T value) { return untyped(this).IndexOf(value); }
  inline int lastIndexOf(T value) { return untyped(this).LastIndexOf(value); }
  inline T shift() { return remove(0); }
  inline T pop() { return remove(size() - 1); }
  inline void reverse() { untyped(this).Reverse(); }
  import void sort(IComparison<T> comparison);
  inline List<T> clone() { return untyped(this).ToList(); }
  inline T remove(int index) { var value = get(index); untyped(this).RemoveAt(index); return value; }
  inline void insert(int index, T value) { untyped(this).Insert(index, value); }
  inline T get(int index) { return untyped(this)[index]; }
  inline void set(int index, T value) { untyped(this)[index] = value; }
  inline void swap(int a, int b) { var temp = get(a); set(a, get(b)); set(b, temp); }
}

import namespace operators {
  import void out(int value);
}

import class Dictionary<K, V> {
  new();
}

class StringMap<T> {
  var map = Dictionary<string, T>();
  inline T get(string key) { return untyped(map)[key]; }
  inline T getOrDefault(string key, T defaultValue) { untyped(map).TryGetValue(key, operators.out(untyped(defaultValue))); return defaultValue; }
  inline void set(string key, T value) { return untyped(map).Add(key, value); }
  inline bool has(string key) { return untyped(map).ContainsKey(key); }
  inline void remove(string key) { return untyped(map).Remove(key); }
  inline List<string> keys() { return untyped(map).Keys.ToList(); }
  inline List<T> values() { return untyped(map).Keys.ToList(); }
  inline StringMap<T> clone() {
    var clone = StringMap<T>(), list = keys();
    for (var i = 0; i < list.size(); i++) {
      var key = list.get(i);
      clone.set(key, get(key));
    }
    return clone;
  }
}

class IntMap<T> {
  var map = Dictionary<int, T>();
  inline T get(int key) { return untyped(map)[key]; }
  inline T getOrDefault(int key, T defaultValue) { untyped(map).TryGetValue(key, operators.out(untyped(defaultValue))); return defaultValue; }
  inline void set(int key, T value) { return untyped(map).Add(key, value); }
  inline bool has(int key) { return untyped(map).ContainsKey(key); }
  inline void remove(int key) { return untyped(map).Remove(key); }
  inline List<int> keys() { return untyped(map).Keys.ToList(); }
  inline List<T> values() { return untyped(map).Keys.ToList(); }
  inline IntMap<T> clone() {
    var clone = IntMap<T>(), list = keys();
    for (var i = 0; i < list.size(); i++) {
      var key = list.get(i);
      clone.set(key, get(key));
    }
    return clone;
  }
}

// TODO: Rename this to \"math\" since namespaces should be lower case
import namespace Math {
  import final double E;
  import final double PI;
  import final double NAN;
  import final double INFINITY;
  import double random();
  import double abs(double n);
  import double sin(double n);
  import double cos(double n);
  import double tan(double n);
  import double asin(double n);
  import double acos(double n);
  import double atan(double n);
  import double round(double n);
  import double floor(double n);
  import double ceil(double n);
  import double exp(double n);
  import double log(double n);
  import double sqrt(double n);
  import bool isNaN(double n);
  import bool isFinite(double n);
  import double atan2(double y, double x);
  import double pow(double base, double exponent);
  import double min(double a, double b);
  import double max(double a, double b);
  import int imin(int a, int b);
  import int imax(int a, int b);
}
";
