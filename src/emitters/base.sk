namespace base {
  class Emitter : IEmitter {
    NodeKind previousKind = .NULL;
    StringMap<bool> isKeyword = null;
    List<Source> outputs = [];
    Source output = null;
    var indent = "";
    TypeCache cache = null;
    Resolver resolver;

    virtual string extension();
    virtual StringMap<bool> createIsKeyword();

    override List<Source> emitProgram(Node program) {
      cache = resolver.cache;
      isKeyword = createIsKeyword();
      output = Source("output." + extension(), "");
      outputs.push(output);
      visitProgram(program);
      return outputs;
    }

    virtual void visitProgram(Node node) {
      visitCollector(Collector(node, .SORT_BY_INHERITANCE_AND_CONTAINMENT));
    }

    void visitCollector(Collector collector) {
      for (var i = 0; i < collector.typeSymbols.size(); i++) {
        var symbol = collector.typeSymbols.get(i);
        if (!symbol.isImport()) {
          emitTypeDeclaration(symbol);
        }
      }
      for (var i = 0; i < collector.freeFunctionSymbols.size(); i++) {
        var symbol = collector.freeFunctionSymbols.get(i);
        if (!symbol.isImport()) {
          emitFunction(symbol);
        }
      }
      for (var i = 0; i < collector.freeVariableSymbols.size(); i++) {
        var symbol = collector.freeVariableSymbols.get(i);
        if (!symbol.isImport()) {
          emitVariable(symbol);
        }
      }
    }

    void emitTypeMembers(Symbol symbol) {
      var members = symbol.type.members.values();
      for (var i = 0; i < members.size(); i++) {
        var member = members.get(i).symbol;
        if (!member.isImport() && member.enclosingSymbol == symbol) {
          if (member.kind.isFunction()) {
            emitFunction(member);
          } else if (member.kind.isVariable()) {
            emitVariable(member);
          }
        }
      }
    }

    virtual void emitTypeBeforeVariable(Symbol symbol) {
      emitType(symbol.type);
      emit(" ");
    }

    virtual void emitTypeDeclaration(Symbol symbol);
    virtual void emitFunction(Symbol symbol);
    virtual void emitVariable(Symbol symbol);
    virtual void emitFunctionArgument(Symbol symbol);

    virtual void emitTypeParameter(Symbol symbol) {
      emit(mangleName(symbol));
    }

    void emitFunctionArguments(Symbol symbol) {
      var arguments = symbol.node.functionArguments();
      emit("(");
      if (arguments.hasChildren()) {
        for (var i = 0; i < arguments.children.size(); i++) {
          if (i > 0) emit(", ");
          emitFunctionArgument(arguments.children.get(i).symbol);
        }
      }
      emit(")");
    }

    virtual void emitTypeParameters(Symbol symbol) {
      if (symbol.hasParameters()) {
        emit("<");
        for (var i = 0; i < symbol.parameters.size(); i++) {
          if (i > 0) emit(", ");
          emitTypeParameter(symbol.parameters.get(i));
        }
        emit(">");
      }
    }

    void forceEmitExtraNewline() {
      if (previousKind != .NULL) {
        emit("\n");
      }
      previousKind = .NULL;
    }

    bool isFlowNodeKind(NodeKind kind) {
      return kind == .EXPRESSION || kind == .VARIABLE || kind == .VARIABLE_CLUSTER || kind.isJump() || kind == .ASSERT;
    }

    virtual bool shouldEmitExtraNewlineBetween(NodeKind before, NodeKind after) {
      return !isFlowNodeKind(before) || !isFlowNodeKind(after) || before != .VARIABLE_CLUSTER && after == .VARIABLE_CLUSTER;
    }

    void emitExtraNewlineBefore(NodeKind kind) {
      if (previousKind != .NULL && shouldEmitExtraNewlineBetween(previousKind, kind)) {
        emit("\n");
      }
      previousKind = .NULL;
    }

    void emitExtraNewlineAfter(NodeKind kind) {
      previousKind = kind;
    }

    void emitAfterVariable(Node node) {
      var value = node.variableValue();
      if (value != null) {
        emit(" = ");
        emitExpression(value, .COMMA);
      }
    }

    void increaseIndent() {
      previousKind = .NULL;
      indent += "  ";
    }

    void decreaseIndent() {
      indent = indent.slice(2, indent.size());
    }

    void emit(string text) {
      output.contents += text;
    }

    virtual void emitBlock(Node node) {
      emit(" {\n");
      increaseIndent();
      previousKind = .NULL;
      emitStatements(node.blockStatements());
      decreaseIndent();
      emit(indent + "}");
      previousKind = .NULL;
    }

    void emitStatements(List<Node> nodes) {
      for (var i = 0; i < nodes.size(); i++) {
        var child = nodes.get(i);
        var kind = child.kind;
        if (kind != .MODIFIER) emitExtraNewlineBefore(kind);
        emitStatement(child);
        if (kind != .MODIFIER) emitExtraNewlineAfter(kind);
      }
    }

    void emitStatement(Node node) {
      switch (node.kind) {
        case .CASE { emitCase(node); }
        case .VARIABLE_CLUSTER { emitStatements(node.clusterVariables()); }
        case .IF { emitIf(node); }
        case .FOR { emitFor(node); }
        case .FOR_EACH { emitForEach(node); }
        case .WHILE { emitWhile(node); }
        case .DO_WHILE { emitDoWhile(node); }
        case .RETURN { emitReturn(node); }
        case .BREAK { emitBreak(node); }
        case .CONTINUE { emitContinue(node); }
        case .ASSERT { emitAssert(node); }
        case .EXPRESSION { emitExpressionStatement(node); }
        case .SWITCH { emitSwitch(node); }
        case .MODIFIER { emitStatements(node.modifierStatements()); }
        case .VARIABLE { emitVariable(node.symbol); }
        default { assert false; }
      }
    }

    virtual void endStatement() {
      emit(";\n");
    }

    void emitCase(Node node) {
      var values = node.caseValues();
      var block = node.caseBlock();
      if (values.size() > 0) {
        for (var i = 0; i < values.size(); i++) {
          if (i > 0) emit("\n");
          emit(indent + "case ");
          emitExpression(values.get(i), .LOWEST);
          emit(":");
        }
      } else {
        emit(indent + "default:");
      }
      emit(" {\n");
      increaseIndent();
      emitStatements(block.blockStatements());
      if (!block.blockAlwaysEndsWithReturn()) {
        emit(indent + "break;\n");
      }
      decreaseIndent();
      emit(indent + "}\n");
    }

    void emitSwitch(Node node) {
      var cases = node.switchCases();
      emit(indent + "switch (");
      emitExpression(node.switchValue(), .LOWEST);
      emit(") {\n");
      increaseIndent();
      previousKind = .NULL;
      for (var i = 0; i < cases.size(); i++) {
        var child = cases.get(i);
        emitExtraNewlineBefore(child.kind);
        emitCase(child);
        emitExtraNewlineAfter(child.kind);
      }
      decreaseIndent();
      emit(indent + "}\n");
    }

    void recursiveEmitIfStatement(Node node) {
      var falseBlock = node.ifFalse();
      emit("if (");
      emitExpression(node.ifTest(), .LOWEST);
      emit(")");
      emitBlock(node.ifTrue());
      if (falseBlock != null) {
        var falseStatement = falseBlock.blockStatement();
        if (falseStatement != null && falseStatement.kind == .IF) {
          emit(" else ");
          recursiveEmitIfStatement(falseStatement);
        } else {
          emit(" else");
          emitBlock(falseBlock);
        }
      }
    }

    virtual void emitIf(Node node) {
      emit(indent);
      recursiveEmitIfStatement(node);
      emit("\n");
    }

    virtual void emitForVariables(List<Node> nodes) {
      emitTypeBeforeVariable(nodes.get(0).symbol);
      for (var i = 0; i < nodes.size(); i++) {
        if (i > 0) emit(", ");
        var node = nodes.get(i);
        var value = node.variableValue();
        emit(mangleName(node.symbol));
        emitAfterVariable(node);
      }
    }

    void emitFor(Node node) {
      var setup = node.forSetup();
      var test = node.forTest();
      var update = node.forUpdate();
      emit(indent + "for (");
      if (setup != null) {
        if (setup.kind == .VARIABLE_CLUSTER) {
          emitForVariables(setup.clusterVariables());
        } else {
          emitExpression(setup, .LOWEST);
        }
      }
      if (test != null) {
        emit("; ");
        emitExpression(test, .LOWEST);
      } else {
        emit(";");
      }
      if (update != null) {
        emit("; ");
        emitExpression(update, .LOWEST);
      } else {
        emit(";");
      }
      emit(")");
      emitBlock(node.forBlock());
      emit("\n");
    }

    void emitForEach(Node node) {
    }

    void emitWhile(Node node) {
      emit(indent + "while (");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")");
      emitBlock(node.whileBlock());
      emit("\n");
    }

    void emitDoWhile(Node node) {
      emit(indent + "do");
      emitBlock(node.whileBlock());
      emit(" while (");
      emitExpression(node.whileTest(), .LOWEST);
      emit(")");
      endStatement();
    }

    void emitReturn(Node node) {
      var value = node.returnValue();
      if (value != null) {
        emit(indent + "return ");
        emitExpression(value, .LOWEST);
      } else {
        emit(indent + "return");
      }
      endStatement();
    }

    void emitBreak(Node node) {
      emit(indent + "break");
      endStatement();
    }

    void emitContinue(Node node) {
      emit(indent + "continue");
      endStatement();
    }

    virtual void emitAssert(Node node);

    void emitExpressionStatement(Node node) {
      emit(indent);
      emitExpression(node.expressionValue(), .LOWEST);
      endStatement();
    }

    void emitExpression(Node node, Precedence precedence) {
      var kind = node.kind;
      switch (kind) {
        case .NAME { emitName(node); }
        case .TYPE { emitType(node.type); }
        case .THIS { emitThis(); }
        case .HOOK { emitHook(node, precedence); }
        case .NULL { emitNull(); }
        case .BOOL { emitBool(node); }
        case .INT { emitInt(node, precedence); }
        case .FLOAT, .DOUBLE { emitReal(node); }
        case .STRING { emitString(node); }
        case .DOT { emitDot(node); }
        case .CALL { emitCall(node, precedence); }
        case .SEQUENCE { emitSequence(node, precedence); }
        case .INDEX { emitIndex(node, precedence); }
        case .ASSIGN_INDEX { emitTernary(node, precedence); }
        case .CAST, .IMPLICIT_CAST { emitCast(node, precedence); }
        case .LIST { emitList(node); }
        case .SUPER_CALL { emitSuperCall(node); }
        case .UNTYPED { emitExpression(node.untypedValue(), precedence); }
        default {
          if (kind.isUnaryOperator()) emitUnary(node, precedence);
          else if (kind.isBinaryOperator()) emitBinary(node, precedence);
          else assert false;
        }
      }
    }

    void emitCommaSeparatedExpressions(List<Node> nodes) {
      for (var i = 0; i < nodes.size(); i++) {
        if (i > 0) emit(", ");
        emitExpression(nodes.get(i), .COMMA);
      }
    }

    void emitSequence(Node node, Precedence precedence) {
      var values = node.sequenceValues();
      assert values.size() > 1;
      assert node.parent.kind == .EXPRESSION || node.parent.kind == .FOR;
      if (.COMMA <= precedence) emit("(");
      emitCommaSeparatedExpressions(node.sequenceValues());
      if (.COMMA <= precedence) emit(")");
    }

    virtual bool hasUnaryStorageOperators() {
      return true;
    }

    virtual void emitUnaryPrefixOperator(Node node) {
      emit(operatorInfo.get(node.kind).text);

      // Prevent "- -1" from becoming "--1"
      var value = node.unaryValue();
      if (node.kind == .POSITIVE && (value.kind == .POSITIVE || value.kind == .PREFIX_INCREMENT) ||
          node.kind == .NEGATIVE && (value.kind == .NEGATIVE || value.kind == .PREFIX_DECREMENT || value.kind == .INT && value.asInt() < 0)) {
        emit(" ");
      }
    }

    void emitUnary(Node node, Precedence precedence) {
      var value = node.unaryValue();
      if (node.kind.isUnaryStorageOperator() && !hasUnaryStorageOperators()) {
        if (.ASSIGN < precedence) emit("(");
        emitExpression(value, .ASSIGN);
        emit(node.kind == .PREFIX_INCREMENT || node.kind == .POSTFIX_INCREMENT ? " += 1" : " -= 1");
        if (.ASSIGN < precedence) emit(")");
        return;
      }
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      var isPostfix = info.precedence == .UNARY_POSTFIX;
      if (!isPostfix) emitUnaryPrefixOperator(node);
      emitExpression(value, info.precedence);
      if (isPostfix) emit(info.text);
      if (info.precedence < precedence) emit(")");
    }

    virtual void emitBinary(Node node, Precedence precedence) {
      var info = operatorInfo.get(node.kind);
      if (info.precedence < precedence) emit("(");
      emitExpression(node.binaryLeft(), info.precedence.incrementIfRightAssociative(info.associativity));
      emit(" " + info.text + " ");
      emitExpression(node.binaryRight(), info.precedence.incrementIfLeftAssociative(info.associativity));
      if (info.precedence < precedence) emit(")");
    }

    void emitIndex(Node node, Precedence precedence) {
      emitExpression(node.binaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.binaryRight(), .LOWEST);
      emit("]");
    }

    void emitTernary(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.ternaryLeft(), .MEMBER);
      emit("[");
      emitExpression(node.ternaryMiddle(), .LOWEST);
      emit("] = ");
      emitExpression(node.ternaryRight(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    virtual void emitDot(Node node) {
      emitExpression(node.dotTarget(), .MEMBER);
      emit(".");
      emit(mangleName(node.symbol));
    }

    virtual void emitCall(Node node, Precedence precedence) {
      var value = node.callValue();
      if (value.kind == .TYPE) {
        emit("new ");
      }
      emitExpression(value, .UNARY_POSTFIX);
      emit("(");
      emitCommaSeparatedExpressions(node.callArguments());
      emit(")");
    }

    void emitParenthesizedCast(Node node, Precedence precedence) {
      if (.UNARY_PREFIX < precedence) emit("(");
      emit("(");
      emitNormalType(node.castType().type);
      emit(")");
      emitExpression(node.castValue(), .UNARY_PREFIX);
      if (.UNARY_PREFIX < precedence) emit(")");
    }

    virtual void emitCast(Node node, Precedence precedence) {
      if (node.kind == .CAST) {
        emitParenthesizedCast(node, precedence);
      } else {
        emitExpression(node.castValue(), precedence);
      }
    }

    virtual void emitList(Node node) {
      emit("[");
      emitCommaSeparatedExpressions(node.listValues());
      emit("]");
    }

    virtual void emitSuperCall(Node node) {
      emit("super(");
      emitCommaSeparatedExpressions(node.superCallArguments());
      emit(")");
    }

    virtual void emitName(Node node) {
      var symbol = node.symbol;
      emit(symbol != null ? symbol.kind.isInstance() ? mangleName(symbol) : fullName(symbol) : node.asString());
    }

    virtual void emitThis() {
      emit("this");
    }

    virtual void emitHook(Node node, Precedence precedence) {
      if (.ASSIGN < precedence) emit("(");
      emitExpression(node.hookTest(), .LOGICAL_OR);
      emit(" ? ");
      emitExpression(node.hookTrue(), .ASSIGN);
      emit(" : ");
      emitExpression(node.hookFalse(), .ASSIGN);
      if (.ASSIGN < precedence) emit(")");
    }

    virtual void emitNull() {
      emit("null");
    }

    virtual void emitBool(Node node) {
      emit(node.asBool().toString());
    }

    virtual void emitInt(Node node, Precedence precedence) {
      if (node.type.isEnum() && node.symbol != null) {
        emitName(node);
      } else {
        emit(node.asInt().toString());
      }
    }

    virtual void emitReal(Node node) {
      emit(node.asDouble().toString());
    }

    virtual void emitString(Node node) {
      emit(quoteString(node.asString(), '"'));
    }

    virtual void emitNormalType(Type type) {
      emitType(type);
    }

    void emitType(Type type) {
      assert !type.isFunction();
      emit(fullName(type.symbol));
      if (type.isParameterized()) {
        emit("<");
        for (var i = 0; i < type.substitutions.size(); i++) {
          if (i > 0) emit(", ");
          emitNormalType(type.substitutions.get(i));
        }
        emit(">");
      }
    }

    virtual string mangleName(Symbol symbol) {
      if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
        return mangleName(symbol.enclosingSymbol);
      }
      if (isKeyword.has(symbol.name) && !symbol.isImport()) {
        return "_" + symbol.name + "_";
      }
      return symbol.name;
    }

    virtual bool useDoubleColonForEnclosingSymbols() {
      return false;
    }

    virtual string fullName(Symbol symbol) {
      var name = mangleName(symbol);
      if (symbol.enclosingSymbol != null && symbol.enclosingSymbol.kind != .GLOBAL_NAMESPACE && !symbol.kind.isParameter()) {
        return fullName(symbol.enclosingSymbol) + (useDoubleColonForEnclosingSymbols() ? "::" : ".") + name;
      }
      return name;
    }
  }
}
