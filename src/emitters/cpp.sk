namespace cpp {
  enum Pass {
    NONE,
    FORWARD_DECLARE_TYPES,
    FORWARD_DECLARE_CODE,
    IMPLEMENT_CODE,
  }

  enum CppEmitType {
    BARE,
    NORMAL,
    DECLARATION,
  }

  class Emitter : base.Emitter {
    List<string> namespaceStack = [];
    var usedAssert = false;
    Pass pass = .NONE;

    override string extension() {
      return "cpp";
    }

    override void visitProgram(Node node) {
      // Emit code in three passes
      var collector = Collector(node, .SORT_BY_INHERITANCE_AND_CONTAINMENT);

      pass = .FORWARD_DECLARE_TYPES;
      visitCollector(collector);
      adjustNamespace(null);
      forceEmitExtraNewline();

      pass = .FORWARD_DECLARE_CODE;
      visitCollector(collector);
      adjustNamespace(null);
      forceEmitExtraNewline();

      pass = .IMPLEMENT_CODE;
      visitCollector(collector);
      adjustNamespace(null);

      // Prepend the necessary headers after all code has been emitted
      var headers = "";
      if (usedAssert) headers += "#include <cassert>\n";
      if (headers != "") output.contents = headers + "\n" + output.contents;
    }

    override bool shouldEmitExtraNewlineBetween(NodeKind before, NodeKind after) {
      if (pass == .FORWARD_DECLARE_TYPES) {
        return before == .NAMESPACE || after == .NAMESPACE || before.isEnum() || after.isEnum();
      }
      return super(before, after) && (pass != .FORWARD_DECLARE_CODE || !before.isFunction() || !after.isFunction());
    }

    override void emitTypeParameter(Symbol symbol) {
      emit("typename " + mangleName(symbol));
    }

    override void emitTypeParameters(Symbol symbol) {
      if (symbol.hasParameters()) {
        emit(indent + "template ");
        super(symbol);
        emit("\n");
      }
    }

    void emitEnumValues(Symbol symbol) {
      var members = symbol.type.members.values();
      var isEnumFlags = symbol.kind == .ENUM_FLAGS;
      var isFirst = true;
      var previous = -1;
      for (var i = 0; i < members.size(); i++) {
        var member = members.get(i).symbol;
        if (member.isEnumValue()) {
          if (isFirst) {
            isFirst = false;
          } else {
            emit(",\n");
          }
          var value = member.constant.asInt();
          emit(indent + mangleName(member));
          if (isEnumFlags || value != previous + 1) {
            emit(" = " + value);
          }
          previous = value;
        }
      }
      if (!isFirst) {
        emit("\n");
      }
    }

    override void emitTypeDeclaration(Symbol symbol) {
      if (symbol.kind.isObject()) {
        if (pass != .IMPLEMENT_CODE) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(symbol.node.kind);
          emitTypeParameters(symbol);
          emit(indent + "struct " + mangleName(symbol));
          if (pass == .FORWARD_DECLARE_CODE) {
            if (symbol.type.hasRelevantTypes()) {
              var types = symbol.type.relevantTypes;
              emit(" : ");
              for (var i = 0; i < types.size(); i++) {
                if (i > 0) emit(", ");
                emitCppType(types.get(i), .BARE);
              }
            }
            emit(" {\n");
            increaseIndent();
            emitTypeMembers(symbol);
            decreaseIndent();
            emit(indent + "}");
          }
          emit(";\n");
          emitExtraNewlineAfter(symbol.node.kind);
        } else {
          emitTypeMembers(symbol);
        }
      }

      else if (symbol.kind == .ENUM) {
        if (pass == .FORWARD_DECLARE_TYPES) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(.ENUM);
          emit(indent + "enum struct " + mangleName(symbol) + " {\n");
          increaseIndent();
          emitEnumValues(symbol);
          decreaseIndent();
          emit(indent + "};\n");
          emitExtraNewlineAfter(.ENUM);
        }
      }

      else if (symbol.kind == .ENUM_FLAGS) {
        if (pass == .FORWARD_DECLARE_TYPES) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(.ENUM_FLAGS);
          emit(indent + "namespace " + mangleName(symbol) + " {\n");
          increaseIndent();
          emit(indent + "enum {\n");
          increaseIndent();
          emitEnumValues(symbol);
          decreaseIndent();
          emit(indent + "};\n");
          decreaseIndent();
          emit(indent + "}\n");
          emitExtraNewlineAfter(.ENUM_FLAGS);
        }
      }
    }

    override void emitFunction(Symbol symbol) {
      if (pass != .FORWARD_DECLARE_TYPES) {
        var node = symbol.node;
        var block = node.functionBlock();
        if (block != null || pass == .FORWARD_DECLARE_CODE) {
          adjustNamespace(pass == .FORWARD_DECLARE_CODE ? symbol : null);
          emitExtraNewlineBefore(node.kind);
          emitTypeParameters(symbol);
          emit(indent);
          if (pass == .FORWARD_DECLARE_CODE) {
            if (symbol.isStatic()) emit("static ");
            if (symbol.isVirtual()) emit("virtual ");
          }
          if (symbol.kind != .CONSTRUCTOR_FUNCTION) {
            emitCppType(symbol.type.resultType(), .DECLARATION);
          }
          emit(pass == .FORWARD_DECLARE_CODE ? mangleName(symbol) : fullName(symbol));
          emitFunctionArguments(symbol);
          if (block == null) {
            emit(" = 0;");
          } else if (pass == .FORWARD_DECLARE_CODE) {
            emit(";");
          } else {
            if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
              var superInitializer = node.superInitializer();
              var memberInitializers = node.memberInitializers();
              var superCallArguments = superInitializer != null ? superInitializer.superCallArguments() : null;
              if (superInitializer != null && superCallArguments.size() > 0 || memberInitializers != null && memberInitializers.hasChildren()) {
                emit(" : ");
                if (superInitializer != null && superCallArguments.size() > 0) {
                  emit(fullName(superInitializer.symbol) + "(");
                  emitCommaSeparatedExpressions(superInitializer.superCallArguments());
                  emit(")");
                  if (memberInitializers != null && memberInitializers.hasChildren()) {
                    emit(", ");
                  }
                }
                if (memberInitializers != null) {
                  for (var i = 0; i < memberInitializers.children.size(); i++) {
                    var initializer = memberInitializers.children.get(i);
                    if (i > 0) emit(", ");
                    emit(mangleName(initializer.symbol) + "(");
                    emitExpression(initializer.memberInitializerValue(), .LOWEST);
                    emit(")");
                  }
                }
              }
            }
            emitBlock(block);
          }
          emit("\n");
          emitExtraNewlineAfter(node.kind);
        }
      }
    }

    override void emitTypeBeforeVariable(Symbol symbol) {
      emitCppType(symbol.type, .DECLARATION);
    }

    override void emitVariable(Symbol symbol) {
      if (pass != .FORWARD_DECLARE_TYPES && (pass == .FORWARD_DECLARE_CODE || symbol.kind != .INSTANCE_VARIABLE)) {
        adjustNamespace(pass == .FORWARD_DECLARE_CODE ? symbol : null);
        emitExtraNewlineBefore(symbol.node.kind);
        emit(indent);
        if (pass == .FORWARD_DECLARE_CODE && symbol.kind.isGlobal()) {
          emit(symbol.isStatic() ? "static " : "extern ");
        }
        emitTypeBeforeVariable(symbol);
        if (pass == .FORWARD_DECLARE_CODE) {
          emit(mangleName(symbol));
        } else {
          emit(fullName(symbol));
          emitAfterVariable(symbol.node);
        }
        emit(";\n");
        emitExtraNewlineAfter(symbol.node.kind);
      }
    }

    override void emitFunctionArgument(Symbol symbol) {
      emitCppType(symbol.type, .DECLARATION);
      emit(mangleName(symbol));
      emitAfterVariable(symbol.node);
    }

    override void emitAssert(Node node) {
      emit(indent + "assert(");
      emitExpression(node.assertValue(), .LOWEST);
      emit(");\n");
      usedAssert = true;
    }

    override void emitBinary(Node node, Precedence precedence) {
      // Clang warns about && inside || or & inside | without parentheses
      if (node.parent.kind == .LOGICAL_OR && node.kind == .LOGICAL_AND ||
          node.parent.kind == .BITWISE_OR && node.kind == .BITWISE_AND) {
        precedence = .MEMBER;
      }

      super(node, precedence);
    }

    override void emitNull() {
      emit("nullptr");
    }

    override void emitReal(Node node) {
      super(node);
      if (node.kind == .FLOAT) {
        emit("f");
      }
    }

    override void emitDot(Node node) {
      var target = node.dotTarget();
      emitExpression(target, .MEMBER);
      emit(target.type.isReference() ? "->" : ".");
      emit(mangleName(node.symbol));
    }

    override void emitCall(Node node, Precedence precedence) {
      var wrap = node.callValue().kind == .TYPE && precedence == .MEMBER;
      if (wrap) emit("(");
      super(node, precedence);
      if (wrap) emit(")");
    }

    override void emitCast(Node node, Precedence precedence) {
      // C++11 doesn't auto-convert enums to ints for some reason
      if (node.type.isInt(cache) && node.castValue().type.isRegularEnum()) {
        emitParenthesizedCast(node, precedence);
      } else {
        super(node, precedence);
      }
    }

    override void emitList(Node node) {
      var values = node.listValues();
      if (values.size() > 0) {
        emit("new ");
        emitCppType(node.type, .BARE);
        emit(" { ");
        emitCommaSeparatedExpressions(values);
        emit(" }");
      } else {
        emit("new ");
        emitCppType(node.type, .BARE);
        emit("()");
      }
    }

    override void emitSuperCall(Node node) {
      emit(fullName(node.symbol));
      emit("(");
      emitCommaSeparatedExpressions(node.superCallArguments());
      emit(")");
    }

    override void emitNormalType(Type type) {
      emitCppType(type, .NORMAL);
    }

    void emitCppType(Type type, CppEmitType mode) {
      if (type.isEnumFlags()) {
        emit("int");
      } else {
        emitType(type);
      }
      if (type.isReference() && mode != .BARE) {
        emit(" *");
      } else if (mode == .DECLARATION) {
        emit(" ");
      }
    }

    override bool useDoubleColonForEnclosingSymbols() {
      return true;
    }

    void adjustNamespace(Symbol symbol) {
      // Get the namespace chain for this symbol
      List<string> names = [];
      while (symbol != null && symbol.kind != .GLOBAL_NAMESPACE) {
        if (symbol.kind == .NAMESPACE) {
          names.unshift(mangleName(symbol));
        }
        symbol = symbol.enclosingSymbol;
      }

      // Find the intersection
      var n = namespaceStack.size() < names.size() ? namespaceStack.size() : names.size();
      int i;
      for (i = 0; i < n; i++) {
        if (namespaceStack.get(i) != names.get(i)) {
          break;
        }
      }

      // Leave the old namespace
      while (namespaceStack.size() > i) {
        namespaceStack.pop();
        decreaseIndent();
        emit(indent + "}\n");
        emitExtraNewlineAfter(.NAMESPACE);
      }

      // Enter the new namespace
      while (namespaceStack.size() < names.size()) {
        var name = names.get(namespaceStack.size());
        emitExtraNewlineBefore(.NAMESPACE);
        emit(indent + "namespace " + name + " {\n");
        increaseIndent();
        namespaceStack.push(name);
      }
    }

    override StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result.set("alignas", true);
      result.set("alignof", true);
      result.set("and", true);
      result.set("and_eq", true);
      result.set("asm", true);
      result.set("auto", true);
      result.set("bitand", true);
      result.set("bitor", true);
      result.set("bool", true);
      result.set("break", true);
      result.set("case", true);
      result.set("catch", true);
      result.set("char", true);
      result.set("char16_t", true);
      result.set("char32_t", true);
      result.set("class", true);
      result.set("compl", true);
      result.set("const", true);
      result.set("const_cast", true);
      result.set("constexpr", true);
      result.set("continue", true);
      result.set("decltype", true);
      result.set("default", true);
      result.set("delete", true);
      result.set("do", true);
      result.set("double", true);
      result.set("dynamic_cast", true);
      result.set("else", true);
      result.set("enum", true);
      result.set("explicit", true);
      result.set("export", true);
      result.set("extern", true);
      result.set("false", true);
      result.set("float", true);
      result.set("for", true);
      result.set("friend", true);
      result.set("goto", true);
      result.set("if", true);
      result.set("inline", true);
      result.set("int", true);
      result.set("long", true);
      result.set("mutable", true);
      result.set("namespace", true);
      result.set("new", true);
      result.set("noexcept", true);
      result.set("not", true);
      result.set("not_eq", true);
      result.set("NULL", true);
      result.set("nullptr", true);
      result.set("operator", true);
      result.set("or", true);
      result.set("or_eq", true);
      result.set("private", true);
      result.set("protected", true);
      result.set("public", true);
      result.set("register", true);
      result.set("reinterpret_cast", true);
      result.set("return", true);
      result.set("short", true);
      result.set("signed", true);
      result.set("sizeof", true);
      result.set("static", true);
      result.set("static_assert", true);
      result.set("static_cast", true);
      result.set("struct", true);
      result.set("switch", true);
      result.set("template", true);
      result.set("this", true);
      result.set("thread_local", true);
      result.set("throw", true);
      result.set("true", true);
      result.set("try", true);
      result.set("typedef", true);
      result.set("typeid", true);
      result.set("typename", true);
      result.set("union", true);
      result.set("unsigned", true);
      result.set("using", true);
      result.set("virtual", true);
      result.set("void", true);
      result.set("volatile", true);
      result.set("wchar_t", true);
      result.set("while", true);
      result.set("xor", true);
      result.set("xor_eq", true);
      return result;
    }
  }
}
