import int parseIntLiteral(string value, int base);
import double parseDoubleLiteral(string value);
import string encodeBase64(string data);
import double now(); // The current time in seconds

final string BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
final string HEX = "0123456789ABCDEF";

class UnionFind {
  List<int> parents = [];

  new(int count) {
    for (var i = 0; i < count; i++) {
      parents.push(i);
    }
  }

  int allocate() {
    var index = parents.size();
    parents.push(index);
    return index;
  }

  void union(int left, int right) {
    parents[find(left)] = find(right);
  }

  int find(int index) {
    assert index >= 0 && index < parents.size();
    var parent = parents[index];
    if (parent != index) {
      parent = find(parent);
      parents[index] = parent;
    }
    return parent;
  }
}

in int {
  bool canIncrement() {
    return this + 1 == ((double)this + 1);
  }

  bool canDecrement() {
    return this - 1 == ((double)this - 1);
  }
}

int hashCombine(int left, int right) {
  return left ^ right - 0x61c88647 + (left << 6) + (left >> 2);
}

// Returns the log2(value) or -1 if log2(value) is not an integer
int logBase2(int value) {
  if (value < 1 || (value & (value - 1)) != 0) {
    return -1;
  }
  var result = 0;
  while (value > 1) {
    value >>= 1;
    result++;
  }
  return result;
}

int parseHexCharacter(int c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'F') return c - 'A' + 10;
  if (c >= 'a' && c <= 'f') return c - 'a' + 10;
  return -1;
}

StringContent parseStringLiteral(Log log, Range range, string text) {
  assert text.size() >= 2;
  assert text[0] == '"' || text[0] == '\'';
  assert text[text.size() - 1] == '"' || text[text.size() - 1] == '\'';
  var isValidString = true;
  var result = "";
  var start = 1; // Append long runs of unescaped characters using a single slice() for speed
  var i = 1;
  while (i + 1 < text.size()) {
    var c = text[i];
    i++;
    if (c == '\\') {
      var escape = i - 1;
      result += text.slice(start, escape);
      if (i + 1 < text.size()) {
        c = text[i]; i++;
        if (c == 'n') { result += "\n"; start = i; }
        else if (c == 'r') { result += "\r"; start = i; }
        else if (c == 't') { result += "\t"; start = i; }
        else if (c == 'e') { result += "\e"; start = i; }
        else if (c == '0') { result += "\0"; start = i; }
        else if (c == '\\' || c == '"' || c == '\'') { result += string.fromCodeUnit(c); start = i; }
        else if (c == 'x') {
          if (i + 1 < text.size()) {
            var c0 = parseHexCharacter(text[i]); i++;
            if (i + 1 < text.size()) {
              var c1 = parseHexCharacter(text[i]); i++;
              if (c0 != -1 && c1 != -1) { result += string.fromCodeUnit(c0 << 4 | c1); start = i; }
            }
          }
        }
      }
      if (start < i) {
        syntaxErrorInvalidEscapeSequence(log, Range(range.source, range.start + escape, range.start + i), text.slice(escape, i));
        isValidString = false;
      }
    }
  }
  result += text.slice(start, i);
  return isValidString ? StringContent(result) : null;
}

string quoteString(string text, int quote) {
  var result = "";
  var quoteString = string.fromCodeUnit(quote);
  result += quoteString;
  var start = 0; // Append long runs of unescaped characters using a single slice() for speed
  int i;
  for (i = 0; i < text.size(); i++) {
    var c = text[i];
    if (c == quote) result += text.slice(start, i) + "\\" + quoteString;
    else if (c == '\n') result += text.slice(start, i) + "\\n";
    else if (c == '\r') result += text.slice(start, i) + "\\r";
    else if (c == '\t') result += text.slice(start, i) + "\\t";
    else if (c == '\0') result += text.slice(start, i) + "\\0";
    else if (c == '\\') result += text.slice(start, i) + "\\\\";
    else if (c < ' ' || c >= 0x7F && c <= 0xFF) result += text.slice(start, i) + "\\x" + HEX.sliceOne(c >> 4) + HEX.sliceOne(c & 15);
    else continue;
    start = i + 1;
  }
  result += text.slice(start, i) + quoteString;
  return result;
}

// TODO: Move this into the standard library
in string {
  string replace(string before, string after) {
    var text = this;
    var result = "";
    var index = text.indexOf(before);
    while (index != -1) {
      result += text.slice(0, index) + after;
      text = text.slice(index + before.size(), text.size());
      index = text.indexOf(before);
    }
    return result + text;
  }
}

string plural(int value, string singular, string plural) {
  return value == 1 ? singular : plural;
}

class SplitPath {
  final string directory;
  final string entry;
}

SplitPath splitPath(string path) {
  var forwardSlash = path.lastIndexOf("/");
  var backwardSlash = path.lastIndexOf("\\");
  var slashIndex = forwardSlash > backwardSlash ? forwardSlash : backwardSlash;
  return slashIndex == -1
    ? SplitPath(".", path)
    : SplitPath(path.slice(0, slashIndex), path.slice(slashIndex + 1, path.size()));
}

string joinPath(string directory, string entry) {
  return directory + "/" + entry;
}

string formatNumber(double number) {
  return (math.round(number * 10) / 10).toString();
}

enum ByteSize {
  KB = 1 << 10,
  MB = 1 << 20,
  GB = 1 << 30,
}

string bytesToString(int bytes) {
  if (bytes == 1) return "1 byte";
  if (bytes < ByteSize.KB) return bytes + " bytes";
  if (bytes < ByteSize.MB) return formatNumber(bytes / (double)ByteSize.KB) + "kb";
  if (bytes < ByteSize.GB) return formatNumber(bytes / (double)ByteSize.MB) + "mb";
  return formatNumber(bytes / (double)ByteSize.GB) + "gb";
}

namespace trace {
  const var GENERICS = false;

  void indent() {}
  void dedent() {}
  void log(string text) {}
}

class StringComparison : Comparison<string> {
  static final var INSTANCE = StringComparison();

  override int compare(string a, string b) {
    return (int)(a > b) - (int)(a < b);
  }
}
