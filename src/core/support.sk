import double parseIntLiteral(string value, int base); // Returns NaN on error
import double parseDoubleLiteral(string value);
import double now(); // The current time in seconds

final string BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
final string HEX = "0123456789ABCDEF";

string encodeBase64(string data) {
  StringBuilder result = StringBuilder();
  int n = data.length;
  int i;
  for (i = 0; i + 2 < n; i = i + 3) {
    int c = data.codeUnitAt(i) << 16 | data.codeUnitAt(i + 1) << 8 | data.codeUnitAt(i + 2);
    result.append(BASE64.get(c >> 18)).append(BASE64.get(c >> 12 & 0x3F)).append(BASE64.get(c >> 6 & 0x3F)).append(BASE64.get(c & 0x3F));
  }
  if (i < n) {
    int a = data.codeUnitAt(i);
    result.append(BASE64.get(a >> 2));
    if (i + 1 < n) {
      int b = data.codeUnitAt(i + 1);
      result.append(BASE64.get(a << 4 & 0x30 | b >> 4)).append(BASE64.get(b << 2 & 0x3C)).append("=");
    } else {
      result.append(BASE64.get(a << 4 & 0x30)).append("==");
    }
  }
  return result.toString();
}

int hashCombine(int left, int right) {
  return left ^ right - 0x61c88647 + (left << 6) + (left >> 2);
}

string doubleToString(double value) {
  string result = value.toString();
  if (result.indexOf(".") < 0) {
    result = result.append(".0");
  }
  return result;
}

int parseHexCharacter(int c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'F') return c - 'A' + 10;
  if (c >= 'a' && c <= 'f') return c - 'a' + 10;
  return -1;
}

StringContent parseStringLiteral(Log log, Range range, string text) {
  bool isValidString = true;
  StringBuilder result = StringBuilder();
  int start = 1; // Append long runs of unescaped characters using a single slice() for speed
  int i = 1;
  while (i + 1 < text.length) {
    int c = text.codeUnitAt(i);
    if (c == '\\') {
      result.append(text.slice(start, i));
      int escape = i++;
      if (i + 1 < text.length) {
        c = text.codeUnitAt(i++);
        if (c == 'n') { result.append("\n"); start = i; continue; }
        else if (c == 'r') { result.append("\r"); start = i; continue; }
        else if (c == 't') { result.append("\t"); start = i; continue; }
        else if (c == 'e') { result.append("\e"); start = i; continue; }
        else if (c == '0') { result.append("\0"); start = i; continue; }
        else if (c == '\\' || c == '"' || c == '\'') { result.append(string.fromCodeUnit(c)); start = i; continue; }
        else if (c == 'x') {
          int c0 = i + 1 < text.length ? parseHexCharacter(text.codeUnitAt(i++)) : -1;
          int c1 = i + 1 < text.length ? parseHexCharacter(text.codeUnitAt(i++)) : -1;
          if (c0 != -1 && c1 != -1) { result.append(string.fromCodeUnit(c0 << 4 | c1)); start = i; continue; }
        }
      }
      syntaxErrorInvalidEscapeSequence(log, Range(range.source, range.start + escape, range.start + i), text.slice(escape, i));
      isValidString = false;
    } else {
      i++;
    }
  }
  result.append(text.slice(start, i));
  return isValidString ? StringContent(result.toString()) : null;
}

string quoteString(string text, int quote) {
  StringBuilder result = StringBuilder();
  string quoteString = string.fromCodeUnit(quote);
  result.append(quoteString);
  int start = 0; // Append long runs of unescaped characters using a single slice() for speed
  int i;
  for (i = 0; i < text.length; i++) {
    int c = text.codeUnitAt(i);
    if (c == quote) { result.append(text.slice(start, i)).append("\\").append(quoteString); start = i + 1; }
    else if (c == '\n') { result.append(text.slice(start, i)).append("\\n"); start = i + 1; }
    else if (c == '\r') { result.append(text.slice(start, i)).append("\\r"); start = i + 1; }
    else if (c == '\t') { result.append(text.slice(start, i)).append("\\t"); start = i + 1; }
    else if (c == '\0') { result.append(text.slice(start, i)).append("\\0"); start = i + 1; }
    else if (c == '\\') { result.append(text.slice(start, i)).append("\\\\"); start = i + 1; }
    else if (c < ' ' || c >= 0x7F && c <= 0xFF) { result.append(text.slice(start, i)).append("\\x").append(HEX.get(c >> 4)).append(HEX.get(c & 15)); start = i + 1; }
  }
  result.append(text.slice(start, i)).append(quoteString);
  return result.toString();
}

// TODO: Move this into the standard library
string replace(string text, string before, string after) {
  string result = "";
  int index;
  while ((index = text.indexOf(before)) != -1) {
    result = result.append(text.slice(0, index)).append(after);
    text = text.slice(index + before.length, text.length);
  }
  return result.append(text);
}

// TODO: Move this into the standard library
string repeat(string text, int count) {
  int i;
  string result = "";
  for (i = 0; i < count; i++) {
    result = result.append(text);
  }
  return result;
}

string plural(int value, string singular, string plural) {
  return value == 1 ? singular : plural;
}

struct SplitPath {
  final string directory;
  final string entry;
}

SplitPath splitPath(string path) {
  int slashIndex = Math.imax(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  return slashIndex == -1
    ? SplitPath(".", path)
    : SplitPath(path.slice(0, slashIndex), path.slice(slashIndex + 1, path.length));
}

string joinPath(string directory, string entry) {
  return directory.append("/").append(entry);
}

string formatNumber(double number) {
  return (Math.round(number * 10) / 10).toString();
}

enum ByteSize {
  KB = 1 << 10,
  MB = 1 << 20,
  GB = 1 << 30,
}

string bytesToString(int bytes) {
  if (bytes == 1) return "1 byte";
  if (bytes < ByteSize.KB) return bytes.toString().append(" bytes");
  if (bytes < ByteSize.MB) return formatNumber(bytes / (double)ByteSize.KB).append("kb");
  if (bytes < ByteSize.GB) return formatNumber(bytes / (double)ByteSize.MB).append("mb");
  return formatNumber(bytes / (double)ByteSize.GB).append("gb");
}
