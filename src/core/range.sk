struct FormattedRange {
  final string line;
  final string range;
}

struct Range {
  static final var EMPTY = Range(null, 0, 0);

  final Source source;
  final int start;
  final int end;

  bool isEmpty() {
    return source == null;
  }

  string toString() {
    return source == null ? "" : source.contents.slice(start, end);
  }

  string locationString() {
    if (isEmpty()) return "";
    var location = source.indexToLineColumn(start);
    return source.name + ":" + (location.line + 1) + ":" + (location.column + 1);
  }

  bool touches(int index) {
    return start <= index && index <= end;
  }

  // Return the length from the start to the end of the range or the end of the
  // first line, whichever comes first
  int singleLineLength() {
    var start = source.indexToLineColumn(this.start);
    var end = source.indexToLineColumn(this.end);
    return (start.line == end.line ? end.column : source.contentsOfLine(start.line).size()) - start.column;
  }

  FormattedRange format(int maxLength) {
    assert source != null;
    var start = source.indexToLineColumn(this.start);
    var end = source.indexToLineColumn(this.end);
    var line = source.contentsOfLine(start.line);
    var length = line.size();
    var a = start.column;
    var b = end.line == start.line ? end.column : length;

    // Ensure the line length doesn't exceed maxLength
    if (maxLength > 0 && length > maxLength) {
      var centeredWidth = b - a < maxLength / 2 ? b - a : maxLength / 2;
      var centeredStart = (maxLength - centeredWidth) / 2;

      // Left aligned
      if (a < centeredStart) {
        line = line.slice(0, maxLength - 3) + "...";
        if (b > maxLength - 3) b = maxLength - 3;
      }

      // Right aligned
      else if (length - a < maxLength - centeredStart) {
        var offset = length - maxLength;
        line = "..." + line.slice(offset + 3, length);
        a -= offset;
        b -= offset;
      }

      // Center aligned
      else {
        var offset = a - centeredStart;
        line = "..." + line.slice(offset + 3, offset + maxLength - 3) + "...";
        a -= offset;
        b -= offset;
        if (b > maxLength - 3) b = maxLength - 3;
      }
    }

    return FormattedRange(line, " ".repeat(a) + (b - a < 2 ? "^" : "~".repeat(b - a)));
  }

  static Range span(Range start, Range end) {
    assert start.source == end.source;
    assert start.start <= end.end;
    return Range(start.source, start.start, end.end);
  }

  static Range inner(Range start, Range end) {
    assert start.source == end.source;
    assert start.end <= end.start;
    return Range(start.source, start.end, end.start);
  }

  static Range before(Range outer, Range inner) {
    assert outer.source == inner.source;
    assert outer.start <= inner.start;
    assert outer.end >= inner.end;
    return Range(outer.source, outer.start, inner.start);
  }

  static Range after(Range outer, Range inner) {
    assert outer.source == inner.source;
    assert outer.start <= inner.start;
    assert outer.end >= inner.end;
    return Range(outer.source, inner.end, outer.end);
  }

  static bool equal(Range left, Range right) {
    return left.source == right.source && left.start == right.start && left.end == right.end;
  }
}
