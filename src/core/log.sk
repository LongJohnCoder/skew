enum DiagnosticKind {
  ERROR,
  WARNING,
}

class Diagnostic {
  DiagnosticKind kind;
  Range range;
  string text;
  var noteRange = Range.EMPTY;
  var noteText = "";
}

class Log {
  List<Diagnostic> diagnostics = {};
  var warningCount = 0;
  var errorCount = 0;

  void error(Range range, string text) {
    assert !range.isEmpty();
    diagnostics.push(Diagnostic(.ERROR, range, text));
    errorCount++;
  }

  void warning(Range range, string text) {
    assert !range.isEmpty();
    diagnostics.push(Diagnostic(.WARNING, range, text));
    warningCount++;
  }

  void note(Range range, string text) {
    assert !range.isEmpty();
    var last = diagnostics.get(diagnostics.length - 1);
    last.noteRange = range;
    last.noteText = text;
  }

  export string toString() {
    var result = "";

    // Emit the log assuming an infinite terminal width
    for (var i = 0; i < diagnostics.length; i++) {
      var diagnostic = diagnostics.get(i);
      var formatted = diagnostic.range.format(0);
      result = result.append(diagnostic.range.locationString()).append(diagnostic.kind == .ERROR ? ": error: " : ": warning: ")
        .append(diagnostic.text).append("\n").append(formatted.line).append("\n").append(formatted.range).append("\n");

      // Append notes after the diagnostic they apply to
      if (!diagnostic.noteRange.isEmpty()) {
        formatted = diagnostic.noteRange.format(0);
        result = result.append(diagnostic.noteRange.locationString()).append(": note: ").append(diagnostic.noteText).append("\n")
          .append(formatted.line).append("\n").append(formatted.range).append("\n");
      }
    }

    return result;
  }
}
