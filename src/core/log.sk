enum DiagnosticKind {
  ERROR,
  WARNING,
}

class Diagnostic {
  DiagnosticKind kind;
  Range range;
  string text;
  Range noteRange = .EMPTY;
  var noteText = "";

  static string format(string kind, Range range, string text) {
    if (range.isEmpty()) return kind + ": " + text + "\n";
    var formatted = range.format(0);
    return range.locationString() + ": " + kind + ": " + text + "\n" + formatted.line + "\n" + formatted.range + "\n";
  }
}

export class Log {
  string toString() {
    var result = "";

    // Emit the log assuming an infinite terminal width
    for (var i = 0; i < diagnostics.size(); i++) {
      var diagnostic = diagnostics[i];
      result += Diagnostic.format(diagnostic.kind == .ERROR ? "error" : "warning", diagnostic.range, diagnostic.text);

      // Append notes after the diagnostic they apply to
      if (!diagnostic.noteRange.isEmpty()) {
        result += Diagnostic.format("note", diagnostic.noteRange, diagnostic.noteText);
      }
    }

    return result;
  }
}

in Log {
  List<Diagnostic> diagnostics = [];
  var warningCount = 0;
  var errorCount = 0;

  bool hasErrors() {
    return errorCount > 0;
  }

  bool hasWarnings() {
    return warningCount > 0;
  }

  void error(Range range, string text) {
    assert range != null; // Use Range.EMPTY instead of null
    diagnostics.push(Diagnostic(.ERROR, range, text));
    errorCount++;
  }

  void warning(Range range, string text) {
    assert range != null; // Use Range.EMPTY instead of null
    diagnostics.push(Diagnostic(.WARNING, range, text));
    warningCount++;
  }

  void note(Range range, string text) {
    assert range != null; // Use Range.EMPTY instead of null
    var last = diagnostics[diagnostics.size() - 1];
    last.noteRange = range;
    last.noteText = text;
  }
}
