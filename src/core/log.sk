enum DiagnosticKind {
  ERROR,
  WARNING,
}

class Diagnostic {
  DiagnosticKind kind;
  Range range;
  string text;
  var noteRange = Range.EMPTY;
  var noteText = "";
}

export class Log {
  List<Diagnostic> diagnostics = [];
  var warningCount = 0;
  var errorCount = 0;

  void error(Range range, string text) {
    assert !range.isEmpty();
    diagnostics.push(Diagnostic(.ERROR, range, text));
    errorCount++;
  }

  void warning(Range range, string text) {
    assert !range.isEmpty();
    diagnostics.push(Diagnostic(.WARNING, range, text));
    warningCount++;
  }

  void note(Range range, string text) {
    assert !range.isEmpty();
    var last = diagnostics.get(diagnostics.length - 1);
    last.noteRange = range;
    last.noteText = text;
  }

  export string toString() {
    var result = "";

    // Emit the log assuming an infinite terminal width
    for (var i = 0; i < diagnostics.length; i++) {
      var diagnostic = diagnostics.get(i);
      var formatted = diagnostic.range.format(0);
      result = result + diagnostic.range.locationString() + (diagnostic.kind == .ERROR ? ": error: " : ": warning: ")
         + diagnostic.text + "\n" + formatted.line + "\n" + formatted.range + "\n";

      // Append notes after the diagnostic they apply to
      if (!diagnostic.noteRange.isEmpty()) {
        formatted = diagnostic.noteRange.format(0);
        result = result + diagnostic.noteRange.locationString() + ": note: " + diagnostic.noteText + "\n"
           + formatted.line + "\n" + formatted.range + "\n";
      }
    }

    return result;
  }
}
