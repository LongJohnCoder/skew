enum SortTypes {
  DO_NOT_SORT,
  SORT_BY_INHERITANCE,
  SORT_BY_INHERITANCE_AND_VALUE,
  SORT_BY_INHERITANCE_AND_CONTAINMENT,
}

class Collector {
  SortTypes sort;
  List<Symbol> typeSymbols = [];
  List<Symbol> freeFunctionSymbols = [];
  List<Node> freeVariableSymbols = [];

  new(Node program, SortTypes sort) : sort = sort {
    assert program.kind == .PROGRAM;
    collectStatements(program);
    sortTypeSymbols();
  }

  void collectStatements(Node node) {
    switch (node.kind) {
      case .PROGRAM, .FILE, .MODIFIER, .BLOCK {
        collectChildStatements(node);
      }

      case .NAMESPACE, .CLASS, .STRUCT, .INTERFACE, .EXTENSION, .ENUM, .ENUM_FLAGS {
        if (node == node.symbol.node) {
          typeSymbols.push(node.symbol);
        }
        collectChildStatements(node);
      }

      case .CONSTRUCTOR, .FUNCTION {
        if (!node.symbol.enclosingSymbol.kind.isTypeWithInstances()) {
          freeFunctionSymbols.push(node.symbol);
        }
      }

      case .VARIABLE_CLUSTER {
        freeVariableSymbols.push(node);
      }
    }
  }

  void sortTypeSymbols() {
    if (sort == .DO_NOT_SORT) {
      return;
    }

    for (var i = 0; i < typeSymbols.length; i++) {
      var j = i;

      // Select a type that comes before all other types
      for (; j < typeSymbols.length; j++) {
        var type = typeSymbols.get(j).type;
        var k = i;

        // Check to see if this comes before all other types
        for (; k < typeSymbols.length; k++) {
          if (j == k) {
            continue;
          }
          var other = typeSymbols.get(k);
          if (typeComesBefore(typeSymbols.get(k).type, type)) {
            break;
          }
        }
        if (k == typeSymbols.length) {
          break;
        }
      }

      // Swap the type into the correct order
      if (j < typeSymbols.length) {
        typeSymbols.swap(i, j);
      }
    }
  }

  bool hasMemberOfType(Type typeWithMembers, Type typeOfMember) {
    var members = typeWithMembers.members.values();
    if (members != null) {
      for (var i = 0; i < members.length; i++) {
        if (members.get(i).type == typeOfMember) {
          return true;
        }
      }
    }
    return false;
  }

  bool isContainedBy(Symbol inner, Symbol outer) {
    if (inner.enclosingSymbol == null) return false;
    if (inner.enclosingSymbol == outer) return true;
    return isContainedBy(inner.enclosingSymbol, outer);
  }

  bool typeComesBefore(Type before, Type after) {
    if (after.hasBaseType(before)) return true;
    if (sort == .SORT_BY_INHERITANCE_AND_VALUE && before.isStruct() && hasMemberOfType(after, before)) return true;
    if (sort == .SORT_BY_INHERITANCE_AND_CONTAINMENT && isContainedBy(after.symbol, before.symbol)) return true;
    return false;
  }

  void collectChildStatements(Node node) {
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null) {
          collectStatements(child);
        }
      }
    }
  }
}
