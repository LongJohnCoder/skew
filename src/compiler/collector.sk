enum SortTypes {
  DO_NOT_SORT,
  SORT_BY_INHERITANCE,
  SORT_BY_INHERITANCE_AND_VALUE,
  SORT_BY_INHERITANCE_AND_CONTAINMENT,
}

class Collector {
  SortTypes sort;
  List<Symbol> typeSymbols = [];
  List<Symbol> freeFunctionSymbols = [];
  List<Node> freeVariableSymbols = [];

  new(Node program, SortTypes sort) : sort = sort {
    assert program.kind == .PROGRAM;
    collectStatements(program);
    sortTypeSymbols();
  }

  void collectStatements(Node node) {
    switch (node.kind) {
      case .PROGRAM, .FILE, .MODIFIER, .BLOCK {
        collectChildStatements(node);
      }

      case .NAMESPACE, .CLASS, .STRUCT, .INTERFACE, .EXTENSION, .ENUM, .ENUM_FLAGS {
        if (node == node.symbol.node) {
          typeSymbols.push(node.symbol);
        }
        collectChildStatements(node);
      }

      case .CONSTRUCTOR, .FUNCTION {
        if (!node.symbol.enclosingSymbol.kind.isTypeWithInstances()) {
          freeFunctionSymbols.push(node.symbol);
        }
      }

      case .VARIABLE_CLUSTER {
        freeVariableSymbols.push(node);
      }
    }
  }

  void sortTypeSymbols() {
    if (sort == .DO_NOT_SORT) {
      return;
    }

    for (var i = 1; i < typeSymbols.length; i++) {
      var symbol = typeSymbols.get(i);
      for (var j = 0; j < i; j++) {
        if (typeComesBefore(symbol.type, typeSymbols.get(j).type)) {
          var k = i;
          for (; k > j; k--) {
            typeSymbols.set(k, typeSymbols.get(k - 1));
          }
          typeSymbols.set(j, symbol);
          break;
        }
      }
    }
  }

  bool typeComesBefore(Type left, Type right) {
    if (right.hasBaseType(left)) {
      return true;
    }

    if (sort == .SORT_BY_INHERITANCE_AND_VALUE && left.isStruct()) {
      var members = right.members.values();
      if (members != null) {
        for (var i = 0; i < members.length; i++) {
          if (members.get(i).type == left) {
            return true;
          }
        }
      }
    }

    if (sort == .SORT_BY_INHERITANCE_AND_CONTAINMENT && right.symbol.isContainedBy(left.symbol)) {
      return true;
    }

    return false;
  }

  void collectChildStatements(Node node) {
    if (node.hasChildren()) {
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children.get(i);
        if (child != null) {
          collectStatements(child);
        }
      }
    }
  }
}
