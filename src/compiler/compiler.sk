interface IEmitter {
  virtual List<Source> emitProgram(Node program);
}

export enum TargetFormat {
  // Target languages that run the resolver
  NONE,
  CPP,
  JAVASCRIPT,

  // AST-only targets
  LISP_AST,
  JSON_AST,
  XML_AST,
}

in TargetFormat {
  bool shouldRunResolver() {
    return this >= NONE && this <= JAVASCRIPT;
  }
}

export class OverriddenDefine {
  bool value;
  Range range;
}

export interface FileAccess {
  virtual Source contentsOfFile(string sourcePath, string relativePath);
}

export enum CompilerConfig {
  AUTOMATIC,
  ANDROID,
  BROWSER,
  IOS,
  LINUX,
  NODE,
  OSX,
  WINDOWS,
}

export class CompilerOptions {
  FileAccess fileAccess = null;
  TargetFormat targetFormat = .NONE;
  CompilerConfig targetConfig = .AUTOMATIC;
  List<Source> inputs = [];
  var overriddenDefines = StringMap<OverriddenDefine>();
  var outputDirectory = "";
  var outputFile = "";
  var verbose = false;
  var minify = false; // Removes whitespace
  var mangle = false; // Changes the code structure to save space
  var sourceMap = false;
  var removeAsserts = false;
  var foldAllConstants = false;
  var inlineAllFunctions = false;
  var globalizeAllFunctions = false;

  void overrideDefine(string name, bool value) {
    overriddenDefines[name] = OverriddenDefine(value, .EMPTY);
  }
}

export class CompilerResult {
  CompilerOptions options;
  List<Source> outputs;
  List<Node> files;
  Node program;
  Resolver resolver;
}

// This caches the parse tree for a bundled source file to speed up recompilation
class CachedSource {
  string name;
  string contents;
  Source source = null;
  Node file = null;

  Node compile(Compiler compiler, CompilerOptions options) {
    if (source == null) {
      source = Source(joinPath("<compiler>", name), contents);
      file = compiler.tokenizeAndParseFile(source);
    }
    return file != null ? file.clone() : null;
  }
}

export class Compiler {
  var tokenizingTime = 0.0;
  var parsingTime = 0.0;
  var resolvingTime = 0.0;
  var callGraphTime = 0.0;
  var globalizeTime = 0.0;
  var symbolMotionTime = 0.0;
  var functionInliningTime = 0.0;
  var constantFoldingTime = 0.0;
  var treeShakingTime = 0.0;
  var emitTime = 0.0;
  var lineCountingTime = 0.0;
  var totalTime = 0.0;
  var log = Log();

  string statistics(CompilerResult result) {
    // Line count
    var lineCountingStart = now();
    var lineCount = 0;
    lineCount += totalLineCount(result.options.inputs);
    var text =
      "Input line count: " + lineCount +
      "\nOutput line count: " + totalLineCount(result.outputs);
    lineCountingTime += now() - lineCountingStart;

    // Compilation time
    var optimizingTime = callGraphTime + globalizeTime + symbolMotionTime + functionInliningTime + constantFoldingTime + treeShakingTime;
    text += "\nTotal compile time: " + formatNumber(totalTime + lineCountingTime) + "ms";
    if (tokenizingTime > 0) text += "\n  Tokenizing: " + formatNumber(tokenizingTime) + "ms";
    if (parsingTime > 0) text += "\n  Parsing: " + formatNumber(parsingTime) + "ms";
    if (resolvingTime > 0) text += "\n  Resolving: " + formatNumber(resolvingTime) + "ms";
    if (optimizingTime > 0) {
      text += "\n  Optimizing: " + formatNumber(optimizingTime) + "ms";
      text += "\n    Building call graph: " + formatNumber(callGraphTime) + "ms";
      text += "\n    Globalize: " + formatNumber(globalizeTime) + "ms";
      text += "\n    Symbol motion: " + formatNumber(symbolMotionTime) + "ms";
      text += "\n    Function inlining: " + formatNumber(functionInliningTime) + "ms";
      text += "\n    Constant folding: " + formatNumber(constantFoldingTime) + "ms";
      text += "\n    Tree shaking: " + formatNumber(treeShakingTime) + "ms";
    }
    if (emitTime > 0) text += "\n  Emit: " + formatNumber(emitTime) + "ms";
    if (lineCountingTime > 0) text += "\n  Counting lines: " + formatNumber(lineCountingTime) + "ms";

    // Sources
    text += sourceStatistics("Inputs", result.options.inputs);
    text += sourceStatistics("Outputs", result.outputs);
    return text;
  }

  CompilerResult compile(CompilerOptions options) {
    var totalStart = now();
    var targetFormat = options.targetFormat;
    var targetConfig = options.targetConfig;
    var program = Node.createProgram([]);
    List<Source> outputs = [];
    List<Node> files = [];

    // Initialize global state
    createOperatorMap();
    createParser();
    createNameToSymbolFlag();
    createSymbolFlagToName();

    // Automatically set the current configuration if it's not explicitly set
    if (targetConfig == .AUTOMATIC) {
      if (targetFormat == .JAVASCRIPT) {
        targetConfig = .BROWSER;
      } else if (targetFormat == .CPP) {
        var os = OperatingSystem.current();
        targetConfig =
          os == .ANDROID ? .ANDROID :
          os == .IOS ? .IOS :
          os == .LINUX ? .LINUX :
          os == .OSX ? .OSX :
          os == .WINDOWS ? .WINDOWS :
          .AUTOMATIC;
      }
      options.targetConfig = targetConfig;
    }

    // Prepare native #define overrides
    options.overrideDefine("TARGET_JS", targetFormat == .JAVASCRIPT);
    options.overrideDefine("TARGET_CPP", targetFormat == .CPP);
    options.overrideDefine("CONFIG_ANDROID", targetConfig == .ANDROID);
    options.overrideDefine("CONFIG_BROWSER", targetConfig == .BROWSER);
    options.overrideDefine("CONFIG_IOS", targetConfig == .IOS);
    options.overrideDefine("CONFIG_LINUX", targetConfig == .LINUX);
    options.overrideDefine("CONFIG_NODE", targetConfig == .NODE);
    options.overrideDefine("CONFIG_OSX", targetConfig == .OSX);
    options.overrideDefine("CONFIG_WINDOWS", targetConfig == .WINDOWS);

    // Tokenize and parse each module individually
    for (var i = 0; i < cachedLibraries.size(); i++) {
      var file = cachedLibraries[i].compile(this, options);
      if (file != null) {
        program.appendChild(file);
        files.push(file);
      }
    }
    for (var i = 0; i < options.inputs.size(); i++) {
      var file = tokenizeAndParseFile(options.inputs[i]);
      if (file != null) {
        program.appendChild(file);
        files.push(file);
      }
    }

    // Resolve everything together
    Resolver resolver = null;
    if (options.targetFormat.shouldRunResolver()) {
      var resolveStart = now();
      resolver = Resolver(log, options);
      resolver.run(program);
      resolvingTime += now() - resolveStart;
    }
    if (log.errorCount == 0) {

      // Optimize the module if the target format requires it
      if (options.targetFormat.shouldRunResolver()) {
        // Build a call graph
        var callGraphStart = now();
        var graph = CallGraph(program);
        callGraphTime += now() - callGraphStart;

        // Convert instance functions to static functions
        var globalizeStart = now();
        GlobalizePass.run(graph, resolver);
        globalizeTime += now() - globalizeStart;

        // Move functions
        var symbolMotionStart = now();
        SymbolMotionPass.run(resolver);
        symbolMotionTime += now() - symbolMotionStart;

        // Inline functions
        var functionInliningStart = now();
        FunctionInliningPass.run(graph, options);
        functionInliningTime += now() - functionInliningStart;

        // Fold constants
        if (options.foldAllConstants) {
          var constantFoldingStart = now();
          resolver.constantFolder.foldConstants(program);
          constantFoldingTime += now() - constantFoldingStart;
        }

        // Tree shaking
        var treeShakingStart = now();
        TreeShakingPass.run(program, options, resolver);
        treeShakingTime += now() - treeShakingStart;
      }

      // Emit the module in the target format
      IEmitter emitter = null;
      switch (options.targetFormat) {
        case .NONE {}
        case .CPP { emitter = cpp.Emitter(resolver); }
        case .JAVASCRIPT { emitter = js.Emitter(resolver); }
        case .LISP_AST { emitter = lisp.Emitter(options); }
        case .JSON_AST { emitter = json.Emitter(options); }
        case .XML_AST { emitter = xml.Emitter(options); }
        default { assert false; }
      }
      if (emitter != null) {
        var emitStart = now();
        outputs = emitter.emitProgram(program);
        emitTime += now() - emitStart;
      }
    }

    totalTime += now() - totalStart;
    return CompilerResult(options, outputs, files, program, resolver);
  }
}

in Compiler {
  // Cache the parsed standard libraries for a speed boost during recompilation
  static List<CachedSource> cachedLibraries = [
    CachedSource("defines.sk", @ContentsOfFile("../../lib/defines.sk")),
    CachedSource("primitives.sk", @ContentsOfFile("../../lib/primitives.sk")),
    CachedSource("math.sk", @ContentsOfFile("../../lib/math.sk")),
    CachedSource("list.sk", @ContentsOfFile("../../lib/list.sk")),
    CachedSource("stringmap.sk", @ContentsOfFile("../../lib/stringmap.sk")),
    CachedSource("intmap.sk", @ContentsOfFile("../../lib/intmap.sk")),
    CachedSource("os.sk", @ContentsOfFile("../../lib/os.sk")),
    CachedSource("terminal.sk", @ContentsOfFile("../../lib/terminal.sk")),
  ];

  static int totalLineCount(List<Source> sources) {
    var lineCount = 0;
    for (var i = 0; i < sources.size(); i++) {
      lineCount += sources[i].lineCount();
    }
    return lineCount;
  }

  static string sourceStatistics(string name, List<Source> sources) {
    var total = 0;
    for (var i = 0; i < sources.size(); i++) {
      total += sources[i].contents.size();
    }
    var text = "\n" + name + ": " + sources.size() + " (" + bytesToString(total) + " total)";
    for (var i = 0; i < sources.size(); i++) {
      var source = sources[i];
      text += "\n  " + source.name + ": " + bytesToString(source.contents.size());
    }
    return text;
  }

  Node tokenizeAndParseFile(Source source) {
    var errorCount = log.errorCount;

    // Tokenize the source
    var tokenizeStart = now();
    var tokens = tokenize(log, source);
    if (log.errorCount == errorCount) {
      prepareTokens(tokens);
    }
    tokenizingTime += now() - tokenizeStart;

    // Parse the source if the tokenize was successful
    if (log.errorCount == errorCount) {
      var parseStart = now();
      var file = parseFile(log, tokens);
      parsingTime += now() - parseStart;
      if (file != null) {
        return file;
      }
    }

    return null;
  }
}
