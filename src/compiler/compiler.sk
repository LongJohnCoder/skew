interface IEmitter {
  virtual List<Source> emitProgram(Node program);
}

export enum TargetFormat {
  // Target languages that run the resolver
  NONE,
  JS,

  // AST-only targets
  LISP_AST,
  JSON_AST,
  XML_AST,
}

export in TargetFormat {
  bool shouldRunResolver() {
    return this >= NONE && this <= JS;
  }
}

class CompilerOptions {
  TargetFormat targetFormat = .NONE;
  List<Source> inputs = {};
  List<Source> prepend = {};
  List<Source> append = {};
  var outputDirectory = "";
  var outputFile = "";
  var jsSourceMap = false;
  var optimize = false;
  var removeAsserts = false;
}

class CompilerResult {
  CompilerOptions options;
  List<Source> outputs;
  Node program;
  Resolver resolver;
}

export class Compiler {
  static Source nativeLibrarySource = null;
  static Node nativeLibraryFile = null;

  var tokenizingTime = 0.0;
  var parsingTime = 0.0;
  var resolvingTime = 0.0;
  var callGraphTime = 0.0;
  var instanceToStaticTime = 0.0;
  var functionInliningTime = 0.0;
  var constantFoldingTime = 0.0;
  var emitTime = 0.0;
  var lineCountingTime = 0.0;
  var totalTime = 0.0;
  var log = Log();

  string statistics(CompilerResult result) {
    // Line count
    var lineCountingStart = now();
    var lineCount = 0;
    lineCount += totalLineCount(result.options.prepend);
    lineCount += totalLineCount(result.options.inputs);
    lineCount += totalLineCount(result.options.append);
    var text =
      "Input line count: ".append(lineCount.toString()).append(
      "\nOutput line count: ").append(totalLineCount(result.outputs).toString());
    lineCountingTime += now() - lineCountingStart;

    // Compilation time
    var optimizingTime = callGraphTime + instanceToStaticTime + functionInliningTime + constantFoldingTime;
    text = text.append("\nTotal compile time: ").append(formatNumber(totalTime + lineCountingTime)).append("ms");
    if (tokenizingTime > 0) text = text.append("\n  Tokenizing: ").append(formatNumber(tokenizingTime)).append("ms");
    if (parsingTime > 0) text = text.append("\n  Parsing: ").append(formatNumber(parsingTime)).append("ms");
    if (resolvingTime > 0) text = text.append("\n  Resolving: ").append(formatNumber(resolvingTime)).append("ms");
    if (optimizingTime > 0) {
      text = text.append("\n  Optimizing: ").append(formatNumber(optimizingTime)).append("ms");
      text = text.append("\n    Building call graph: ").append(formatNumber(callGraphTime)).append("ms");
      text = text.append("\n    Instance to static: ").append(formatNumber(instanceToStaticTime)).append("ms");
      text = text.append("\n    Function inlining: ").append(formatNumber(functionInliningTime)).append("ms");
      text = text.append("\n    Constant folding: ").append(formatNumber(constantFoldingTime)).append("ms");
    }
    if (emitTime > 0) text = text.append("\n  Emit: ").append(formatNumber(emitTime)).append("ms");
    if (lineCountingTime > 0) text = text.append("\n  Counting lines: ").append(formatNumber(lineCountingTime)).append("ms");

    // Sources
    text = text.append(sourceStatistics("Prepend", result.options.prepend));
    text = text.append(sourceStatistics("Inputs", result.options.inputs));
    text = text.append(sourceStatistics("Append", result.options.append));
    text = text.append(sourceStatistics("Outputs", result.outputs));
    return text;
  }

  static int totalLineCount(List<Source> sources) {
    var lineCount = 0;
    for (var i = 0; i < sources.length; i++) {
      lineCount += sources.get(i).lineCount();
    }
    return lineCount;
  }

  static string sourceStatistics(string name, List<Source> sources) {
    var text = "\n".append(name).append(": ").append(sources.length.toString());
    for (var i = 0; i < sources.length; i++) {
      var source = sources.get(i);
      text = text.append("\n  ").append(source.name).append(": ").append(bytesToString(source.contents.length));
    }
    return text;
  }

  export CompilerResult compile(CompilerOptions options) {
    var totalStart = now();
    var program = Node.createProgram({});
    List<Source> outputs = {};

    // Cache the standard library for a small speed increase
    if (nativeLibrarySource != null) {
      program.appendChild(nativeLibraryFile.clone());
    } else {
      nativeLibrarySource = Source("<native>", NATIVE_LIBRARY);
      processInput(program, nativeLibrarySource);
      nativeLibraryFile = program.children.get(0).clone();
    }
    options.inputs.unshift(nativeLibrarySource);

    // Tokenize and parse each module individually
    for (var i = 1; i < options.inputs.length; i++) {
      processInput(program, options.inputs.get(i));
    }

    // Resolve everything together
    Resolver resolver = null;
    if (options.targetFormat.shouldRunResolver()) {
      var resolveStart = now();
      resolver = Resolver(log);
      resolver.run(program);
      resolvingTime += now() - resolveStart;
    }
    if (log.errorCount == 0) {

      // Create an emitter if there's a target language
      IEmitter emitter = null;
      switch (options.targetFormat) {
        case .NONE {}
        case .JS { emitter = js.Emitter(options, resolver.cache); }
        case .LISP_AST { emitter = lisp.Emitter(options); }
        case .JSON_AST { emitter = json.Emitter(options); }
        case .XML_AST { emitter = xml.Emitter(options); }
        default { assert false; }
      }

      // Optimize and emit the module in the target language if present
      if (emitter != null) {
        if (options.targetFormat.shouldRunResolver()) {

          // Build call graph
          var callGraphStart = now();
          var graph = CallGraph(program);
          callGraphTime += now() - callGraphStart;

          // Convert instance functions to static functions
          var instanceToStaticStart = now();
          InstanceToStaticPass.run(graph, options);
          instanceToStaticTime += now() - instanceToStaticStart;

          // Inline functions
          var functionInliningStart = now();
          FunctionInliningPass.run(graph, options);
          functionInliningTime += now() - functionInliningStart;

          // Fold constants
          if (options.optimize) {
            var constantFoldingStart = now();
            resolver.constantFolder.foldConstants(program);
            constantFoldingTime += now() - constantFoldingStart;
          }
        }

        // Emit
        var emitStart = now();
        outputs = emitter.emitProgram(program);
        emitTime += now() - emitStart;
      }
    }

    totalTime += now() - totalStart;
    return CompilerResult(options, outputs, program, resolver);
  }

  void processInput(Node program, Source source) {
    var errorCount = log.errorCount;

    // Tokenize the source
    var tokenizeStart = now();
    var sourceTokens = tokenize(log, source);
    tokenizingTime += now() - tokenizeStart;

    // Parse the source if the tokenize was successful
    if (log.errorCount == errorCount) {
      var parseStart = now();
      var file = parseFile(log, sourceTokens);
      parsingTime += now() - parseStart;
      if (file != null) {
        program.appendChild(file);
      }
    }
  }
}
