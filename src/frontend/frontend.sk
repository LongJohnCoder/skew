class FrontendFileAccess : FileAccess {
  override Source contentsOfFile(string sourcePath, string relativePath) {
    var path = joinPath(splitPath(sourcePath).directory, relativePath);
    var contents = io.readFile(path);
    return contents != null ? Source(path, contents.value) : null;
  }
}

enum Option {
  APPEND_FILE,
  CONFIG,
  DEFINE,
  FOLD_CONSTANTS,
  GLOBALIZE,
  HELP,
  INLINE,
  MANGLE,
  MINIFY,
  OUTPUT_DIRECTORY,
  OUTPUT_FILE,
  PREPEND_FILE,
  RELEASE,
  REMOVE_ASSERTS,
  SOURCE_MAP,
  TARGET,
  VERBOSE,
}

namespace frontend {
  @EntryPoint
  int main(List<string> arguments) {
    // Translate frontend flags to compiler options
    var log = Log();
    var parser = OptionParser();
    var options = parseOptions(log, parser, arguments);

    // Run the compilation
    if (!log.hasErrors() && options != null) {
      var compiler = Compiler();
      compiler.log = log;
      var result = compiler.compile(options);

      // Write all outputs
      if (!log.hasErrors()) {
        for (var i = 0; i < result.outputs.size(); i++) {
          var output = result.outputs[i];
          if (!io.writeFile(output.name, output.contents)) {
            commandLineErrorUnwritableFile(log, parser.source.rangeContainingEverything(), output.name);
            break;
          }
        }

        // Print compilation statistics
        if (!log.hasErrors() && options.verbose) {
          terminal.print(compiler.statistics(result));
        }
      }
    }

    // Print any errors and warnings
    printLogWithColor(log);
    return log.hasErrors() ? 1 : 0;
  }

  CompilerOptions parseOptions(Log log, OptionParser parser, List<string> arguments) {
    // Configure the parser
    parser.define(.BOOL, .HELP, "--help", "Prints this message.").aliases(["-help", "?", "-?", "-h", "-H", "/?", "/h", "/H"]);
    parser.define(.STRING, .TARGET, "--target", "Sets the target format. Valid targets are " + prettyPrint.join(simpleQuoteAll(VALID_TARGETS), "and") + ".");
    parser.define(.STRING, .OUTPUT_FILE, "--output-file", "Combines all output into a single file. Mutually exclusive with --output-dir.");
    parser.define(.STRING, .OUTPUT_DIRECTORY, "--output-dir", "Places all output files in the specified directory. Mutually exclusive with --output-file.");
    parser.define(.STRING_LIST, .DEFINE, "--define", "Overrides the value of a #define statement. Example: --define:UNIT_TESTS=true.");
    parser.define(.BOOL, .RELEASE, "--release", "Implies --inline, --globalize, --remove-asserts, --fold-constants, --minify, --mangle, and --define:BUILD_RELEASE.");
    parser.define(.STRING, .CONFIG, "--config", "Provides the configuration for the target format. Valid configurations are " + prettyPrint.join(simpleQuoteAll(VALID_JS_CONFIGS), "and") + " for JavaScript and " + prettyPrint.join(simpleQuoteAll(VALID_CPP_CONFIGS), "and") + " for C++. The default configuration is \"browser\" for JavaScript and the current operating system for C++.");
    parser.define(.BOOL, .VERBOSE, "--verbose", "Prints out information about the compilation.");
    parser.define(.BOOL, .SOURCE_MAP, "--source-map", "Generates a source map when targeting JavaScript. The source map is saved with the \".map\" extension in the same directory as the main output file.");
    parser.define(.BOOL, .INLINE, "--inline", "Uses heuristics to automatically inline simple functions.");
    parser.define(.BOOL, .GLOBALIZE, "--globalize", "Changes all internal non-virtual instance methods to static methods. This provides more inlining opportunities at compile time and avoids property access overhead at runtime.");
    parser.define(.BOOL, .REMOVE_ASSERTS, "--remove-asserts", "Removes all assert statements prior to compilation.");
    parser.define(.BOOL, .FOLD_CONSTANTS, "--fold-constants", "Evaluates constants at compile time and removes dead code inside functions.");
    parser.define(.BOOL, .MINIFY, "--minify", "Omits whitespace so the emitted JavaScript takes up less space.");
    parser.define(.BOOL, .MANGLE, "--mangle", "Transforms your JavaScript code to be as small as possible. The \"export\" modifier prevents renaming a symbol.");
    parser.define(.STRING_LIST, .APPEND_FILE, "--append-file", "Append the contents of this file to the output. Provide this flag multiple times to append multiple files.");
    parser.define(.STRING_LIST, .PREPEND_FILE, "--prepend-file", "Prepend the contents of this file to the output. Provide this flag multiple times to prepend multiple files.");

    // Parse the command line arguments
    parser.parse(log, arguments);
    if (log.hasErrors()) {
      return null;
    }

    // Early-out when printing the usage text
    if (parser.boolForOption(.HELP, arguments.size() == 0)) {
      printUsage(parser);
      return null;
    }

    // Set up the options for the compiler
    var options = CompilerOptions();
    var releaseFlag = parser.boolForOption(.RELEASE, false);
    options.fileAccess = FrontendFileAccess();
    options.verbose = parser.boolForOption(.VERBOSE, false);
    options.sourceMap = parser.boolForOption(.SOURCE_MAP, false);
    options.minify = parser.boolForOption(.MINIFY, releaseFlag);
    options.mangle = parser.boolForOption(.MANGLE, releaseFlag);
    options.removeAsserts = parser.boolForOption(.REMOVE_ASSERTS, releaseFlag);
    options.foldAllConstants = parser.boolForOption(.FOLD_CONSTANTS, releaseFlag);
    options.inlineAllFunctions = parser.boolForOption(.INLINE, releaseFlag);
    options.globalizeAllFunctions = parser.boolForOption(.GLOBALIZE, releaseFlag);

    // Prepare the defines
    if (releaseFlag) {
      options.overrideDefine("BUILD_RELEASE", true);
    }
    var defines = parser.stringRangeListForOption(.DEFINE);
    if (defines != null) {
      for (var i = 0; i < defines.size(); i++) {
        var range = defines[i];
        var text = range.toString();
        var equals = text.indexOf("=");
        var value = true;
        var name = text;
        if (equals >= 0) {
          name = text.slice(0, equals);
          var boolean = text.slice(equals + 1, text.size());
          if (boolean != "true" && boolean != "false") {
            commandLineErrorNonBooleanValue(log, range.fromEnd(boolean.size()), boolean, text);
            continue;
          }
          value = boolean == "true";
          range = range.fromStart(name.size());
        }
        options.overriddenDefines[name] = OverriddenDefine(value, range);
      }
    }

    // There must be at least one source file
    var everything = parser.source.rangeContainingEverything();
    if (parser.normalArguments.size() == 0) {
      commandLineErrorNoInputFiles(log, everything);
    }

    // Check the format
    TargetFormat targetFormat = .NONE;
    var target = parser.stringRangeForOption(.TARGET);
    if (target == null) {
      commandLineErrorMissingTarget(log, everything, "--target");
    } else {
      var name = target.toString();
      if (name == "js") targetFormat = .JAVASCRIPT;
      else if (name == "cpp") targetFormat = .CPP;
      else if (name == "lisp-ast") targetFormat = .LISP_AST;
      else if (name == "json-ast") targetFormat = .JSON_AST;
      else if (name == "xml-ast") targetFormat = .XML_AST;
      else commandLineErrorInvalidTarget(log, target, name, VALID_TARGETS);
    }
    options.targetFormat = targetFormat;

    // Parse the output location
    var outputFile = parser.stringRangeForOption(.OUTPUT_FILE);
    var outputDirectory = parser.stringRangeForOption(.OUTPUT_DIRECTORY);
    if (outputFile == null && outputDirectory == null) {
      commandLineErrorMissingOutput(log, everything, "--output-file", "--output-dir");
    } else if (outputFile != null && outputDirectory != null) {
      commandLineErrorDuplicateOutput(log, outputFile.start > outputDirectory.start ? outputFile : outputDirectory, "--output-file", "--output-dir");
    } else if (outputFile != null) {
      options.outputFile = outputFile.toString();
    } else {
      options.outputDirectory = outputDirectory.toString();
    }

    // Check the configuration
    if (targetFormat != .NONE) {
      var config = parser.stringRangeForOption(.CONFIG);
      if (config != null) {
        CompilerConfig targetConfig = .AUTOMATIC;
        var name = config.toString();
        if (targetFormat == .JAVASCRIPT) {
          if (name == "browser") targetConfig = .BROWSER;
          else if (name == "node") targetConfig = .NODE;
          else commandLineErrorInvalidConfiguration(log, config, name, VALID_JS_CONFIGS);
        } else if (targetFormat == .CPP) {
          if (name == "android") targetConfig = .ANDROID;
          else if (name == "ios") targetConfig = .IOS;
          else if (name == "linux") targetConfig = .LINUX;
          else if (name == "osx") targetConfig = .OSX;
          else if (name == "windows") targetConfig = .WINDOWS;
          else commandLineErrorInvalidConfiguration(log, config, name, VALID_CPP_CONFIGS);
        } else {
          commandLineErrorUnexpectedConfiguration(log, config, name, target.toString());
        }
        options.targetConfig = targetConfig;
      }
    }

    // Read the source files
    options.inputs = readSources(log, parser.normalArguments);
    options.append = readSources(log, parser.stringRangeListForOption(.APPEND_FILE));
    options.prepend = readSources(log, parser.stringRangeListForOption(.PREPEND_FILE));
    return options;
  }

  List<Source> readSources(Log log, List<Range> files) {
    List<Source> result = [];
    var error = false;
    for (var i = 0; i < files.size(); i++) {
      var file = files[i];
      var path = file.toString();
      var contents = io.readFile(path);
      if (contents == null) {
        commandLineErrorUnreadableFile(log, file, path);
      } else {
        result.push(Source(path, contents.value));
      }
    }
    return error ? null : result;
  }

  void printWithColor(terminal.Color color, string text) {
    terminal.setColor(color);
    terminal.write(text);
    terminal.setColor(.DEFAULT);
  }

  void printError(string text) {
    printWithColor(.RED, "error: ");
    printWithColor(.BOLD, text + "\n");
  }

  void printNote(string text) {
    printWithColor(.GRAY, "note: ");
    printWithColor(.BOLD, text + "\n");
  }

  void printWarning(string text) {
    printWithColor(.MAGENTA, "warning: ");
    printWithColor(.BOLD, text + "\n");
  }

  void printUsage(OptionParser parser) {
    printWithColor(.GREEN, "\nusage: ");
    printWithColor(.BOLD, "skewc [flags] [inputs]\n");
    terminal.write(parser.usageText(80 - terminalWidthPadding()));
  }

  void printLogWithColor(Log log) {
    var terminalWidth = terminal.width() - terminalWidthPadding();
    for (var i = 0; i < log.diagnostics.size(); i++) {
      var diagnostic = log.diagnostics[i];
      if (!diagnostic.range.isEmpty()) {
        printWithColor(.BOLD, diagnostic.range.locationString() + ": ");
      }
      switch (diagnostic.kind) {
        case .WARNING { printWarning(diagnostic.text); }
        case .ERROR { printError(diagnostic.text); }
      }
      if (!diagnostic.range.isEmpty()) {
        var formatted = diagnostic.range.format(terminalWidth);
        terminal.print(formatted.line);
        printWithColor(.GREEN, formatted.range + "\n");
      }
      if (!diagnostic.noteRange.isEmpty()) {
        printWithColor(.BOLD, diagnostic.noteRange.locationString() + ": ");
        printNote(diagnostic.noteText);
        var formatted = diagnostic.noteRange.format(terminalWidth);
        terminal.print(formatted.line);
        printWithColor(.GREEN, formatted.range + "\n");
      }
    }

    // Print the summary
    var hasErrors = log.hasErrors();
    var hasWarnings = log.hasWarnings();
    var summary = "";
    if (hasWarnings) {
      summary += log.warningCount + prettyPrint.plural(log.warningCount, " warning", " warnings");
      if (hasErrors) summary += " and ";
    }
    if (hasErrors) {
      summary += log.errorCount + prettyPrint.plural(log.errorCount, " error", " errors");
    }
    if (hasWarnings || hasErrors) {
      terminal.print(summary + " generated");
    }
  }

  // The windows command prompt inserts an extra line break if text is present
  // in the last column of a row, so don't put any text there just to be safe
  int terminalWidthPadding() {
    return OperatingSystem.current() == .WINDOWS ? 1 : 0;
  }

  final var VALID_TARGETS = [
    "js",
    "cpp",
    "lisp-ast",
    "json-ast",
    "xml-ast",
  ];

  final var VALID_JS_CONFIGS = [
    "browser",
    "node",
  ];

  final var VALID_CPP_CONFIGS = [
    "android",
    "ios",
    "linux",
    "osx",
    "windows",
  ];
}
