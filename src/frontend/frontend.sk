import namespace io {
  int terminalWidth;
  void setColor(int color);
  void print(string text);
  bool writeFile(string path, string contents);
  Source readFile(string path);
}

class FrontendFileAccess : FileAccess {
  override Source contentsOfFile(string sourcePath, string relativePath) {
    return io.readFile(joinPath(splitPath(sourcePath).directory, relativePath));
  }
}

enum Option {
  APPEND_FILE,
  CONFIG,
  DEFINE,
  FOLD_CONSTANTS,
  GLOBALIZE,
  HELP,
  INLINE,
  MANGLE,
  MINIFY,
  OUTPUT_DIRECTORY,
  OUTPUT_FILE,
  PREPEND_FILE,
  RELEASE,
  REMOVE_ASSERTS,
  SOURCE_MAP,
  TARGET,
  VERBOSE,
}

export namespace frontend {
  int main(List<string> arguments) {
    // Translate frontend flags to compiler options
    var log = Log();
    var parser = OptionParser();
    var options = parseOptions(log, parser, arguments);

    // Run the compilation
    if (!log.hasErrors() && options != null) {
      var compiler = Compiler();
      compiler.log = log;
      var result = compiler.compile(options);

      // Write all outputs
      if (!log.hasErrors()) {
        for (var i = 0; i < result.outputs.size(); i++) {
          var output = result.outputs[i];
          if (!io.writeFile(output.name, output.contents)) {
            commandLineErrorUnwritableFile(log, parser.source.rangeContainingEverything(), output.name);
            break;
          }
        }

        // Print compilation statistics
        if (!log.hasErrors() && options.verbose) {
          io.print(compiler.statistics(result) + "\n");
        }
      }
    }

    // Print any errors and warnings
    printLogWithColor(log);
    return log.hasErrors() ? 1 : 0;
  }
}

in frontend {
  CompilerOptions parseOptions(Log log, OptionParser parser, List<string> arguments) {
    // Configure the parser
    parser.define(.BOOL, .HELP, "--help", "Prints this message.").aliases(["-help", "?", "-?", "-h", "-H", "/?", "/h", "/H"]);
    parser.define(.STRING, .TARGET, "--target", "Sets the target format. Valid targets are " + prettyPrint.join(simpleQuoteAll(VALID_TARGETS), "and") + ".");
    parser.define(.STRING, .OUTPUT_FILE, "--output-file", "Combines all output into a single file. Mutually exclusive with --output-dir.");
    parser.define(.STRING, .OUTPUT_DIRECTORY, "--output-dir", "Places all output files in the specified directory. Mutually exclusive with --output-file.");
    parser.define(.STRING_LIST, .DEFINE, "--define", "Overrides the value of a #define statement. Example: --define:UNIT_TESTS=true.");
    parser.define(.BOOL, .RELEASE, "--release", "Implies --inline, --globalize, --remove-asserts, --fold-constants, --minify, --mangle, and --define:BUILD_RELEASE=true.");
    parser.define(.STRING, .CONFIG, "--config", "Provides the configuration for the target format. Valid configurations are " + prettyPrint.join(simpleQuoteAll(VALID_JS_CONFIGS), "and") + " for JavaScript and " + prettyPrint.join(simpleQuoteAll(VALID_CPP_CONFIGS), "and") + " for C++. The default configuration is \"browser\" for JavaScript and the current operating system for C++.");
    parser.define(.BOOL, .VERBOSE, "--verbose", "Prints out information about the compilation.");
    parser.define(.BOOL, .SOURCE_MAP, "--source-map", "Generates a source map when targeting JavaScript. The source map is saved with the \".map\" extension in the same directory as the main output file.");
    parser.define(.BOOL, .INLINE, "--inline", "Uses heuristics to automatically inline simple functions.");
    parser.define(.BOOL, .GLOBALIZE, "--globalize", "Changes all internal non-virtual instance methods to static methods. This provides more inlining opportunities at compile time and avoids property access overhead at runtime.");
    parser.define(.BOOL, .REMOVE_ASSERTS, "--remove-asserts", "Removes all assert statements prior to compilation.");
    parser.define(.BOOL, .FOLD_CONSTANTS, "--fold-constants", "Evaluates constants at compile time and removes dead code inside functions.");
    parser.define(.BOOL, .MINIFY, "--minify", "Omits whitespace so the emitted JavaScript takes up less space.");
    parser.define(.BOOL, .MANGLE, "--mangle", "Transforms your JavaScript code to be as small as possible. The \"export\" modifier prevents renaming a symbol.");
    parser.define(.STRING_LIST, .APPEND_FILE, "--append-file", "Append the contents of this file to the output. Provide this flag multiple times to append multiple files.");
    parser.define(.STRING_LIST, .PREPEND_FILE, "--prepend-file", "Prepend the contents of this file to the output. Provide this flag multiple times to prepend multiple files.");

    // Parse the command line arguments
    parser.parse(log, arguments);
    if (log.hasErrors()) {
      return null;
    }

    // Early-out when printing the usage text
    if (parser.boolForOption(.HELP, arguments.size() == 0)) {
      printUsage(parser);
      return null;
    }

    // Set up the options for the compiler
    var options = CompilerOptions();
    var releaseFlag = parser.boolForOption(.RELEASE, false);
    options.fileAccess = FrontendFileAccess();
    options.verbose = parser.boolForOption(.VERBOSE, false);
    options.jsSourceMap = parser.boolForOption(.SOURCE_MAP, false);
    options.jsMinify = parser.boolForOption(.MINIFY, releaseFlag);
    options.jsMangle = parser.boolForOption(.MANGLE, releaseFlag);
    options.removeAsserts = parser.boolForOption(.REMOVE_ASSERTS, releaseFlag);
    options.foldAllConstants = parser.boolForOption(.FOLD_CONSTANTS, releaseFlag);
    options.inlineAllFunctions = parser.boolForOption(.INLINE, releaseFlag);
    options.convertAllInstanceToStatic = parser.boolForOption(.GLOBALIZE, releaseFlag);

    // Prepare the defines
    if (releaseFlag) {
      options.overrideDefine("BUILD_RELEASE", true);
    }
    var defines = parser.stringRangeListForOption(.DEFINE);
    if (defines != null) {
      for (var i = 0; i < defines.size(); i++) {
        var range = defines[i];
        var text = range.toString();
        var equals = text.indexOf("=");
        var value = true;
        var name = text;
        if (equals >= 0) {
          name = text.slice(0, equals);
          var boolean = text.slice(equals + 1, text.size());
          if (boolean != "true" && boolean != "false") {
            commandLineErrorNonBooleanValue(log, range.fromEnd(boolean.size()), boolean, text);
            continue;
          }
          value = boolean == "true";
          range = range.fromStart(name.size());
        }
        options.overriddenDefines[name] = OverriddenDefine(value, range);
      }
    }

    // There must be at least one source file
    var everything = parser.source.rangeContainingEverything();
    if (parser.normalArguments.size() == 0) {
      commandLineErrorNoInputFiles(log, everything);
    }

    // Check the format
    TargetFormat targetFormat = .NONE;
    var target = parser.stringRangeForOption(.TARGET);
    if (target == null) {
      commandLineErrorMissingTarget(log, everything, "--target");
    } else {
      var name = target.toString();
      if (name == "js") targetFormat = .JAVASCRIPT;
      else if (name == "cpp") targetFormat = .CPP;
      else if (name == "lisp-ast") targetFormat = .LISP_AST;
      else if (name == "json-ast") targetFormat = .JSON_AST;
      else if (name == "xml-ast") targetFormat = .XML_AST;
      else commandLineErrorInvalidTarget(log, target, name, VALID_TARGETS);
    }
    options.targetFormat = targetFormat;

    // Parse the output location
    var outputFile = parser.stringRangeForOption(.OUTPUT_FILE);
    var outputDirectory = parser.stringRangeForOption(.OUTPUT_DIRECTORY);
    if (outputFile == null && outputDirectory == null) {
      commandLineErrorMissingOutput(log, everything, "--output-file", "--output-dir");
    } else if (outputFile != null && outputDirectory != null) {
      commandLineErrorDuplicateOutput(log, outputFile.start > outputDirectory.start ? outputFile : outputDirectory, "--output-file", "--output-dir");
    } else if (outputFile != null) {
      options.outputFile = outputFile.toString();
    } else {
      options.outputDirectory = outputDirectory.toString();
    }

    // Check the configuration
    if (targetFormat != .NONE) {
      CompilerConfig targetConfig = .NONE;
      var config = parser.stringRangeForOption(.CONFIG);
      if (config == null) {
        var os = OperatingSystem.current();
        targetConfig =
          targetFormat == .CPP ?
            os == .ANDROID ? .ANDROID :
            os == .IOS ? .IOS :
            os == .LINUX ? .LINUX :
            os == .OSX ? .OSX :
            os == .WINDOWS ? .WINDOWS :
            .NONE :
          targetFormat == .JAVASCRIPT ?
            .BROWSER :
          .NONE;
      } else {
        var name = config.toString();
        if (targetFormat == .JAVASCRIPT) {
          if (name == "browser") targetConfig = .BROWSER;
          else if (name == "node") targetConfig = .NODE;
          else commandLineErrorInvalidConfiguration(log, config, name, VALID_JS_CONFIGS);
        } else if (targetFormat == .CPP) {
          if (name == "android") targetConfig = .ANDROID;
          else if (name == "ios") targetConfig = .IOS;
          else if (name == "linux") targetConfig = .LINUX;
          else if (name == "osx") targetConfig = .OSX;
          else if (name == "windows") targetConfig = .WINDOWS;
          else commandLineErrorInvalidConfiguration(log, config, name, VALID_CPP_CONFIGS);
        } else {
          commandLineErrorUnexpectedConfiguration(log, config, name, target.toString());
        }
      }
      options.targetConfig = targetConfig;
    }

    // Read the source files
    options.inputs = readSources(log, parser.normalArguments);
    options.append = readSources(log, parser.stringRangeListForOption(.APPEND_FILE));
    options.prepend = readSources(log, parser.stringRangeListForOption(.PREPEND_FILE));
    return options;
  }

  List<Source> readSources(Log log, List<Range> files) {
    List<Source> result = [];
    var error = false;
    for (var i = 0; i < files.size(); i++) {
      var file = files[i];
      var name = file.toString();
      var source = io.readFile(name);
      if (source == null) {
        commandLineErrorUnreadableFile(log, file, name);
      } else {
        result.push(source);
      }
    }
    return error ? null : result;
  }

  enum Color {
    DEFAULT = 0,
    BOLD = 1,
    GRAY = 90,
    RED = 91,
    GREEN = 92,
    YELLOW = 93,
    BLUE = 94,
    MAGENTA = 95,
    CYAN = 96,
  }

  void printWithColor(Color color, string text) {
    io.setColor(color);
    io.print(text);
    io.setColor(Color.DEFAULT);
  }

  void printError(string text) {
    printWithColor(.RED, "error: ");
    printWithColor(.BOLD, text + "\n");
  }

  void printNote(string text) {
    printWithColor(.GRAY, "note: ");
    printWithColor(.BOLD, text + "\n");
  }

  void printWarning(string text) {
    printWithColor(.MAGENTA, "warning: ");
    printWithColor(.BOLD, text + "\n");
  }

  void printUsage(OptionParser parser) {
    printWithColor(.GREEN, "\nusage: ");
    printWithColor(.BOLD, "skewc [flags] [inputs]\n");
    io.print(parser.usageText(80));
  }

  void printLogWithColor(Log log) {
    for (var i = 0; i < log.diagnostics.size(); i++) {
      var diagnostic = log.diagnostics[i];
      if (!diagnostic.range.isEmpty()) {
        printWithColor(.BOLD, diagnostic.range.locationString() + ": ");
      }
      switch (diagnostic.kind) {
        case .WARNING { printWarning(diagnostic.text); }
        case .ERROR { printError(diagnostic.text); }
      }
      if (!diagnostic.range.isEmpty()) {
        var formatted = diagnostic.range.format(io.terminalWidth);
        io.print(formatted.line + "\n");
        printWithColor(.GREEN, formatted.range + "\n");
      }
      if (!diagnostic.noteRange.isEmpty()) {
        printWithColor(.BOLD, diagnostic.noteRange.locationString() + ": ");
        printNote(diagnostic.noteText);
        var formatted = diagnostic.noteRange.format(io.terminalWidth);
        io.print(formatted.line + "\n");
        printWithColor(.GREEN, formatted.range + "\n");
      }
    }

    // Print the summary
    var hasErrors = log.hasErrors();
    var hasWarnings = log.hasWarnings();
    var summary = "";
    if (hasWarnings) {
      summary += log.warningCount + prettyPrint.plural(log.warningCount, " warning", " warnings");
      if (hasErrors) summary += " and ";
    }
    if (hasErrors) {
      summary += log.errorCount + prettyPrint.plural(log.errorCount, " error", " errors");
    }
    if (hasWarnings || hasErrors) {
      io.print(summary + " generated\n");
    }
  }

  final var VALID_TARGETS = [
    "js",
    "cpp",
    "lisp-ast",
    "json-ast",
    "xml-ast",
  ];

  final var VALID_JS_CONFIGS = [
    "browser",
    "node",
  ];

  final var VALID_CPP_CONFIGS = [
    "android",
    "ios",
    "linux",
    "osx",
    "windows",
  ];
}
