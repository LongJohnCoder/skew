import namespace io {
  enum Color {
    DEFAULT = 0,
    BOLD = 1,
    GRAY = 90,
    RED = 91,
    GREEN = 92,
    YELLOW = 93,
    BLUE = 94,
    MAGENTA = 95,
    CYAN = 96,
  }

  import int terminalWidth;
  import void setColor(Color color);
  import void print(string text);
  import bool writeFile(string path, string contents);
  import Source readFile(string path);

  void printWithColor(Color color, string text) {
    setColor(color);
    print(text);
    setColor(.DEFAULT);
  }
}

export namespace frontend {
  void printError(string text) {
    io.printWithColor(.RED, "error: ");
    io.printWithColor(.BOLD, text + "\n");
  }

  void printNote(string text) {
    io.printWithColor(.GRAY, "note: ");
    io.printWithColor(.BOLD, text + "\n");
  }

  void printWarning(string text) {
    io.printWithColor(.MAGENTA, "warning: ");
    io.printWithColor(.BOLD, text + "\n");
  }

  void printUsage() {
    io.printWithColor(.GREEN, "\nusage: ");
    io.printWithColor(.BOLD, "skewc [flags] [inputs]\n");
    io.print("
  --help (-h)        Print this message.

  --verbose          Print out useful information about the compilation.

  --target=___       Set the target language. Valid target languages: none, js,
                     lisp-ast, json-ast, and xml-ast.

  --output-file=___  Combines all output into a single file.

  --prepend-file=___ Prepend the contents of this file to the output. Provide
                     this flag multiple times to prepend multiple files.

  --append-file=___  Append the contents of this file to the output. Provide
                     this flag multiple times to append multiple files.

  --js-minify        Transform the emitted JavaScript so that it takes up less
                     space. Make sure to use the \"export\" modifier on code
                     that shouldn't be minifed.

  --js-source-map    Generate a source map when targeting JavaScript. The source
                     map will be saved with the \".map\" extension in the same
                     directory as the main output file.

");
  }

  class Flags {
    var help = false;
    var verbose = false;
    var target = "";
    var outputFile = "";
    var jsMinify = false;
    var jsSourceMap = false;
    var optimize = false;
  }

  string afterEquals(string text) {
    var equals = text.indexOf("=");
    assert equals >= 0;
    return text.slice(equals + 1, text.length);
  }

  List<Source> readSources(List<string> files) {
    List<Source> result = [];
    for (var i = 0; i < files.length; i++) {
      var file = files.get(i);
      var source = io.readFile(file);
      if (source == null) {
        printError("Could not read from " + quoteString(file, '"'));
        return null;
      }
      result.push(source);
    }
    return result;
  }

  export int main(List<string> args) {
    List<string> inputs = [];
    List<string> prepend = [];
    List<string> append = [];
    var flags = Flags();

    for (var i = 0; i < args.length; i++) {
      var arg = args.get(i);

      // Ignore empty arguments
      if (arg.length == 0) continue;

      // Remember file paths
      if (arg.codeUnitAt(0) != '-') inputs.push(arg);

      // Check flags
      else if (arg == "-help" || arg == "--help" || arg == "-h") { printUsage(); return 0; }
      else if (arg == "-verbose" || arg == "--verbose") flags.verbose = true;
      else if (arg == "-optimize" || arg == "--optimize") flags.optimize = true;
      else if (arg == "-js-minify" || arg == "--js-minify") flags.jsMinify = true;
      else if (arg == "-js-source-map" || arg == "--js-source-map") flags.jsSourceMap = true;
      else if (arg.startsWith("-target=") || arg.startsWith("--target=")) flags.target = afterEquals(arg);
      else if (arg.startsWith("-output-file=") || arg.startsWith("--output-file=")) flags.outputFile = afterEquals(arg);
      else if (arg.startsWith("-prepend-file=") || arg.startsWith("--prepend-file=")) prepend.push(afterEquals(arg));
      else if (arg.startsWith("-append-file=") || arg.startsWith("--append-file=")) append.push(afterEquals(arg));

      // An unknown argument is an error
      else {
        printError("Unknown flag " + quoteString(arg, '"'));
        return 1;
      }

      continue;
    }

    // Input files are required
    if (inputs.length == 0) {
      printError("Missing input files");
      return 1;
    }

    // The target language is required
    TargetFormat target;
    if (flags.target == "") {
      printError("Set the target language with \"--target=___\"");
      return 1;
    }
    switch (flags.target) {
      case "none" { target = .NONE; }
      case "js" { target = .JAVASCRIPT; }
      case "cs" { target = .CSHARP; }
      case "lisp-ast" { target = .LISP_AST; }
      case "json-ast" { target = .JSON_AST; }
      case "xml-ast" { target = .XML_AST; }
      default { printError("Unknown target language " + quoteString(flags.target, '"')); return 1; }
    }

    // Translate frontend flags to compiler options
    var options = CompilerOptions();
    options.targetFormat = target;
    options.removeAsserts = flags.optimize;
    options.outputFile = flags.outputFile;
    options.foldAllConstants = options.inlineAllFunctions = options.convertAllInstanceToStatic = flags.optimize && target == .JAVASCRIPT;
    options.jsMinify = options.jsMangle = flags.jsMinify && target == .JAVASCRIPT;
    options.jsSourceMap = flags.jsSourceMap && target == .JAVASCRIPT;
    options.inputs = readSources(inputs); if (options.inputs == null) return 1;
    options.prepend = readSources(prepend); if (options.prepend == null) return 1;
    options.append = readSources(append); if (options.append == null) return 1;

    // Run the compilation
    var compiler = Compiler();
    var result = compiler.compile(options);

    // Print any errors and warnings
    var log = compiler.log;
    for (var i = 0; i < log.diagnostics.length; i++) {
      var diagnostic = log.diagnostics.get(i);
      if (!diagnostic.range.isEmpty()) {
        io.printWithColor(.BOLD, diagnostic.range.locationString() + ": ");
      }
      switch (diagnostic.kind) {
        case .WARNING { printWarning(diagnostic.text); }
        case .ERROR { printError(diagnostic.text); }
      }
      if (!diagnostic.range.isEmpty()) {
        var formatted = diagnostic.range.format(io.terminalWidth);
        io.print(formatted.line + "\n");
        io.printWithColor(.GREEN, formatted.range + "\n");
      }
      if (!diagnostic.noteRange.isEmpty()) {
        io.printWithColor(.BOLD, diagnostic.noteRange.locationString() + ": ");
        printNote(diagnostic.noteText);
        var formatted = diagnostic.noteRange.format(io.terminalWidth);
        io.print(formatted.line + "\n");
        io.printWithColor(.GREEN, formatted.range + "\n");
      }
    }

    // Print the summary
    var hasErrors = log.errorCount > 0;
    var hasWarnings = log.warningCount > 0;
    var summary = "";
    if (hasWarnings) {
      summary += log.warningCount + (plural(log.warningCount, " warning", " warnings"));
      if (hasErrors) summary += " and ";
    }
    if (hasErrors) summary += log.errorCount + (plural(log.errorCount, " error", " errors"));
    if (hasWarnings || hasErrors) io.print(summary + " generated\n");
    if (flags.verbose) io.print(compiler.statistics(result) + "\n");
    if (hasErrors) return 1;

    // Write all outputs
    for (var i = 0; i < result.outputs.length; i++) {
      var output = result.outputs.get(i);
      if (output.name == "") {
        io.print(output.contents);
        continue;
      }
      if (!io.writeFile(output.name, output.contents)) {
        printError("Could not write to " + quoteString(output.name, '"'));
        return 1;
      }
    }

    return 0;
  }
}
