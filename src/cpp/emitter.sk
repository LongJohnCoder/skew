namespace cpp {
  enum Pass {
    NONE,
    FORWARD_DECLARE_TYPES,
    FORWARD_DECLARE_CODE,
    IMPLEMENT_CODE,
  }

  enum CppEmitType {
    BARE,
    NORMAL,
    DECLARATION,
  }

  class Emitter : base.Emitter {
    List<string> namespaceStack = [];
    var includes = StringMap<bool>();
    var usedAssert = false;
    var usedMath = false;
    Pass pass = .NONE;

    override string extension() {
      return "cpp";
    }

    override void visitProgram(Node node) {
      // Emit code in three passes
      var collector = Collector(node, .SORT_BY_INHERITANCE_AND_CONTAINMENT);

      pass = .FORWARD_DECLARE_TYPES;
      visitCollector(collector);
      adjustNamespace(null);
      forceEmitExtraNewline();

      pass = .FORWARD_DECLARE_CODE;
      visitCollector(collector);
      adjustNamespace(null);
      forceEmitExtraNewline();

      pass = .IMPLEMENT_CODE;
      visitCollector(collector);
      adjustNamespace(null);

      emitEntryPoint();
      prependHeaders();
    }

    void emitEntryPoint() {
      var entryPointSymbol = resolver.entryPointSymbol;
      if (entryPointSymbol != null) {
        var type = entryPointSymbol.type;
        var hasArguments = type.argumentTypes().size() > 0;
        var hasReturnValue = type.resultType() == cache.intType;
        emitExtraNewlineBefore(.NULL);
        emit(indent + "int main(" + (hasArguments ? "int argc, char **argv" : "") + ") {\n");
        increaseIndent();
        if (hasArguments) {
          assert "<string>" in includes;
          var name = mangleName(cache.stringType.symbol);
          emit(indent + "List<" + name + "> *args = new List<" + name + "> {};\n");
          emit(indent + "args->_data.insert(args->_data.begin(), argv + 1, argv + argc);\n"); // The method push() may not have been emitted
        }
        emit(indent + (hasReturnValue ? "return " : "") + fullName(entryPointSymbol) + "(" + (hasArguments ? "args" : "") + ");\n");
        decreaseIndent();
        emit(indent + "}\n");
      }
    }

    void prependHeaders() {
      // Some headers need to be force-included for floating-point literals and
      // assert statements
      if (usedAssert) includes["<cassert>"] = true;
      if (usedMath) includes["<cmath>"] = true;

      // Sort headers for deterministic output
      var headers = includes.keys();
      headers.sort(StringComparison.INSTANCE);

      // Prepend headers if needed
      if (headers.size() > 0) {
        var text = "";
        for (var i = 0; i < headers.size(); i++) {
          var name = headers[i];
          var size = name.size();
          text += "#include " + (size == 0 || name[0] != '<' || name[size - 1] != '>' ? "\"" + name + "\"" : name) + "\n";
        }
        output.contents = text + "\n" + output.contents;
      }
    }

    override void handleSymbol(Symbol symbol) {
      if (symbol.neededIncludes != null) {
        for (var i = 0; i < symbol.neededIncludes.size(); i++) {
          includes[symbol.neededIncludes[i]] = true;
        }
      }
      if (!symbol.kind.isType() && symbol.type.symbol != symbol) {
        handleSymbolType(symbol.type);
      }
    }

    void handleSymbolType(Type type) {
      if (type.symbol != null) {
        handleSymbol(type.symbol);
      }
    }

    override bool shouldEmitExtraNewlineBetween(NodeKind before, NodeKind after) {
      if (pass == .FORWARD_DECLARE_TYPES) {
        return before == .NAMESPACE || after == .NAMESPACE || before.isEnum() || after.isEnum();
      }
      return super(before, after) && (pass != .FORWARD_DECLARE_CODE || !before.isFunction() || !after.isFunction());
    }

    override void emitTypeParameter(Symbol symbol) {
      emit("typename " + mangleName(symbol));
    }

    override void emitTypeParameters(Symbol symbol) {
      var enclosingSymbol = symbol.enclosingSymbol;
      var selfParameters = symbol.hasParameters();
      var enclosingParameters = pass == .IMPLEMENT_CODE && enclosingSymbol.hasParameters();
      if (selfParameters || enclosingParameters) {
        emit(indent + "template <");
        if (selfParameters) {
          for (var i = 0; i < symbol.parameters.size(); i++) {
            if (i > 0) emit(", ");
            emitTypeParameter(symbol.parameters[i]);
          }
        }
        if (enclosingParameters) {
          for (var i = 0; i < enclosingSymbol.parameters.size(); i++) {
            if (i > 0 || selfParameters) emit(", ");
            emitTypeParameter(enclosingSymbol.parameters[i]);
          }
        }
        emit(">\n");
      }
    }

    void emitEnumValues(Symbol symbol) {
      var members = symbol.type.sortedMembers();
      var isEnumFlags = symbol.kind == .ENUM_FLAGS;
      var isFirst = true;
      var previous = -1;
      for (var i = 0; i < members.size(); i++) {
        var member = members[i].symbol;
        handleSymbol(member);
        if (member.isEnumValue()) {
          if (isFirst) {
            isFirst = false;
          } else {
            emit(",\n");
          }
          var value = member.constant.asInt();
          emit(indent + mangleName(member));
          if (isEnumFlags || value != previous + 1) {
            emit(" = " + value);
          }
          previous = value;
        }
      }
      if (!isFirst) {
        emit("\n");
      }
    }

    override void emitTypeDeclaration(Symbol symbol) {
      handleSymbol(symbol);
      if (symbol.kind.isObject()) {
        if (pass != .IMPLEMENT_CODE) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(symbol.node.kind);
          emitTypeParameters(symbol);
          emit(indent + "struct " + mangleName(symbol));
          if (pass == .FORWARD_DECLARE_CODE) {
            if (symbol.type.hasRelevantTypes()) {
              var types = symbol.type.relevantTypes;
              emit(" : ");
              for (var i = 0; i < types.size(); i++) {
                if (i > 0) emit(", ");
                emitCppType(types[i], .BARE);
              }
            }
            emit(" {\n");
            increaseIndent();
            emitTypeMembers(symbol);
            decreaseIndent();
            emit(indent + "}");
          }
          emit(";\n");
          emitExtraNewlineAfter(symbol.node.kind);
        } else {
          emitTypeMembers(symbol);
        }
      }

      else if (symbol.kind == .ENUM) {
        if (pass == .FORWARD_DECLARE_TYPES) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(.ENUM);
          emit(indent + "enum struct " + mangleName(symbol) + " {\n");
          increaseIndent();
          emitEnumValues(symbol);
          decreaseIndent();
          emit(indent + "};\n");
          emitExtraNewlineAfter(.ENUM);
        }
      }

      else if (symbol.kind == .ENUM_FLAGS) {
        if (pass == .FORWARD_DECLARE_TYPES) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(.ENUM_FLAGS);
          emit(indent + "namespace " + mangleName(symbol) + " {\n");
          increaseIndent();
          emit(indent + "enum {\n");
          increaseIndent();
          emitEnumValues(symbol);
          decreaseIndent();
          emit(indent + "};\n");
          decreaseIndent();
          emit(indent + "}\n");
          emitExtraNewlineAfter(.ENUM_FLAGS);
        }
      }
    }

    override void emitFunction(Symbol symbol) {
      handleSymbol(symbol);
      if (pass != .FORWARD_DECLARE_TYPES) {
        var node = symbol.node;
        var block = node.functionBlock();
        if (block != null || pass == .FORWARD_DECLARE_CODE) {
          adjustNamespace(pass == .FORWARD_DECLARE_CODE ? symbol : null);
          emitExtraNewlineBefore(node.kind);
          emitTypeParameters(symbol);
          emit(indent);
          if (pass == .FORWARD_DECLARE_CODE) {
            if (symbol.isStatic()) emit("static ");
            if (symbol.isVirtual()) emit("virtual ");
          }
          if (symbol.kind != .CONSTRUCTOR_FUNCTION) {
            emitCppType(symbol.type.resultType(), .DECLARATION);
          }
          if (pass == .IMPLEMENT_CODE) {
            var enclosingSymbol = symbol.enclosingSymbol;
            if (enclosingSymbol != null && enclosingSymbol.kind != .GLOBAL_NAMESPACE) {
              emit(fullName(enclosingSymbol));
              if (enclosingSymbol.hasParameters()) {
                emit("<");
                for (var i = 0; i < enclosingSymbol.parameters.size(); i++) {
                  if (i > 0) emit(", ");
                  emit(mangleName(enclosingSymbol.parameters[i]));
                }
                emit(">");
              }
              emit("::");
            }
          }
          emit(mangleName(symbol));
          emitFunctionArguments(symbol);
          if (block == null) {
            emit(" = 0;");
          } else if (pass == .FORWARD_DECLARE_CODE) {
            emit(";");
          } else {
            if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
              var superInitializer = node.superInitializer();
              var memberInitializers = node.memberInitializers();
              var superCallArguments = superInitializer != null ? superInitializer.superCallArguments() : null;
              if (superInitializer != null && superCallArguments.size() > 0 || memberInitializers != null && memberInitializers.hasChildren()) {
                emit(" : ");
                if (superInitializer != null && superCallArguments.size() > 0) {
                  emit(fullName(superInitializer.symbol.enclosingSymbol) + "(");
                  emitCommaSeparatedExpressions(superInitializer.superCallArguments());
                  emit(")");
                  if (memberInitializers != null && memberInitializers.hasChildren()) {
                    emit(", ");
                  }
                }
                if (memberInitializers != null) {
                  for (var i = 0; i < memberInitializers.children.size(); i++) {
                    var initializer = memberInitializers.children[i];
                    var value = initializer.memberInitializerValue();
                    if (i > 0) emit(", ");
                    emit(mangleName(initializer.symbol) + "(");
                    if (value.kind != .ERROR) {
                      emitExpression(value, .LOWEST);
                    }
                    emit(")");
                  }
                }
              }
            }
            emitBlock(block);
          }
          emit("\n");
          emitExtraNewlineAfter(node.kind);
        }
      }
    }

    override bool shouldEmitSpaceForUnaryOperator(Node node) {
      return node.kind.isUnaryTypeOperator() ? true : super(node);
    }

    override void emitTypeBeforeVariable(Symbol symbol) {
      emitCppType(symbol.type, .DECLARATION);
    }

    override void emitVariable(Symbol symbol) {
      handleSymbol(symbol);
      if (pass != .FORWARD_DECLARE_TYPES && (pass == .FORWARD_DECLARE_CODE || symbol.kind != .INSTANCE_VARIABLE)) {
        adjustNamespace(pass == .FORWARD_DECLARE_CODE ? symbol : null);
        emitExtraNewlineBefore(symbol.node.kind);
        emit(indent);
        if (pass == .FORWARD_DECLARE_CODE && symbol.kind.isGlobal()) {
          emit(symbol.isStatic() ? "static " : "extern ");
        }
        emitTypeBeforeVariable(symbol);
        if (pass == .FORWARD_DECLARE_CODE) {
          emit(mangleName(symbol));
        } else {
          emit(fullName(symbol));
          emitAfterVariable(symbol.node);
        }
        emit(";\n");
        emitExtraNewlineAfter(symbol.node.kind);
      }
    }

    override void emitFunctionArgument(Symbol symbol) {
      // Make sure to avoid copies for std::string extension methods
      var useConstReference = symbol.name == "this" && symbol.type.isString(cache);
      if (useConstReference) emit("const ");
      emitCppType(symbol.type, .DECLARATION);
      if (useConstReference) emit("&");
      emit(mangleName(symbol));
      emitAfterVariable(symbol.node);
    }

    override void emitForEach(Node node) {
      var symbol = node.forEachVariable().symbol;
      emit(indent + "for (");
      emitTypeBeforeVariable(symbol);
      emit(mangleName(symbol));
      emit(" : ");
      emitExpression(node.forEachValue(), .LOWEST);
      emit(")");
      emitBlock(node.forEachBlock());
      emit("\n");
    }

    override void emitAssert(Node node) {
      emit(indent + "assert(");
      emitExpression(node.assertValue(), .LOWEST);
      emit(");\n");
      usedAssert = true;
    }

    override void emitBinary(Node node, Precedence precedence) {
      // Clang warns about && inside || or & inside | without parentheses
      if (node.parent.kind == .LOGICAL_OR && node.kind == .LOGICAL_AND ||
          node.parent.kind == .BITWISE_OR && node.kind == .BITWISE_AND) {
        precedence = .MEMBER;
      }

      super(node, precedence);
    }

    override void emitNull() {
      emit("nullptr");
    }

    override void emitReal(Node node) {
      var value = node.asDouble();
      if (value == math.INFINITY) {
        usedMath = true;
        emit("INFINITY");
      } else if (value == -math.INFINITY) {
        usedMath = true;
        emit("-INFINITY");
      } else if (value != value) {
        usedMath = true;
        emit("NAN");
      } else {
        emit(doubleToStringWithDot(value) + (node.kind == .FLOAT ? "f" : ""));
      }
    }

    // Avoid generating C++ code that adds two "char *" pointers or that
    // tries to access a member of std::string off a "char *" pointer
    static bool needsWrappedStringConstructor(Node node) {
      var parent = node.parent;
      switch (parent.kind) {
        case .CALL { return node == parent.callValue(); }
        case .HOOK { return parent.hookTrue() == node && parent.hookFalse().kind == .STRING; }
        case .ADD { return parent.binaryLeft() == node && parent.binaryRight().kind == .STRING; }
        case .ASSIGN, .ASSIGN_ADD, .VARIABLE, .MEMBER_INITIALIZER, .RETURN { return false; }
        default { return true; }
      }
    }

    override void emitString(Node node) {
      var content = node.asString();
      var needsLength = "\0" in content;
      var needsWrap = needsLength || needsWrappedStringConstructor(node);

      if (needsWrap) {
        handleSymbol(cache.stringType.symbol);
        emit(mangleName(cache.stringType.symbol) + "(");
      }
      super(node);
      if (needsWrap) {
        if (needsLength) {
          emit(", " + content.size());
        }
        emit(")");
      }
    }

    override void emitDot(Node node) {
      var target = node.dotTarget();
      var dotName = node.dotName();
      if (target != null) {
        emitExpression(target, .MEMBER);
      }
      if (dotName.kind == .QUOTED) {
        dotName = dotName.quotedValue();
      }
      emit(node.kind == .DOT_COLON ? "::" : node.kind == .DOT_ARROW || target != null && target.type.isReference() ? "->" : ".");
      emit(node.symbol != null ? mangleName(node.symbol) : dotName.asString());
    }

    override void emitCall(Node node, Precedence precedence) {
      var value = node.callValue();
      var isNew = value.kind == .TYPE;
      var wrap = isNew && precedence == .MEMBER;
      if (wrap) emit("(");
      if (isNew) emit("new ");
      emitExpression(value, .UNARY_POSTFIX);
      if (!isNew && value.type != null && value.type.isParameterized()) {
        var substitutions = value.type.substitutions;
        emit("<");
        for (var i = 0; i < substitutions.size(); i++) {
          if (i > 0) emit(", ");
          emitCppType(substitutions[i], .NORMAL);
        }
        emit(">");
      }
      emit("(");
      emitCommaSeparatedExpressions(node.callArguments());
      emit(")");
      if (wrap) emit(")");
    }

    override void emitParenthesizedCast(Node node, Precedence precedence) {
      emit("static_cast<");
      emitNormalType(node.castType().type);
      emit(">(");
      emitExpression(node.castValue(), .LOWEST);
      emit(")");
    }

    override bool shouldEmitCast(Node node) {
        // C++11 doesn't auto-convert enums to ints for some reason
      if (node.type.isInt(cache) && node.castValue().type.isRegularEnum()) {
        return true;
      }

      // C++ doesn't find common types for some reason, so this is an error:
      //
      //   struct Foo {};
      //   struct Bar : Foo {};
      //   struct Baz : Foo {};
      //   Foo *foo = ... ? new Bar : new Baz;
      //
      // This must be used instead:
      //
      //   Foo *foo = ... ? static_cast<Foo *>(new Bar) : new Baz;
      //
      if (node.type.isReference() && node.parent.kind == .HOOK && node.castValue().kind != .NULL && node == node.parent.hookTrue()) {
        return true;
      }

      return super(node);
    }

    override void emitInt(Node node, Precedence precedence) {
      if (node.type.isEnum() && node.symbol != null) {
        emitName(node);
      } else if (node.type.isRegularEnum()) {
        if (.UNARY_PREFIX < precedence) emit("(");
        emit("(");
        emitNormalType(node.type);
        emit(")");
        emit(node.asInt().toString());
        if (.UNARY_PREFIX < precedence) emit(")");
      } else {
        emit(node.asInt().toString());
      }
    }

    override void emitList(Node node, Precedence precedence) {
      var values = node.listValues();
      var wrap = precedence == .MEMBER;
      if (wrap) emit("(");
      emit("new ");
      emitCppType(node.type, .BARE);
      handleSymbolType(node.type);
      if (values.size() > 0) {
        emit(" { ");
        emitCommaSeparatedExpressions(values);
        emit(" }");
      } else {
        emit(" {}");
      }
      if (wrap) emit(")");
    }

    override void emitSuperCall(Node node) {
      emit(fullName(node.symbol));
      emit("(");
      emitCommaSeparatedExpressions(node.superCallArguments());
      emit(")");
    }

    override void emitNormalType(Type type) {
      emitCppType(type, .NORMAL);
    }

    void emitCppType(Type type, CppEmitType mode) {
      if (type.isEnumFlags()) {
        emit("int");
      } else if (type.isQuoted()) {
        emitExpression(type.symbol.node, .LOWEST);
      } else {
        emitType(type);
      }
      if (type.isReference() && mode != .BARE) {
        emit(" *");
      } else if (mode == .DECLARATION && (!type.isQuoted() || !type.symbol.node.kind.isUnaryTypeOperator())) {
        emit(" ");
      }
    }

    override bool useDoubleColonForEnclosingSymbols() {
      return true;
    }

    void adjustNamespace(Symbol symbol) {
      // Get the namespace chain for this symbol
      List<string> names = [];
      while (symbol != null && symbol.kind != .GLOBAL_NAMESPACE) {
        if (symbol.kind == .NAMESPACE) {
          names.unshift(mangleName(symbol));
        }
        symbol = symbol.enclosingSymbol;
      }

      // Find the intersection
      var n = namespaceStack.size() < names.size() ? namespaceStack.size() : names.size();
      int i;
      for (i = 0; i < n; i++) {
        if (namespaceStack[i] != names[i]) {
          break;
        }
      }

      // Leave the old namespace
      while (namespaceStack.size() > i) {
        namespaceStack.pop();
        decreaseIndent();
        emit(indent + "}\n");
        emitExtraNewlineAfter(.NAMESPACE);
      }

      // Enter the new namespace
      while (namespaceStack.size() < names.size()) {
        var name = names[namespaceStack.size()];
        emitExtraNewlineBefore(.NAMESPACE);
        emit(indent + "namespace " + name + " {\n");
        increaseIndent();
        namespaceStack.push(name);
      }
    }

    override string mangleName(Symbol symbol) {
      if (symbol.name == "main" && symbol.fullName() == "main") {
        return "_main_";
      }
      return super(symbol);
    }

    override StringMap<bool> createIsKeyword() {
      var result = StringMap<bool>();
      result["alignas"] = true;
      result["alignof"] = true;
      result["and"] = true;
      result["and_eq"] = true;
      result["asm"] = true;
      result["auto"] = true;
      result["bitand"] = true;
      result["bitor"] = true;
      result["bool"] = true;
      result["break"] = true;
      result["case"] = true;
      result["catch"] = true;
      result["char"] = true;
      result["char16_t"] = true;
      result["char32_t"] = true;
      result["class"] = true;
      result["compl"] = true;
      result["const"] = true;
      result["const_cast"] = true;
      result["constexpr"] = true;
      result["continue"] = true;
      result["decltype"] = true;
      result["default"] = true;
      result["delete"] = true;
      result["do"] = true;
      result["double"] = true;
      result["dynamic_cast"] = true;
      result["else"] = true;
      result["enum"] = true;
      result["explicit"] = true;
      result["export"] = true;
      result["extern"] = true;
      result["false"] = true;
      result["float"] = true;
      result["for"] = true;
      result["friend"] = true;
      result["goto"] = true;
      result["if"] = true;
      result["INFINITY"] = true;
      result["inline"] = true;
      result["int"] = true;
      result["long"] = true;
      result["mutable"] = true;
      result["namespace"] = true;
      result["NAN"] = true;
      result["new"] = true;
      result["noexcept"] = true;
      result["not"] = true;
      result["not_eq"] = true;
      result["NULL"] = true;
      result["nullptr"] = true;
      result["operator"] = true;
      result["or"] = true;
      result["or_eq"] = true;
      result["private"] = true;
      result["protected"] = true;
      result["public"] = true;
      result["register"] = true;
      result["reinterpret_cast"] = true;
      result["return"] = true;
      result["short"] = true;
      result["signed"] = true;
      result["sizeof"] = true;
      result["static"] = true;
      result["static_assert"] = true;
      result["static_cast"] = true;
      result["struct"] = true;
      result["switch"] = true;
      result["template"] = true;
      result["this"] = true;
      result["thread_local"] = true;
      result["throw"] = true;
      result["true"] = true;
      result["try"] = true;
      result["typedef"] = true;
      result["typeid"] = true;
      result["typename"] = true;
      result["union"] = true;
      result["unsigned"] = true;
      result["using"] = true;
      result["virtual"] = true;
      result["void"] = true;
      result["volatile"] = true;
      result["wchar_t"] = true;
      result["while"] = true;
      result["xor"] = true;
      result["xor_eq"] = true;
      return result;
    }
  }
}
