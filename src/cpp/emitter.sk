namespace cpp {
  enum Pass {
    NONE,
    FORWARD_DECLARE_TYPES,
    FORWARD_DECLARE_CODE,
    IMPLEMENT_CODE,
  }

  enum CppEmitType {
    BARE,
    NORMAL,
    DECLARATION,
  }

  class Emitter : base.Emitter {
    private {
      List<string> namespaceStack = [];
      var includes = StringMap<bool>();
      var usedAssert = false;
      var usedMath = false;
      var isMarkSweep = false;
      Pass pass = .NONE;
    }

    override string extension() {
      return "cpp";
    }

    override void visitProgram(Node node) {
      // Emit code in three passes
      var collector = Collector(node, .SORT_BY_INHERITANCE_AND_CONTAINMENT);
      isMarkSweep = options.memoryManagement == .MARK_SWEEP;

      pass = .FORWARD_DECLARE_TYPES;
      visitCollector(collector);
      adjustNamespace(null);
      forceEmitExtraNewline();

      pass = .FORWARD_DECLARE_CODE;
      visitCollector(collector);
      adjustNamespace(null);
      forceEmitExtraNewline();

      pass = .IMPLEMENT_CODE;
      visitCollector(collector);
      adjustNamespace(null);

      emitEntryPoint();
      wrapEmittedCode();
    }

    void emitEntryPoint() {
      var entryPointSymbol = resolver.entryPointSymbol;
      if (entryPointSymbol != null) {
        var type = entryPointSymbol.type;
        var hasArguments = type.argumentTypes().size() > 0;
        var hasReturnValue = type.resultType() == cache.intType;
        emitExtraNewlineBefore(.NULL);
        emit(indent + "int main(" + (hasArguments ? "int argc, char **argv" : "") + ") {\n");
        increaseIndent();
        if (hasArguments) {
          assert "<string>" in includes;
          var listType = "List<" + mangleName(cache.stringType.symbol) + ">";
          emit(indent + (isMarkSweep ? "gc::Root<" + listType + "> " : listType + " *") + "args = new " + listType + "();\n");
          emit(indent + "args->_data.insert(args->_data.begin(), argv + 1, argv + argc);\n"); // The method push() may not have been emitted
        }
        emit(indent + (hasReturnValue ? "return " : "") + fullName(entryPointSymbol) + "(" + (hasArguments ? "args" : "") + ");\n");
        decreaseIndent();
        emit(indent + "}\n");
      }
    }

    void wrapEmittedCode() {
      var useFastHack = options.memoryManagement == .NONE_FAST;

      // Some headers need to be force-included
      if (usedAssert) {
        includes["<cassert>"] = true;
      }
      if (useFastHack) {
        includes["<cassert>"] = true;
        includes["<new>"] = true;
        includes[options.config == .WINDOWS ? "<windows.h>" : "<sys/mman.h>"] = true;
      }
      if (isMarkSweep) {
        includes["<stack>"] = true;
        includes["<type_traits>"] = true;
        includes["<unordered_map>"] = true;
        includes["<unordered_set>"] = true;
        includes["<vector>"] = true;
      }
      if (usedMath) {
        includes["<cmath>"] = true;
      }

      // Sort headers for deterministic output
      var headers = includes.keys();
      headers.sort(StringComparison.INSTANCE);

      // Prepend headers if needed
      var text = "";
      if (headers.size() != 0) {
        for (var i = 0; i < headers.size(); i++) {
          var name = headers[i];
          var size = name.size();
          text += "#include " + (size == 0 || name[0] != '<' || name[size - 1] != '>' ? "\"" + name + "\"" : name) + "\n";
        }
        text += "\n";
      }
      if (isMarkSweep) text += @ContentsOfFile("../../lib/mark-sweep.h") + "\n";
      if (text != "") output.contents = text + output.contents;
      if (isMarkSweep) output.contents += "\n" + @ContentsOfFile("../../lib/mark-sweep.cpp");
      if (useFastHack) output.contents += "\n" + @ContentsOfFile("../../lib/fast.cpp");
    }

    override void handleSymbol(Symbol symbol) {
      if (symbol.neededIncludes != null) {
        for (var i = 0; i < symbol.neededIncludes.size(); i++) {
          includes[symbol.neededIncludes[i]] = true;
        }
      }
    }

    override bool shouldEmitExtraNewlineBetween(NodeKind before, NodeKind after) {
      if (pass == .FORWARD_DECLARE_TYPES) {
        return before == .NAMESPACE || after == .NAMESPACE || before.isEnum() || after.isEnum();
      }
      return super(before, after) && (pass != .FORWARD_DECLARE_CODE || !before.isFunction() || !after.isFunction());
    }

    override void emitTypeParameters(Symbol symbol) {
      if (pass == .IMPLEMENT_CODE && symbol.enclosingSymbol.hasParameters()) {
        emitTypeParameters(symbol.enclosingSymbol);
      }
      if (symbol.hasParameters()) {
        emit(indent + "template <");
        for (var i = 0; i < symbol.parameters.size(); i++) {
          if (i != 0) {
            emit(", ");
          }
          emit("typename " + mangleName(symbol.parameters[i]));
        }
        emit(">\n");
      }
    }

    void emitEnumValues(Symbol symbol) {
      var members = symbol.type.sortedMembers();
      var isEnumFlags = symbol.kind == .ENUM_FLAGS;
      var isFirst = true;
      var previous = -1;
      for (var i = 0; i < members.size(); i++) {
        var member = members[i].symbol;
        handleSymbol(member);
        if (member.isEnumValue()) {
          if (isFirst) {
            isFirst = false;
          } else {
            emit(",\n");
          }
          var value = member.constant.asInt();
          emit(indent + mangleName(member));
          if (isEnumFlags || value != previous + 1) {
            emit(" = " + value);
          }
          previous = value;
        }
      }
      if (!isFirst) {
        emit("\n");
      }
    }

    override void emitTypeDeclaration(Symbol symbol) {
      var needsMark = isMarkSweep && symbol.kind == .CLASS;
      handleSymbol(symbol);
      if (symbol.kind.isObject()) {
        if (pass != .IMPLEMENT_CODE) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(symbol.node.kind);
          emitTypeParameters(symbol);
          emit(indent + "struct " + mangleName(symbol));
          if (pass == .FORWARD_DECLARE_CODE) {
            var needsObject = isMarkSweep && (symbol.kind == .INTERFACE || symbol.type.baseClass() == null);
            if (needsObject) {
              emit(" : virtual gc::Object");
            }
            if (symbol.type.hasRelevantTypes()) {
              var types = symbol.type.relevantTypes;
              if (!needsObject) {
                emit(" : ");
              }
              for (var i = 0; i < types.size(); i++) {
                if (i != 0 || needsObject) {
                  emit(", ");
                }
                emitCppType(types[i], .BARE);
              }
            }
            emit(" {\n");
            increaseIndent();
            emitTypeMembers(symbol);
            if (needsMark) {
              emitMarkFunction(symbol);
            }
            decreaseIndent();
            emit(indent + "}");
          }
          emit(";\n");
          emitExtraNewlineAfter(symbol.node.kind);
        } else {
          emitTypeMembers(symbol);
          if (needsMark) {
            emitMarkFunction(symbol);
          }
        }
      }

      else if (symbol.kind == .ENUM) {
        if (pass == .FORWARD_DECLARE_TYPES) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(.ENUM);
          emit(indent + "enum struct " + mangleName(symbol) + " {\n");
          increaseIndent();
          emitEnumValues(symbol);
          decreaseIndent();
          emit(indent + "};\n");
          emitExtraNewlineAfter(.ENUM);
        }
      }

      else if (symbol.kind == .ENUM_FLAGS) {
        if (pass == .FORWARD_DECLARE_TYPES) {
          adjustNamespace(symbol);
          emitExtraNewlineBefore(.ENUM_FLAGS);
          emit(indent + "namespace " + mangleName(symbol) + " {\n");
          increaseIndent();
          emit(indent + "enum {\n");
          increaseIndent();
          emitEnumValues(symbol);
          decreaseIndent();
          emit(indent + "};\n");
          decreaseIndent();
          emit(indent + "}\n");
          emitExtraNewlineAfter(.ENUM_FLAGS);
        }
      }
    }

    void emitMarkFunction(Symbol symbol) {
      if (isMarkSweep && symbol.kind == .CLASS) {
        if (pass == .FORWARD_DECLARE_CODE) {
          emitExtraNewlineBefore(.FUNCTION);
          emit(indent + "virtual void __gc_mark();\n");
          emitExtraNewlineAfter(.FUNCTION);
        }

        else if (pass == .IMPLEMENT_CODE) {
          emitExtraNewlineBefore(.FUNCTION);
          emitTypeParameters(symbol);
          emit(indent + "void ");
          emitEnclosingSymbolPrefix(symbol);
          emit("__gc_mark() {\n");
          increaseIndent();

          var baseClass = symbol.type.baseClass();
          if (baseClass != null) {
            emit(indent + mangleName(baseClass.symbol) + "::__gc_mark();\n");
          }

          var members = symbol.type.sortedMembers();
          for (var i = 0; i < members.size(); i++) {
            var member = members[i].symbol;
            if (member.kind == .INSTANCE_VARIABLE && member.enclosingSymbol == symbol && !member.type.isPrimitive() && !member.type.isEnum()) {
              emit(indent + "gc::mark(" + mangleName(member) + ");\n");
            }
          }

          decreaseIndent();
          emit(indent + "}\n");
          emitExtraNewlineAfter(.FUNCTION);
        }
      }
    }

    void emitEnclosingSymbolPrefix(Symbol enclosingSymbol) {
      if (enclosingSymbol != null && enclosingSymbol.kind != .GLOBAL_NAMESPACE) {
        emit(fullName(enclosingSymbol));
        if (enclosingSymbol.hasParameters()) {
          emit("<");
          for (var i = 0; i < enclosingSymbol.parameters.size(); i++) {
            if (i != 0) {
              emit(", ");
            }
            emit(mangleName(enclosingSymbol.parameters[i]));
          }
          emit(">");
        }
        emit("::");
      }
    }

    override void emitFunction(Symbol symbol) {
      handleSymbol(symbol);
      if (pass != .FORWARD_DECLARE_TYPES) {
        var node = symbol.node;
        var block = node.functionBlock();
        if (block != null || pass == .FORWARD_DECLARE_CODE) {
          adjustNamespace(pass == .FORWARD_DECLARE_CODE ? symbol : null);
          emitExtraNewlineBefore(node.kind);
          emitTypeParameters(symbol);
          emit(indent);
          if (symbol.isExternC() && (pass == .FORWARD_DECLARE_CODE || pass == .IMPLEMENT_CODE)) {
            emit("extern \"C\" ");
          }
          if (pass == .FORWARD_DECLARE_CODE) {
            if (symbol.isStatic()) emit("static ");
            if (symbol.isVirtual()) emit("virtual ");
          }
          if (symbol.kind != .CONSTRUCTOR_FUNCTION) {
            emitCppType(symbol.type.resultType(), .DECLARATION);
          }
          if (pass == .IMPLEMENT_CODE) {
            emitEnclosingSymbolPrefix(symbol.enclosingSymbol);
          }
          emit(mangleName(symbol));
          emitFunctionArguments(symbol);
          if (block == null) {
            emit(" = 0;");
          } else if (pass == .FORWARD_DECLARE_CODE) {
            emit(";");
          } else {
            if (symbol.kind == .CONSTRUCTOR_FUNCTION) {
              var superInitializer = node.superInitializer();
              var memberInitializers = node.memberInitializers();
              var superCallArguments = superInitializer != null ? superInitializer.superCallArguments() : null;
              var hasSuperInitializer = superInitializer != null && superCallArguments.size() > 0;
              var hasMemberInitializers = memberInitializers != null && memberInitializers.hasChildren();
              if (hasSuperInitializer || hasMemberInitializers) {
                emit(" : ");
                if (hasSuperInitializer) {
                  emit(fullName(superInitializer.symbol.enclosingSymbol) + "(");
                  emitCommaSeparatedExpressions(superInitializer.superCallArguments());
                  emit(")");
                  if (hasMemberInitializers) {
                    emit(", ");
                  }
                }
                if (hasMemberInitializers) {
                  for (var i = 0; i < memberInitializers.children.size(); i++) {
                    var initializer = memberInitializers.children[i];
                    var value = initializer.memberInitializerValue();
                    if (i != 0) {
                      emit(", ");
                    }
                    emit(mangleName(initializer.symbol) + "(");
                    if (value.kind != .ERROR) {
                      emitExpression(value, .LOWEST);
                    }
                    emit(")");
                  }
                }
              }
            }
            emitBlock(block);
          }
          emit("\n");
          emitExtraNewlineAfter(node.kind);
        }
      }
    }

    override bool shouldEmitSpaceForUnaryOperator(Node node) {
      return node.kind.isUnaryTypeOperator() ? true : super(node);
    }

    override void emitTypeBeforeVariable(Symbol symbol) {
      if (isMarkSweep && symbol.kind == .GLOBAL_VARIABLE && symbol.type.isReference()) {
        emit("gc::Root<");
        emitCppType(symbol.type, .BARE);
        emit("> ");
      } else {
        emitCppType(symbol.type, .DECLARATION);
      }
    }

    override void emitVariable(Symbol symbol) {
      handleSymbol(symbol);
      if (pass != .FORWARD_DECLARE_TYPES && (pass == .FORWARD_DECLARE_CODE || symbol.kind != .INSTANCE_VARIABLE)) {
        adjustNamespace(pass == .FORWARD_DECLARE_CODE ? symbol : null);
        emitExtraNewlineBefore(symbol.node.kind);
        emit(indent);
        if (symbol.isExternC() && (pass == .FORWARD_DECLARE_CODE || pass == .IMPLEMENT_CODE)) {
          emit("extern \"C\" ");
        } else if (pass == .FORWARD_DECLARE_CODE && symbol.kind.isGlobal()) {
          emit(symbol.isStatic() ? "static " : "extern ");
        }
        emitTypeBeforeVariable(symbol);
        if (pass == .FORWARD_DECLARE_CODE) {
          emit(mangleName(symbol));
        } else {
          emit(fullName(symbol));
          emitAfterVariable(symbol.node);
        }
        emit(";\n");
        emitExtraNewlineAfter(symbol.node.kind);
      }
    }

    override void emitFunctionArgument(Symbol symbol) {
      // Make sure to avoid copies for std::string extension methods
      var useConstReference = symbol.name == "this" && symbol.type.isString(cache);
      if (useConstReference) emit("const ");
      emitCppType(symbol.type, .DECLARATION);
      if (useConstReference) emit("&");
      emit(mangleName(symbol));
      emitAfterVariable(symbol.node);
    }

    override void emitTry(Node node) {
      emit(indent + "try");
      emitBlock(node.tryBlock());
      emit(" catch (...)");
      emitBlock(node.catchBlock());
      emit("\n");
    }

    override void emitBeforeSubsequentForVariable(Node node) {
      var type = node.symbol.type;
      emit(
        type.isReference() || type.isQuoted() && type.symbol.node.kind == .POSTFIX_DEREFERENCE ? ", *" :
        type.isQuoted() && type.symbol.node.kind == .POSTFIX_REFERENCE ? ", &" :
        ", ");
    }

    override void emitForEach(Node node) {
      var symbol = node.forEachVariable().symbol;
      emit(indent + "for (");
      emitTypeBeforeVariable(symbol);
      emit(mangleName(symbol));
      emit(" : ");
      emitExpression(node.forEachValue(), .LOWEST);
      emit(")");
      emitBlock(node.forEachBlock());
      emit("\n");
    }

    override void emitAssert(Node node) {
      emit(indent + "assert(");
      emitExpression(node.assertValue(), .LOWEST);
      emit(");\n");
      usedAssert = true;
    }

    override void emitBinary(Node node, Precedence precedence) {
      // Clang warns about && inside || or & inside | without parentheses
      if (node.parent.kind == .LOGICAL_OR && node.kind == .LOGICAL_AND ||
          node.parent.kind == .BITWISE_OR && node.kind == .BITWISE_AND) {
        precedence = .MEMBER;
      }

      super(node, precedence);
    }

    override void emitNull() {
      emit("nullptr");
    }

    override void emitReal(Node node) {
      var value = node.asDouble();
      if (value == math.INFINITY) {
        usedMath = true;
        emit("INFINITY");
      } else if (value == -math.INFINITY) {
        usedMath = true;
        emit("-INFINITY");
      } else if (value != value) {
        usedMath = true;
        emit("NAN");
      } else {
        emit(doubleToStringWithDot(value) + (node.kind == .FLOAT ? "f" : ""));
      }
    }

    // Avoid generating C++ code that adds two "char *" pointers or that
    // tries to access a member of std::string off a "char *" pointer
    static bool needsWrappedStringConstructor(Node node) {
      var parent = node.parent;
      switch (parent.kind) {
        case .CALL { return node == parent.callValue(); }
        case .HOOK { return parent.hookTrue() == node && parent.hookFalse().kind == .STRING; }
        case .ADD { return parent.binaryLeft() == node && parent.binaryRight().kind == .STRING; }
        case .ASSIGN, .ASSIGN_ADD, .VARIABLE, .MEMBER_INITIALIZER, .RETURN { return false; }
        default { return true; }
      }
    }

    override void emitString(Node node) {
      var content = node.asString();
      var needsLength = "\0" in content;
      var needsWrap = needsLength || needsWrappedStringConstructor(node);

      if (needsWrap) {
        handleSymbol(cache.stringType.symbol);
        emit(mangleName(cache.stringType.symbol) + "(");
      }
      super(node);
      if (needsWrap) {
        if (needsLength) {
          emit(", " + content.size());
        }
        emit(")");
      }
    }

    override void emitDot(Node node) {
      var target = node.dotTarget();
      var dotName = node.dotName();
      if (target != null) {
        emitExpression(target, .MEMBER);
      }
      if (dotName.kind == .QUOTED) {
        dotName = dotName.quotedValue();
      }
      emit(node.kind == .DOT_COLON ? "::" : node.kind == .DOT_ARROW || target != null && target.type.isReference() ? "->" : ".");
      emit(node.symbol != null ? mangleName(node.symbol) : dotName.asString());
    }

    override void emitCall(Node node, Precedence precedence) {
      var value = node.callValue();
      var isNew = value.kind == .TYPE;
      var wrap = isNew && precedence == .MEMBER;
      if (wrap) emit("(");
      if (isNew) {
        emit("new ");
        emitCppType(value.type, .BARE);
      } else {
        emitExpression(value, .UNARY_POSTFIX);
      }
      if (!isNew && value.type != null && value.type.isParameterized()) {
        var substitutions = value.type.substitutions;
        emit("<");
        for (var i = 0; i < substitutions.size(); i++) {
          if (i != 0) {
            emit(", ");
          }
          emitCppType(substitutions[i], .NORMAL);
        }
        emit(">");
      }
      emit("(");
      emitCommaSeparatedExpressions(node.callArguments());
      emit(")");
      if (wrap) emit(")");
    }

    override void emitParenthesizedCast(Type type, Node node, Precedence precedence) {
      // MSVC has a warning that indicates converting numeric types to bool is
      // slow. I have no idea why their compiler can't do this efficiently but
      // the warning is really stupid because all it does is encourage code
      // obfuscation. The warning is "forcing value to bool 'true' or 'false'
      // (performance warning)". The "!!x" boolean-cast trick works in almost
      // all cases but fails for strongly-typed enums, which are missing a
      // unary not operator.
      if (options.config == .WINDOWS && type.isBool(cache)) {
        if (.UNARY_PREFIX < precedence) emit("(");
        emit("!!");
        if (node.type.isPrimitive()) {
          emitExpression(node, .UNARY_PREFIX);
        } else {
          emit("static_cast<int>(");
          emitExpression(node, .UNARY_PREFIX);
          emit(")");
        }
        if (.UNARY_PREFIX < precedence) emit(")");
      }

      // Emit a normal cast
      else {
        emit("static_cast<");
        emitNormalType(type);
        emit(">(");
        emitExpression(node, .LOWEST);
        emit(")");
      }
    }

    override bool shouldEmitCast(Node node) {
      // C++11 doesn't auto-convert enums to ints for some reason
      if (node.type.isInt(cache) && node.castValue().type.isRegularEnum()) {
        return true;
      }

      // C++ doesn't find common types for some reason, so this is an error:
      //
      //   struct Foo {};
      //   struct Bar : Foo {};
      //   struct Baz : Foo {};
      //   Foo *foo = ... ? new Bar : new Baz;
      //
      // This must be used instead:
      //
      //   Foo *foo = ... ? static_cast<Foo *>(new Bar) : new Baz;
      //
      if (node.type.isReference() && node.parent.kind == .HOOK && node.castValue().kind != .NULL && node == node.parent.hookTrue()) {
        return true;
      }

      return super(node);
    }

    override void emitInt(Node node, Precedence precedence) {
      if (node.type.isEnum() && node.symbol != null) {
        emitName(node);
      } else if (node.type.isRegularEnum()) {
        if (.UNARY_PREFIX < precedence) emit("(");
        emit("(");
        emitNormalType(node.type);
        emit(")");
        emit(node.asInt().toString());
        if (.UNARY_PREFIX < precedence) emit(")");
      } else {
        emit(node.asInt().toString());
      }
    }

    override void emitList(Node node, Precedence precedence) {
      var values = node.listValues();
      var wrap = values.size() > 0 || precedence == .MEMBER;
      if (wrap) emit("(");
      emit("new ");
      emitCppType(node.type, .BARE);
      emit("()");
      if (wrap) emit(")");
      if (values.size() != 0) {
        emit("->literal({ ");
        emitCommaSeparatedExpressions(values);
        emit(" })");
      }
    }

    override void emitSuperCall(Node node) {
      emit(fullName(node.symbol));
      emit("(");
      emitCommaSeparatedExpressions(node.superCallArguments());
      emit(")");
    }

    override bool hookNeedsExplicitCast(Node node) {
      return isMarkSweep && node.type.isReference();
    }

    override void emitNormalType(Type type) {
      emitCppType(type, .NORMAL);
    }

    void emitCppType(Type type, CppEmitType mode) {
      if (type.isEnumFlags()) {
        emit("int");
      } else {
        emitType(type);
      }
      if (type.isReference() && mode != .BARE) {
        emit(" *");
      } else if (mode == .DECLARATION && (!type.isQuoted() || !type.symbol.node.kind.isUnaryTypeOperator())) {
        emit(" ");
      }
    }

    override bool useDoubleColonForEnclosingSymbols() {
      return true;
    }

    void adjustNamespace(Symbol symbol) {
      // Get the namespace chain for this symbol
      List<string> names = [];
      while (symbol != null && symbol.kind != .GLOBAL_NAMESPACE) {
        if (symbol.kind == .NAMESPACE) {
          names.unshift(mangleName(symbol));
        }
        symbol = symbol.enclosingSymbol;
      }

      // Find the intersection
      var n = imin(namespaceStack.size(), names.size());
      int i;
      for (i = 0; i < n; i++) {
        if (namespaceStack[i] != names[i]) {
          break;
        }
      }

      // Leave the old namespace
      while (namespaceStack.size() > i) {
        namespaceStack.pop();
        decreaseIndent();
        emit(indent + "}\n");
        emitExtraNewlineAfter(.NAMESPACE);
      }

      // Enter the new namespace
      while (namespaceStack.size() < names.size()) {
        var name = names[namespaceStack.size()];
        emitExtraNewlineBefore(.NAMESPACE);
        emit(indent + "namespace " + name + " {\n");
        increaseIndent();
        namespaceStack.push(name);
      }
    }

    override string mangleName(Symbol symbol) {
      if (symbol.name == "main" && symbol.fullName() == "main") {
        return "_main_";
      }
      return super(symbol);
    }

    override StringMap<bool> createIsKeyword() {
      var result = {
        "alignas": true,
        "alignof": true,
        "and": true,
        "and_eq": true,
        "asm": true,
        "auto": true,
        "bitand": true,
        "bitor": true,
        "bool": true,
        "break": true,
        "case": true,
        "catch": true,
        "char": true,
        "char16_t": true,
        "char32_t": true,
        "class": true,
        "compl": true,
        "const": true,
        "const_cast": true,
        "constexpr": true,
        "continue": true,
        "decltype": true,
        "default": true,
        "delete": true,
        "do": true,
        "double": true,
        "dynamic_cast": true,
        "else": true,
        "enum": true,
        "explicit": true,
        "export": true,
        "extern": true,
        "false": true,
        "float": true,
        "for": true,
        "friend": true,
        "goto": true,
        "if": true,
        "INFINITY": true,
        "inline": true,
        "int": true,
        "long": true,
        "mutable": true,
        "namespace": true,
        "NAN": true,
        "new": true,
        "noexcept": true,
        "not": true,
        "not_eq": true,
        "NULL": true,
        "nullptr": true,
        "operator": true,
        "or": true,
        "or_eq": true,
        "private": true,
        "protected": true,
        "public": true,
        "register": true,
        "reinterpret_cast": true,
        "return": true,
        "short": true,
        "signed": true,
        "sizeof": true,
        "static": true,
        "static_assert": true,
        "static_cast": true,
        "struct": true,
        "switch": true,
        "template": true,
        "this": true,
        "thread_local": true,
        "throw": true,
        "true": true,
        "try": true,
        "typedef": true,
        "typeid": true,
        "typename": true,
        "union": true,
        "unsigned": true,
        "using": true,
        "virtual": true,
        "void": true,
        "volatile": true,
        "wchar_t": true,
        "while": true,
        "xor": true,
        "xor_eq": true,
      };

      // The windows.h header has an excellent selection of very poorly chosen #define names
      if (options.config == .WINDOWS) {
        result["CONST"] = true;
        result["DELETE"] = true;
        result["ERROR"] = true;
        result["EXTERN_C"] = true;
        result["FALSE"] = true;
        result["IN"] = true;
        result["INTERFACE"] = true;
        result["OUT"] = true;
        result["PURE"] = true;
        result["THIS"] = true;
        result["TRUE"] = true;
      }

      return result;
    }
  }
}
