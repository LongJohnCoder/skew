namespace cpp {
  const var NATIVE_LIBRARY = "
import class int {}
import class bool {}
import class float {}
import class double {}
import class string {}

in int {
  string toString() {
    `std::stringstream` ss;
    ss << this;
    return ss.str();
  }
}

in bool {
  inline string toString() { return this ? \"true\" : \"false\"; }
}

in float {
  inline string toString() {
    `std::stringstream` ss;
    ss << this;
    return ss.str();
  }
}

in double {
  inline string toString() {
    `std::stringstream` ss;
    ss << this;
    return ss.str();
  }
}

in string {
  inline {
    string toString() { return this; }
    int size() { return (int)this.`size`(); }
    string slice(int start, int end) { return this.`substr`(start, end - start); }
    string sliceOne(int index) { return fromCodeUnit(codeUnitAt(index)); }
    int indexOf(string value) { return (int)this.`find`(value); }
    int lastIndexOf(string value) { return (int)this.`rfind`(value); }
    static string fromCodeUnit(int value) { return `string`(1, value); }
    @OperatorGet int codeUnitAt(int index) { return `this`[index]; }
    @OperatorIn bool contains(string value) { return indexOf(value) >= 0; }
  }

  string toLowerCase() {
    var clone = this;
    `std::transform(clone.begin(), clone.end(), clone.begin(), ::tolower)`;
    return clone;
  }

  string toUpperCase() {
    var clone = this;
    `std::transform(clone.begin(), clone.end(), clone.begin(), ::toupper)`;
    return clone;
  }

  string join(List<string> values) {
    var result = \"\";
    for (var i = 0; i < values.size(); i++) {
      if (i > 0) result += this;
      result += values[i];
    }
    return result;
  }

  bool startsWith(string prefix) {
    return size() >= prefix.size() && slice(0, prefix.size()) == prefix;
  }

  bool endsWith(string suffix) {
    return size() >= suffix.size() && slice(size() - suffix.size(), size()) == suffix;
  }

  string repeat(int count) {
    var result = \"\";
    for (var i = 0; i < count; i++) result += this;
    return result;
  }
}

interface Comparison<T> {
  virtual int compare(T left, T right);
}

bool bindCompare<T>(Comparison<T> comparison, T left, T right) {
  return comparison.compare(left, right) < 0;
}

class List<T> {
  new(`std::initializer_list<T>` list) : _data = list {}

  int size() {
    return _data.size();
  }

  void push(T value) {
    _data.push_back(value);
  }

  void unshift(T value) {
    insert(0, value);
  }

  List<T> slice(int start, int end) {
    assert start >= 0 && start <= end && end <= size();
    List<T> slice = [];
    slice._data.insert(slice._data.begin(), _data.begin() + start, _data.begin() + end);
    return slice;
  }

  int indexOf(T value) {
    int index = `std`::find(_data.begin(), _data.end(), value) - _data.begin();
    return index == size() ? -1 : index;
  }

  int lastIndexOf(T value) {
    int index = `std`::find(_data.rbegin(), _data.rend(), value) - _data.rbegin();
    return size() - index - 1;
  }

  T shift() {
    T value = this[0];
    remove(0);
    return value;
  }

  T pop() {
    T value = this[size() - 1];
    _data.pop_back();
    return value;
  }

  void reverse() {
    `std`::reverse(_data.begin(), _data.end());
  }

  void sort(Comparison<T> comparison) {
    `std`::sort(_data.begin(), _data.end(), `std`::bind(`&`bindCompare`<T>`, comparison, `std`::placeholders::_1, `std`::placeholders::_2));
  }

  List<T> clone() {
    List<T> clone = [];
    clone._data = _data;
    return clone;
  }

  T remove(int index) {
    T value = this[index];
    _data.erase(_data.begin() + index);
    return value;
  }

  void insert(int index, T value) {
    assert index >= 0 && index <= size();
    _data.insert(_data.begin() + index, value);
  }

  @OperatorGet
  T get(int index) {
    assert index >= 0 && index < size();
    return _data[index];
  }

  @OperatorSet
  void set(int index, T value) {
    assert index >= 0 && index < size();
    _data[index] = value;
  }

  @OperatorIn
  bool contains(T value) {
    return indexOf(value) >= 0;
  }

  void swap(int a, int b) {
    assert a >= 0 && a < size();
    assert b >= 0 && b < size();
    `std`::swap(_data[a], _data[b]);
  }

  `std::vector<T>` _data;
}

class StringMap<T> {
  new() {}
  @OperatorGet T get(string key) { return _table[key]; }
  T getOrDefault(string key, T defaultValue) { `auto` it = _table.find(key); return it != _table.end() ? it->second : defaultValue; }
  @OperatorSet void set(string key, T value) { _table[key] = value; }
  @OperatorIn bool has(string key) { return _table.count(key); }
  void remove(string key) { _table.erase(key); }
  List<string> keys() { List<string> keys = []; for (`(auto &)` it in _table) keys.push(it.first); return keys; }
  List<T> values() { List<T> values = []; for (`(auto &)` it in _table) values.push(it.second); return values; }
  StringMap<T> clone() { var clone = StringMap<T>(); clone._table = _table; return clone; }

  `std::unordered_map<string, T>` _table;
}

class IntMap<T> {
  new() {}
  @OperatorGet T get(int key) { return _table[key]; }
  T getOrDefault(int key, T defaultValue) { `auto` it = _table.find(key); return it != _table.end() ? it->second : defaultValue; }
  @OperatorSet void set(int key, T value) { _table[key] = value; }
  @OperatorIn bool has(int key) { return _table.count(key); }
  void remove(int key) { _table.erase(key); }
  List<int> keys() { List<int> keys = []; for (`(auto &)` it in _table) keys.push(it.first); return keys; }
  List<T> values() { List<T> values = []; for (`(auto &)` it in _table) values.push(it.second); return values; }
  StringMap<T> clone() { var clone = StringMap<T>(); clone._table = _table; return clone; }

  `std::unordered_map<int, T>` _table;
}

namespace math {
  inline {
    double abs(double x) { return `std`::abs(x); }
    double sin(double x) { return `std`::sin(x); }
    double cos(double x) { return `std`::cos(x); }
    double tan(double x) { return `std`::tan(x); }
    double asin(double x) { return `std`::asin(x); }
    double acos(double x) { return `std`::acos(x); }
    double atan(double x) { return `std`::atan(x); }
    double atan2(double y, double x) { return `std`::atan2(y, x); }
    double sqrt(double x) { return `std`::sqrt(x); }
    double exp(double x) { return `std`::exp(x); }
    double log(double x) { return `std`::log(x); }
    double pow(double x, double y) { return `std`::pow(x, y); }
    double floor(double x) { return `std`::floor(x); }
    double round(double x) { return `std`::round(x); }
    double ceil(double x) { return `std`::ceil(x); }
    double min(double x, double y) { return `std`::fmin(x, y); }
    double max(double x, double y) { return `std`::fmax(x, y); }
  }

  const {
    double SQRT2 = 1.414213562373095;
    double PI = 3.141592653589793;
    double E = 2.718281828459045;
    double INFINITY = 1 / 0.0;
    double NAN = 0 / 0.0;
  }
}
";
}
