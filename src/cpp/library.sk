namespace cpp {
  const var NATIVE_LIBRARY = "
import class int {}
import class bool {}
import class float {}
import class double {}
import class string {}

in int {
  string toString() {
    untyped(std::stringstream) ss;
    ss << this;
    return ss.str();
  }
}

in bool {
  inline string toString() { return this ? \"true\" : \"false\"; }
}

in float {
  inline string toString() { return ((double)this).toString(); }
}

in double {
  inline string toString() {
    untyped(std::stringstream) ss;
    untyped(ss << std::setprecision(std::numeric_limits<double>::digits10 + 1) << std::fixed) << this;
    string result = ss.str();
    while (untyped(result.back()) == '0') untyped(result.pop_back());
    if (untyped(result.back()) == '.') untyped(result.pop_back());
    return result;
  }
}

in string {
  inline {
    int size() { return (int)untyped(this.size()); }
    string slice(int start, int end) { return untyped(this.substr(typed(start), typed(end) - typed(start))); }
    int indexOf(string value) { return (int)untyped(this.find(typed(value))); }
    int lastIndexOf(string value) { return (int)untyped(this.rfind(typed(value))); }
    static string fromCodeUnit(int value) { return untyped(string(1, typed(value))); }
    string get(int index) { return fromCodeUnit(codeUnitAt(index)); }
    int codeUnitAt(int index) { return untyped(this[typed(index)]); }
  }

  string toLowerCase() {
    var clone = this;
    untyped(std::transform(clone.begin(), clone.end(), clone.begin(), ::tolower));
    return clone;
  }

  string toUpperCase() {
    var clone = this;
    untyped(std::transform(clone.begin(), clone.end(), clone.begin(), ::toupper));
    return clone;
  }

  string join(List<string> values) {
    var result = \"\";
    for (var i = 0; i < values.size(); i++) {
      if (i > 0) result += this;
      result += values.get(i);
    }
    return result;
  }

  bool startsWith(string prefix) {
    return size() >= prefix.size() && slice(0, prefix.size()) == prefix;
  }

  bool endsWith(string suffix) {
    return size() >= suffix.size() && slice(size() - suffix.size(), size()) == suffix;
  }

  string repeat(int count) {
    var result = \"\";
    for (var i = 0; i < count; i++) result += this;
    return result;
  }
}

import interface Comparison<T> {
  virtual int compare(T left, T right);
}

import class List<T> {
  new();
  int size();
  void push(T value);
  void unshift(T value);
  List<T> slice(int start, int end);
  int indexOf(T value);
  int lastIndexOf(T value);
  T shift();
  T pop();
  void reverse();
  void sort(Comparison<T> comparison);
  List<T> clone();
  T remove(int index);
  void insert(int index, T value);
  T get(int index);
  void set(int index, T value);
  void swap(int a, int b);
}

class StringMap<T> {
  new() {}
  T get(string key) { return _table[key]; }
  T getOrDefault(string key, T defaultValue) { untyped(auto) it = _table.find(key); return it != _table.end() ? it->second : defaultValue; }
  void set(string key, T value) { _table[key] = value; }
  bool has(string key) { return _table.count(key); }
  void remove(string key) { _table.erase(key); }
  List<string> keys() { var keys = List<string>(); for (untyped(auto &) it in _table) keys.push(it.first); return keys; }
  List<T> values() { var values = List<T>(); for (untyped(auto &) it in _table) values.push(it.second); return values; }
  StringMap<T> clone() { var clone = StringMap<T>(); clone._table = _table; return clone; }

  untyped(std::unordered_map<string, T>) _table;
}

class IntMap<T> {
  new() {}
  T get(int key) { return _table[key]; }
  T getOrDefault(int key, T defaultValue) { untyped(auto) it = _table.find(key); return it != _table.end() ? it->second : defaultValue; }
  void set(int key, T value) { _table[key] = value; }
  bool has(int key) { return _table.count(key); }
  void remove(int key) { _table.erase(key); }
  List<int> keys() { var keys = List<int>(); for (untyped(auto &) it in _table) keys.push(it.first); return keys; }
  List<T> values() { var values = List<T>(); for (untyped(auto &) it in _table) values.push(it.second); return values; }
  StringMap<T> clone() { var clone = StringMap<T>(); clone._table = _table; return clone; }

  untyped(std::unordered_map<int, T>) _table;
}

namespace math {
  inline {
    double abs(double x) { return untyped(std::abs(typed(x))); }
    double sin(double x) { return untyped(std::sin(typed(x))); }
    double cos(double x) { return untyped(std::cos(typed(x))); }
    double tan(double x) { return untyped(std::tan(typed(x))); }
    double asin(double x) { return untyped(std::asin(typed(x))); }
    double acos(double x) { return untyped(std::acos(typed(x))); }
    double atan(double x) { return untyped(std::atan(typed(x))); }
    double atan2(double y, double x) { return untyped(std::atan2(typed(y), typed(x))); }
    double sqrt(double x) { return untyped(std::sqrt(typed(x))); }
    double exp(double x) { return untyped(std::exp(typed(x))); }
    double log(double x) { return untyped(std::log(typed(x))); }
    double pow(double x, double y) { return untyped(std::pow(typed(x), typed(y))); }
    double floor(double x) { return untyped(std::floor(typed(x))); }
    double round(double x) { return untyped(std::round(typed(x))); }
    double ceil(double x) { return untyped(std::ceil(typed(x))); }
    double min(double x, double y) { return untyped(std::fmin(typed(x), typed(y))); }
    double max(double x, double y) { return untyped(std::fmax(typed(x), typed(y))); }
  }

  const {
    double SQRT2 = 1.414213562373095;
    double PI = 3.141592653589793;
    double E = 2.718281828459045;
    double INFINITY = 1 / 0.0;
    double NAN = 0 / 0.0;
  }
}
";
}
