namespace cpp {
  const var NATIVE_LIBRARY = "
import void cpp_toString();
import string cpp_fromCodeUnit(int value);
import string cpp_toLowerCase(string value);
import string cpp_toUpperCase(string value);

import class int {}
import class bool {}
import class float {}
import class double {}
import class string {}

in int {
  inline string toString() { return untyped(cpp_toString)(this); }
}

in bool {
  inline string toString() { return this ? \"true\" : \"false\"; }
}

in float {
  inline string toString() { return untyped(cpp_toString)(this); }
}

in double {
  inline string toString() { return untyped(cpp_toString)(this); }
}

in string {
  inline {
    int size() { return (int)untyped(this).size(); }
    string slice(int start, int end) { return untyped(this).substr(start, end - start); }
    int indexOf(string value) { return (int)untyped(this).find(value); }
    int lastIndexOf(string value) { return (int)untyped(this).rfind(value); }
    string toLowerCase() { return cpp_toLowerCase(this); }
    string toUpperCase() { return cpp_toUpperCase(this); }
    static string fromCodeUnit(int value) { return cpp_fromCodeUnit(value); }
    string get(int index) { return fromCodeUnit(codeUnitAt(index)); }
    int codeUnitAt(int index) { return untyped(this)[index]; }
  }
  string join(List<string> values) { var result = \"\"; for (var i = 0; i < values.size(); i++) { if (i > 0) result += this; result += values.get(i); } return result; }
  bool startsWith(string prefix) { return size() >= prefix.size() && slice(0, prefix.size()) == prefix; }
  bool endsWith(string suffix) { return size() >= suffix.size() && slice(size() - suffix.size(), size()) == suffix; }
  string repeat(int count) { var result = \"\"; for (var i = 0; i < count; i++) result += this; return result; }
}

import interface Comparison<T> {
  virtual int compare(T left, T right);
}

import class List<T> {
  new();
  int size();
  void push(T value);
  void unshift(T value);
  List<T> slice(int start, int end);
  int indexOf(T value);
  int lastIndexOf(T value);
  T shift();
  T pop();
  void reverse();
  void sort(Comparison<T> comparison);
  List<T> clone();
  T remove(int index);
  void insert(int index, T value);
  T get(int index);
  void set(int index, T value);
  void swap(int a, int b);
}

import class StringMap<T> {
  new();
  T get(string key);
  T getOrDefault(string key, T defaultValue);
  void set(string key, T value);
  bool has(string key);
  void remove(string key);
  List<string> keys();
  List<T> values();
  StringMap<T> clone();
}

import class IntMap<T> {
  new();
  T get(int key);
  T getOrDefault(int key, T defaultValue);
  void set(int key, T value);
  bool has(int key);
  void remove(int key);
  List<int> keys();
  List<T> values();
  IntMap<T> clone();
}

import namespace std {
  double abs(double x);
  double sin(double x);
  double cos(double x);
  double tan(double x);
  double asin(double x);
  double acos(double x);
  double atan(double x);
  double atan2(double y, double x);
  double sqrt(double x);
  double exp(double x);
  double log(double x);
  double pow(double x, double y);
  double floor(double x);
  double round(double x);
  double ceil(double x);
  double fmin(double x, double y);
  double fmax(double x, double y);
}

import namespace math {}

in math {
  inline double abs(double x) { return std.abs(x); }
  inline double sin(double x) { return std.sin(x); }
  inline double cos(double x) { return std.cos(x); }
  inline double tan(double x) { return std.tan(x); }
  inline double asin(double x) { return std.asin(x); }
  inline double acos(double x) { return std.acos(x); }
  inline double atan(double x) { return std.atan(x); }
  inline double atan2(double y, double x) { return std.atan2(y, x); }
  inline double sqrt(double x) { return std.sqrt(x); }
  inline double exp(double x) { return std.exp(x); }
  inline double log(double x) { return std.log(x); }
  inline double pow(double x, double y) { return std.pow(x, y); }
  inline double floor(double x) { return std.floor(x); }
  inline double round(double x) { return std.round(x); }
  inline double ceil(double x) { return std.ceil(x); }
  inline double min(double x, double y) { return std.fmin(x, y); }
  inline double max(double x, double y) { return std.fmax(x, y); }

  const double SQRT2 = 1.414213562373095;
  const double PI = 3.141592653589793;
  const double E = 2.718281828459045;
  const double INFINITY = 1 / 0.0;
  const double NAN = 0 / 0.0;
}
";
}
